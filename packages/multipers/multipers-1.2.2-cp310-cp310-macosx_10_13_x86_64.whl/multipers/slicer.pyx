# WARNING: Do not edit this file directly.
# It is automatically generated from 'multipers/slicer.pyx.tp'.
# Changes must be made there.


from multipers.simplex_tree_multi import SimplexTreeMulti
import multipers
from typing import Optional,Literal
import multipers.io as mio
import multipers.grids as mpg
import threading
import os 

from multipers.slicer cimport *
from multipers.filtrations cimport *
from multipers.filtration_conversions cimport *
import numpy as np
cimport cython
# python_value_type = np.float32
from typing import Union

global available_slicers
available_slicers = tuple((
  _SlicerClement,
  _SlicerVineGraph,
  _SlicerVineSimplicial,
  _SlicerNoVineSimplicial,
  _KSlicer0_vine_i32,
  _KSlicer0_vine_f32,
  _KSlicer0_vine_f64,
  _Slicer0_vine_i32,
  _Slicer0_vine_f32,
  _Slicer0_vine_f64,
  _KSlicer0_i32,
  _KSlicer0_f32,
  _KSlicer0_f64,
  _Slicer0_i32,
  _Slicer0_f32,
  _Slicer0_f64,
))
global _slicers_type
Slicer_type = Union[
  _SlicerClement,
  _SlicerVineGraph,
  _SlicerVineSimplicial,
  _SlicerNoVineSimplicial,
  _KSlicer0_vine_i32,
  _KSlicer0_vine_f32,
  _KSlicer0_vine_f64,
  _Slicer0_vine_i32,
  _Slicer0_vine_f32,
  _Slicer0_vine_f64,
  _KSlicer0_i32,
  _KSlicer0_f32,
  _KSlicer0_f64,
  _Slicer0_i32,
  _Slicer0_f32,
  _Slicer0_f64,

]


#------------------------------------------------------------------------------
cdef class _SlicerClement:
    cdef GeneralVineClementTruc truc
    cdef public vector[vector[double]] filtration_grid
    @property
    def is_squeezed(self)->bool:
        return self.filtration_grid.size() > 0 and self.filtration_grid[0].size() > 0

    def get_ptr(self):
        """
        Returns a pointer to the underlying C++ slicer.
        """
        return <intptr_t>(&self.truc)
    def __init__(self, generator_maps=[], generator_dimensions=[], filtration_values=[]):        
        """
        Constructs a slicer from
         - generator maps (Iterable of list of ints)
         - generator dimensions (Iterable of int)
         - filtration values (Iterable of filtration values)
        """
        pass
    def __cinit__(self, generator_maps=[], generator_dimensions=[], filtration_values=[]):
        """
        Cython constructor
        """
        cdef uint32_t num_generators = len(generator_maps)
        cdef vector[vector[uint32_t]] c_generator_maps
        cdef vector[Finitely_critical_multi_filtration[float]] c_filtration_values
        for stuff in generator_maps:
            c_generator_maps.push_back(<vector[uint32_t]>(stuff))
        for f in filtration_values:
            # cf.clear()
            # for truc in f:
            #     cf.push_back(truc)
            c_filtration_values.push_back(_py21c_f32(f))
        cdef vector[int] c_generator_dimensions = generator_dimensions
        assert num_generators == c_generator_maps.size() == c_filtration_values.size(), "Invalid input, shape do not coincide."
        self.truc = GeneralVineClementTruc(c_generator_maps,c_generator_dimensions, c_filtration_values)
    def copy(self):
        """
        Returns a copy of the slicer.
        """
        copy_ = _SlicerClement()
        copy_.truc = self.truc
        return copy_
    def get_barcode(self):
        """
        Returns the current barcode.
        """
        return self.truc.get_barcode()
    def push_to_line(self, basepoint, direction=None):
        """
        Pushes the current slicer to the line
        """
        cdef Line[float] line
        if direction is None:
            line = Line[float](_py21c_f32(basepoint))
        else:
            line = Line[float](_py21c_f32(basepoint),_py21c_f32(direction))
        self.truc.push_to(line)        
        return self

    def persistence_on_line(self,basepoint,direction=None):
        """
        Computes the persistence on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        self.truc.compute_persistence()
        return self.truc.get_barcode()
    def compute_persistence(self,one_filtration=None):
        """
        Computes the current persistence, or the persistence
        given by the filtration one_filtration (num_generators,).
        """
        if one_filtration is not None:
            self.truc.set_one_filtration(one_filtration)
        self.truc.compute_persistence()
        # return self.truc.get_barcode()
    def get_barcode(self):
        """
        Returns the barcode of the current 1d-persistence.
        """
        return self.truc.get_barcode()
    def sliced_filtration(self,basepoint, direction=None):
        """
        Computes the filtration on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        return np.asarray(self.truc.get_one_filtration())
    def __len__(self):
        return self.truc.num_generators()
    @property
    def num_generators(self):
        return self.truc.num_generators()
    @property
    def num_parameters(self):
        return self.truc.num_parameters()
    def info(self):
        return self.truc.to_str().decode()
    def compute_box(self):
        """
        Computes the bounding box of the current persistence.
        """
        cdef pair[Finitely_critical_multi_filtration[float],Finitely_critical_multi_filtration[float]] box = self.truc.get_bounding_box()
        cdef cnp.ndarray[float, ndim=1] a = _ff21cview_f32(&box.first)
        cdef cnp.ndarray[float, ndim=1] b = _ff21cview_f32(&box.second)
        return np.asarray([a,b])
    def get_filtrations_values(self):
        """
        Returns the current filtration values of the slicer.
        """
        cdef vector[Finitely_critical_multi_filtration[float]] v = self.truc.get_filtration_values()
        out = _vff21cview_f32(v, copy=True)
        return np.asarray(out)
    def get_filtrations(self):
        return _vff21cview_f32(self.truc.get_filtrations(), copy=True)

    def get_dimensions(self):
        """
        Returns the ordered dimensions of the generators.
        """
        return np.asarray(self.truc.get_dimensions())
    def get_boundaries(self):
        """
        Returns the boundaries of the generators.
        """
        return tuple(tuple(b) for b in self.truc.get_boundaries())
    def grid_squeeze(self, filtration_grid=None, grid_strategy="exact", resolution=-1, bool coordinates=True, bool inplace = False, bool force=False):
        """
        Squeeze the filtration values on a grid.
        """
        if force and self.is_squeezed:
            raise ValueError("The slicer seems to be already squeezed. Use force=True to resqueeze.")
        if filtration_grid is None:
            filtration_grid = mpg.compute_grid(
                    self.get_filtrations_values().T,
                    strategy=grid_strategy,
                    resolution=resolution)
        cdef vector[vector[float]] grid = filtration_grid
        if inplace or not coordinates:
            self.truc.coarsen_on_grid_inplace(grid, coordinates)
            self.filtration_grid = filtration_grid
        else:
          raise ValueError("WIP")
        return self
    def minpres(self,
        int degree = 1, 
        list[int] degrees=[],
        str backend:Literal["mpfree", "2pac"]="mpfree", 
        str slicer_backend:Literal["matrix","clement","graph"]="matrix",
        bool vineyard=True, 
        id :Optional[str] = None,
        dtype = np.float32,
        **minpres_kwargs
        ):
        """
        Computes the minimal presentation of the slicer, and returns it as a new slicer.
        """
        new_slicer = minimal_presentation(self, degree=degree, degrees=degrees, backend=backend, slicer_backend=slicer_backend, vineyard=vineyard, id=id, **minpres_kwargs)
        return new_slicer

    @property
    def dtype(self)->type:
      return np.float32
    @property
    def col_type(self)->str:
      return ""
    @property
    def is_vine(self)->bool:
      return True
    @property
    def is_kcritical(self)->bool:
      return False


    def vine_update(self,basepoint,direction=None):
        """
        Updates the barcode, on a line, using the vineyard algorithm.
        """
        self.push_to_line(basepoint,direction)
        self.truc.vineyard_update()
        return self
    def get_representative_cycles(self, bool update=True):
        """
        Returns the representative cycles of the current barcode.
        Recomputes the generators if update=True
        """
        return self.truc.get_representative_cycles(update)
    def get_permutation(self):
        """
        Returns the current generator permutation (w.r.t. vineyard).
        """
        return self.truc.get_current_order()

    @staticmethod
    def from_bitmap(self):
      raise ValueError("Not implemented.")

#------------------------------------------------------------------------------
cdef class _SlicerVineGraph:
    cdef SimplicialVineGraphTruc truc
    cdef public vector[vector[double]] filtration_grid
    @property
    def is_squeezed(self)->bool:
        return self.filtration_grid.size() > 0 and self.filtration_grid[0].size() > 0

    def get_ptr(self):
        """
        Returns a pointer to the underlying C++ slicer.
        """
        return <intptr_t>(&self.truc)
    def __init__(self, st=None):
        """
        Constructs a slicer from a simplex tree.
        """
        pass
    def __cinit__(self, st=None):
        if st is None:
            return
        cdef intptr_t ptr = st.thisptr
        cdef Simplex_tree_multi_interface[Finitely_critical_multi_filtration[float],float]* st_ptr = <Simplex_tree_multi_interface[Finitely_critical_multi_filtration[float],float]*>(ptr)
        self.truc = SimplicialVineGraphTruc(st_ptr)
    def copy(self):
        """
        Returns a copy of the slicer.
        """
        copy_ = _SlicerVineGraph()
        copy_.truc = self.truc
        return copy_
    def get_barcode(self):
        """
        Returns the current barcode.
        """
        return self.truc.get_barcode()
    def push_to_line(self, basepoint, direction=None):
        """
        Pushes the current slicer to the line
        """
        cdef Line[float] line
        if direction is None:
            line = Line[float](_py21c_f32(basepoint))
        else:
            line = Line[float](_py21c_f32(basepoint),_py21c_f32(direction))
        self.truc.push_to(line)        
        return self

    def persistence_on_line(self,basepoint,direction=None):
        """
        Computes the persistence on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        self.truc.compute_persistence()
        return self.truc.get_barcode()
    def compute_persistence(self,one_filtration=None):
        """
        Computes the current persistence, or the persistence
        given by the filtration one_filtration (num_generators,).
        """
        if one_filtration is not None:
            self.truc.set_one_filtration(one_filtration)
        self.truc.compute_persistence()
        # return self.truc.get_barcode()
    def get_barcode(self):
        """
        Returns the barcode of the current 1d-persistence.
        """
        return self.truc.get_barcode()
    def sliced_filtration(self,basepoint, direction=None):
        """
        Computes the filtration on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        return np.asarray(self.truc.get_one_filtration())
    def __len__(self):
        return self.truc.num_generators()
    @property
    def num_generators(self):
        return self.truc.num_generators()
    @property
    def num_parameters(self):
        return self.truc.num_parameters()
    def info(self):
        return self.truc.to_str().decode()
    def compute_box(self):
        """
        Computes the bounding box of the current persistence.
        """
        cdef pair[Finitely_critical_multi_filtration[float],Finitely_critical_multi_filtration[float]] box = self.truc.get_bounding_box()
        cdef cnp.ndarray[float, ndim=1] a = _ff21cview_f32(&box.first)
        cdef cnp.ndarray[float, ndim=1] b = _ff21cview_f32(&box.second)
        return np.asarray([a,b])
    def get_filtrations_values(self):
        """
        Returns the current filtration values of the slicer.
        """
        cdef vector[Finitely_critical_multi_filtration[float]] v = self.truc.get_filtration_values()
        out = _vff21cview_f32(v, copy=True)
        return np.asarray(out)
    def get_filtrations(self):
        return _vff21cview_f32(self.truc.get_filtrations(), copy=True)

    def get_dimensions(self):
        """
        Returns the ordered dimensions of the generators.
        """
        return np.asarray(self.truc.get_dimensions())
    def get_boundaries(self):
        """
        Returns the boundaries of the generators.
        """
        return tuple(tuple(b) for b in self.truc.get_boundaries())
    def grid_squeeze(self, filtration_grid=None, grid_strategy="exact", resolution=-1, bool coordinates=True, bool inplace = False, bool force=False):
        """
        Squeeze the filtration values on a grid.
        """
        if force and self.is_squeezed:
            raise ValueError("The slicer seems to be already squeezed. Use force=True to resqueeze.")
        if filtration_grid is None:
            filtration_grid = mpg.compute_grid(
                    self.get_filtrations_values().T,
                    strategy=grid_strategy,
                    resolution=resolution)
        cdef vector[vector[float]] grid = filtration_grid
        if inplace or not coordinates:
            self.truc.coarsen_on_grid_inplace(grid, coordinates)
            self.filtration_grid = filtration_grid
        else:
          raise ValueError("WIP")
        return self
    def minpres(self,
        int degree = 1, 
        list[int] degrees=[],
        str backend:Literal["mpfree", "2pac"]="mpfree", 
        str slicer_backend:Literal["matrix","clement","graph"]="matrix",
        bool vineyard=True, 
        id :Optional[str] = None,
        dtype = np.float32,
        **minpres_kwargs
        ):
        """
        Computes the minimal presentation of the slicer, and returns it as a new slicer.
        """
        new_slicer = minimal_presentation(self, degree=degree, degrees=degrees, backend=backend, slicer_backend=slicer_backend, vineyard=vineyard, id=id, **minpres_kwargs)
        return new_slicer

    @property
    def dtype(self)->type:
      return np.float32
    @property
    def col_type(self)->str:
      return ""
    @property
    def is_vine(self)->bool:
      return True
    @property
    def is_kcritical(self)->bool:
      return False


    def vine_update(self,basepoint,direction=None):
        """
        Updates the barcode, on a line, using the vineyard algorithm.
        """
        self.push_to_line(basepoint,direction)
        self.truc.vineyard_update()
        return self
    def get_representative_cycles(self, bool update=True):
        """
        Returns the representative cycles of the current barcode.
        Recomputes the generators if update=True
        """
        return self.truc.get_representative_cycles(update)
    def get_permutation(self):
        """
        Returns the current generator permutation (w.r.t. vineyard).
        """
        return self.truc.get_current_order()

    @staticmethod
    def from_bitmap(self):
      raise ValueError("Not implemented.")

#------------------------------------------------------------------------------
cdef class _SlicerVineSimplicial:
    cdef SimplicialVineMatrixTruc truc
    cdef public vector[vector[double]] filtration_grid
    @property
    def is_squeezed(self)->bool:
        return self.filtration_grid.size() > 0 and self.filtration_grid[0].size() > 0

    def get_ptr(self):
        """
        Returns a pointer to the underlying C++ slicer.
        """
        return <intptr_t>(&self.truc)
    def __init__(self, st=None):
        """
        Constructs a slicer from a simplex tree.
        """
        pass
    def __cinit__(self, st=None):
        if st is None:
            return
        cdef intptr_t ptr = st.thisptr
        cdef Simplex_tree_multi_interface[Finitely_critical_multi_filtration[float],float]* st_ptr = <Simplex_tree_multi_interface[Finitely_critical_multi_filtration[float],float]*>(ptr)
        self.truc = SimplicialVineMatrixTruc(st_ptr)
    def copy(self):
        """
        Returns a copy of the slicer.
        """
        copy_ = _SlicerVineSimplicial()
        copy_.truc = self.truc
        return copy_
    def get_barcode(self):
        """
        Returns the current barcode.
        """
        return self.truc.get_barcode()
    def push_to_line(self, basepoint, direction=None):
        """
        Pushes the current slicer to the line
        """
        cdef Line[float] line
        if direction is None:
            line = Line[float](_py21c_f32(basepoint))
        else:
            line = Line[float](_py21c_f32(basepoint),_py21c_f32(direction))
        self.truc.push_to(line)        
        return self

    def persistence_on_line(self,basepoint,direction=None):
        """
        Computes the persistence on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        self.truc.compute_persistence()
        return self.truc.get_barcode()
    def compute_persistence(self,one_filtration=None):
        """
        Computes the current persistence, or the persistence
        given by the filtration one_filtration (num_generators,).
        """
        if one_filtration is not None:
            self.truc.set_one_filtration(one_filtration)
        self.truc.compute_persistence()
        # return self.truc.get_barcode()
    def get_barcode(self):
        """
        Returns the barcode of the current 1d-persistence.
        """
        return self.truc.get_barcode()
    def sliced_filtration(self,basepoint, direction=None):
        """
        Computes the filtration on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        return np.asarray(self.truc.get_one_filtration())
    def __len__(self):
        return self.truc.num_generators()
    @property
    def num_generators(self):
        return self.truc.num_generators()
    @property
    def num_parameters(self):
        return self.truc.num_parameters()
    def info(self):
        return self.truc.to_str().decode()
    def compute_box(self):
        """
        Computes the bounding box of the current persistence.
        """
        cdef pair[Finitely_critical_multi_filtration[float],Finitely_critical_multi_filtration[float]] box = self.truc.get_bounding_box()
        cdef cnp.ndarray[float, ndim=1] a = _ff21cview_f32(&box.first)
        cdef cnp.ndarray[float, ndim=1] b = _ff21cview_f32(&box.second)
        return np.asarray([a,b])
    def get_filtrations_values(self):
        """
        Returns the current filtration values of the slicer.
        """
        cdef vector[Finitely_critical_multi_filtration[float]] v = self.truc.get_filtration_values()
        out = _vff21cview_f32(v, copy=True)
        return np.asarray(out)
    def get_filtrations(self):
        return _vff21cview_f32(self.truc.get_filtrations(), copy=True)

    def get_dimensions(self):
        """
        Returns the ordered dimensions of the generators.
        """
        return np.asarray(self.truc.get_dimensions())
    def get_boundaries(self):
        """
        Returns the boundaries of the generators.
        """
        return tuple(tuple(b) for b in self.truc.get_boundaries())
    def grid_squeeze(self, filtration_grid=None, grid_strategy="exact", resolution=-1, bool coordinates=True, bool inplace = False, bool force=False):
        """
        Squeeze the filtration values on a grid.
        """
        if force and self.is_squeezed:
            raise ValueError("The slicer seems to be already squeezed. Use force=True to resqueeze.")
        if filtration_grid is None:
            filtration_grid = mpg.compute_grid(
                    self.get_filtrations_values().T,
                    strategy=grid_strategy,
                    resolution=resolution)
        cdef vector[vector[float]] grid = filtration_grid
        if inplace or not coordinates:
            self.truc.coarsen_on_grid_inplace(grid, coordinates)
            self.filtration_grid = filtration_grid
        else:
          raise ValueError("WIP")
        return self
    def minpres(self,
        int degree = 1, 
        list[int] degrees=[],
        str backend:Literal["mpfree", "2pac"]="mpfree", 
        str slicer_backend:Literal["matrix","clement","graph"]="matrix",
        bool vineyard=True, 
        id :Optional[str] = None,
        dtype = np.float32,
        **minpres_kwargs
        ):
        """
        Computes the minimal presentation of the slicer, and returns it as a new slicer.
        """
        new_slicer = minimal_presentation(self, degree=degree, degrees=degrees, backend=backend, slicer_backend=slicer_backend, vineyard=vineyard, id=id, **minpres_kwargs)
        return new_slicer

    @property
    def dtype(self)->type:
      return np.float32
    @property
    def col_type(self)->str:
      return ""
    @property
    def is_vine(self)->bool:
      return True
    @property
    def is_kcritical(self)->bool:
      return False


    def vine_update(self,basepoint,direction=None):
        """
        Updates the barcode, on a line, using the vineyard algorithm.
        """
        self.push_to_line(basepoint,direction)
        self.truc.vineyard_update()
        return self
    def get_representative_cycles(self, bool update=True):
        """
        Returns the representative cycles of the current barcode.
        Recomputes the generators if update=True
        """
        return self.truc.get_representative_cycles(update)
    def get_permutation(self):
        """
        Returns the current generator permutation (w.r.t. vineyard).
        """
        return self.truc.get_current_order()

    @staticmethod
    def from_bitmap(self):
      raise ValueError("Not implemented.")

#------------------------------------------------------------------------------
cdef class _SlicerNoVineSimplicial:
    cdef SimplicialNoVineMatrixTruc truc
    cdef public vector[vector[double]] filtration_grid
    @property
    def is_squeezed(self)->bool:
        return self.filtration_grid.size() > 0 and self.filtration_grid[0].size() > 0

    def get_ptr(self):
        """
        Returns a pointer to the underlying C++ slicer.
        """
        return <intptr_t>(&self.truc)
    def __init__(self, st=None):
        """
        Constructs a slicer from a simplex tree.
        """
        pass
    def __cinit__(self, st=None):
        if st is None:
            return
        cdef intptr_t ptr = st.thisptr
        cdef Simplex_tree_multi_interface[Finitely_critical_multi_filtration[float],float]* st_ptr = <Simplex_tree_multi_interface[Finitely_critical_multi_filtration[float],float]*>(ptr)
        self.truc = SimplicialNoVineMatrixTruc(st_ptr)
    def copy(self):
        """
        Returns a copy of the slicer.
        """
        copy_ = _SlicerNoVineSimplicial()
        copy_.truc = self.truc
        return copy_
    def get_barcode(self):
        """
        Returns the current barcode.
        """
        return self.truc.get_barcode()
    def push_to_line(self, basepoint, direction=None):
        """
        Pushes the current slicer to the line
        """
        cdef Line[float] line
        if direction is None:
            line = Line[float](_py21c_f32(basepoint))
        else:
            line = Line[float](_py21c_f32(basepoint),_py21c_f32(direction))
        self.truc.push_to(line)        
        return self

    def persistence_on_line(self,basepoint,direction=None):
        """
        Computes the persistence on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        self.truc.compute_persistence()
        return self.truc.get_barcode()
    def compute_persistence(self,one_filtration=None):
        """
        Computes the current persistence, or the persistence
        given by the filtration one_filtration (num_generators,).
        """
        if one_filtration is not None:
            self.truc.set_one_filtration(one_filtration)
        self.truc.compute_persistence()
        # return self.truc.get_barcode()
    def get_barcode(self):
        """
        Returns the barcode of the current 1d-persistence.
        """
        return self.truc.get_barcode()
    def sliced_filtration(self,basepoint, direction=None):
        """
        Computes the filtration on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        return np.asarray(self.truc.get_one_filtration())
    def __len__(self):
        return self.truc.num_generators()
    @property
    def num_generators(self):
        return self.truc.num_generators()
    @property
    def num_parameters(self):
        return self.truc.num_parameters()
    def info(self):
        return self.truc.to_str().decode()
    def compute_box(self):
        """
        Computes the bounding box of the current persistence.
        """
        cdef pair[Finitely_critical_multi_filtration[float],Finitely_critical_multi_filtration[float]] box = self.truc.get_bounding_box()
        cdef cnp.ndarray[float, ndim=1] a = _ff21cview_f32(&box.first)
        cdef cnp.ndarray[float, ndim=1] b = _ff21cview_f32(&box.second)
        return np.asarray([a,b])
    def get_filtrations_values(self):
        """
        Returns the current filtration values of the slicer.
        """
        cdef vector[Finitely_critical_multi_filtration[float]] v = self.truc.get_filtration_values()
        out = _vff21cview_f32(v, copy=True)
        return np.asarray(out)
    def get_filtrations(self):
        return _vff21cview_f32(self.truc.get_filtrations(), copy=True)

    def get_dimensions(self):
        """
        Returns the ordered dimensions of the generators.
        """
        return np.asarray(self.truc.get_dimensions())
    def get_boundaries(self):
        """
        Returns the boundaries of the generators.
        """
        return tuple(tuple(b) for b in self.truc.get_boundaries())
    def grid_squeeze(self, filtration_grid=None, grid_strategy="exact", resolution=-1, bool coordinates=True, bool inplace = False, bool force=False):
        """
        Squeeze the filtration values on a grid.
        """
        if force and self.is_squeezed:
            raise ValueError("The slicer seems to be already squeezed. Use force=True to resqueeze.")
        if filtration_grid is None:
            filtration_grid = mpg.compute_grid(
                    self.get_filtrations_values().T,
                    strategy=grid_strategy,
                    resolution=resolution)
        cdef vector[vector[float]] grid = filtration_grid
        if inplace or not coordinates:
            self.truc.coarsen_on_grid_inplace(grid, coordinates)
            self.filtration_grid = filtration_grid
        else:
          raise ValueError("WIP")
        return self
    def minpres(self,
        int degree = 1, 
        list[int] degrees=[],
        str backend:Literal["mpfree", "2pac"]="mpfree", 
        str slicer_backend:Literal["matrix","clement","graph"]="matrix",
        bool vineyard=False, 
        id :Optional[str] = None,
        dtype = np.float32,
        **minpres_kwargs
        ):
        """
        Computes the minimal presentation of the slicer, and returns it as a new slicer.
        """
        new_slicer = minimal_presentation(self, degree=degree, degrees=degrees, backend=backend, slicer_backend=slicer_backend, vineyard=vineyard, id=id, **minpres_kwargs)
        return new_slicer

    @property
    def dtype(self)->type:
      return np.float32
    @property
    def col_type(self)->str:
      return ""
    @property
    def is_vine(self)->bool:
      return False
    @property
    def is_kcritical(self)->bool:
      return False



    @staticmethod
    def from_bitmap(self):
      raise ValueError("Not implemented.")

#------------------------------------------------------------------------------
cdef class _KSlicer0_vine_i32:
    cdef C_KSlicer0_vine_i32 truc
    cdef public vector[vector[double]] filtration_grid
    @property
    def is_squeezed(self)->bool:
        return self.filtration_grid.size() > 0 and self.filtration_grid[0].size() > 0

    def get_ptr(self):
        """
        Returns a pointer to the underlying C++ slicer.
        """
        return <intptr_t>(&self.truc)
    def __init__(self, generator_maps=[], generator_dimensions=[], filtration_values=[]):        
        """
        Constructs a slicer from
         - scc-like blocks 
         or 
         - generator maps (Iterable of list of ints)
         - generator dimensions (Iterable of int)
         - filtration values (Iterable of filtration values)
        """
        pass
    def __cinit__(self, generator_maps=[], generator_dimensions=[], filtration_values=[]):
        """
        Cython constructor
        """
        if len(generator_maps)>0 and len(generator_dimensions) == 0 and len(filtration_values) == 0:
          from multipers._slicer_meta import _blocks2boundary_dimension_grades
          generator_maps, generator_dimensions, filtration_values = _blocks2boundary_dimension_grades(
                  generator_maps,
                  inplace=False,
              )
        cdef uint32_t num_generators = len(generator_maps)
        cdef vector[vector[uint32_t]] c_generator_maps
        cdef vector[KCriticalFiltration[int32_t]] c_filtration_values
        for stuff in generator_maps:
            c_generator_maps.push_back(<vector[uint32_t]>(stuff))
        cdef KCriticalFiltration[int32_t] cf
        for F in filtration_values:
            cf.clear()
            for f in F:
                cf.add_point(_py21c_i32(f))
            c_filtration_values.push_back(cf)
        cdef vector[int] c_generator_dimensions = generator_dimensions
        assert num_generators == c_generator_maps.size() == c_filtration_values.size(), "Invalid input, shape do not coincide."
        self.truc = C_KSlicer0_vine_i32(c_generator_maps,c_generator_dimensions, c_filtration_values)
    def copy(self):
        """
        Returns a copy of the slicer.
        """
        copy_ = _KSlicer0_vine_i32()
        copy_.truc = self.truc
        return copy_
    def get_barcode(self):
        """
        Returns the current barcode.
        """
        return self.truc.get_barcode()
    def push_to_line(self, basepoint, direction=None):
        """
        Pushes the current slicer to the line
        """
        cdef Line[int32_t] line
        if direction is None:
            line = Line[int32_t](_py21c_i32(basepoint))
        else:
            line = Line[int32_t](_py21c_i32(basepoint),_py21c_i32(direction))
        self.truc.push_to(line)        
        return self

    def persistence_on_line(self,basepoint,direction=None):
        """
        Computes the persistence on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        self.truc.compute_persistence()
        return self.truc.get_barcode()
    def compute_persistence(self,one_filtration=None):
        """
        Computes the current persistence, or the persistence
        given by the filtration one_filtration (num_generators,).
        """
        if one_filtration is not None:
            self.truc.set_one_filtration(one_filtration)
        self.truc.compute_persistence()
        # return self.truc.get_barcode()
    def get_barcode(self):
        """
        Returns the barcode of the current 1d-persistence.
        """
        return self.truc.get_barcode()
    def sliced_filtration(self,basepoint, direction=None):
        """
        Computes the filtration on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        return np.asarray(self.truc.get_one_filtration())
    def __len__(self):
        return self.truc.num_generators()
    @property
    def num_generators(self):
        return self.truc.num_generators()
    @property
    def num_parameters(self):
        return self.truc.num_parameters()
    def info(self):
        return self.truc.to_str().decode()
    def compute_box(self):
        """
        Computes the bounding box of the current persistence.
        """
        cdef pair[Finitely_critical_multi_filtration[int32_t],Finitely_critical_multi_filtration[int32_t]] box = self.truc.get_bounding_box()
        cdef cnp.ndarray[int32_t, ndim=1] a = _ff21cview_i32(&box.first)
        cdef cnp.ndarray[int32_t, ndim=1] b = _ff21cview_i32(&box.second)
        return np.asarray([a,b])
    def get_filtrations_values(self):
        """
        Returns the current filtration values of the slicer.
        """
        cdef vector[Finitely_critical_multi_filtration[int32_t]] v = self.truc.get_filtration_values()
        out = _vff21cview_i32(v, copy=True)
        return np.asarray(out)
    def get_filtrations(self):
        return _vff2kcview_i32(self.truc.get_filtrations(), copy=True)

    def get_dimensions(self):
        """
        Returns the ordered dimensions of the generators.
        """
        return np.asarray(self.truc.get_dimensions())
    def get_boundaries(self):
        """
        Returns the boundaries of the generators.
        """
        return tuple(tuple(b) for b in self.truc.get_boundaries())
    def grid_squeeze(self, filtration_grid=None, grid_strategy="exact", resolution=-1, bool coordinates=True, bool inplace = False, bool force=False):
        """
        Squeeze the filtration values on a grid.
        """
        if force and self.is_squeezed:
            raise ValueError("The slicer seems to be already squeezed. Use force=True to resqueeze.")
        if filtration_grid is None:
            filtration_grid = mpg.compute_grid(
                    self.get_filtrations_values().T,
                    strategy=grid_strategy,
                    resolution=resolution)
        cdef vector[vector[int32_t]] grid = filtration_grid
        if inplace or not coordinates:
            self.truc.coarsen_on_grid_inplace(grid, coordinates)
            self.filtration_grid = filtration_grid
        else:
          out = _KSlicer0_vine_i32()
          out.truc = self.truc.coarsen_on_grid(grid)
          out.filtration_grid = filtration_grid
          return out
        return self
    def minpres(self,
        int degree = 1, 
        list[int] degrees=[],
        str backend:Literal["mpfree", "2pac"]="mpfree", 
        str slicer_backend:Literal["matrix","clement","graph"]="matrix",
        bool vineyard=True, 
        id :Optional[str] = None,
        dtype = np.int32,
        **minpres_kwargs
        ):
        """
        Computes the minimal presentation of the slicer, and returns it as a new slicer.
        """
        new_slicer = minimal_presentation(self, degree=degree, degrees=degrees, backend=backend, slicer_backend=slicer_backend, vineyard=vineyard, id=id, **minpres_kwargs)
        return new_slicer

    @property
    def dtype(self)->type:
      return np.int32
    @property
    def col_type(self)->str:
      return "INTRUSIVE_SET"
    @property
    def is_vine(self)->bool:
      return True
    @property
    def is_kcritical(self)->bool:
      return True


    def vine_update(self,basepoint,direction=None):
        """
        Updates the barcode, on a line, using the vineyard algorithm.
        """
        self.push_to_line(basepoint,direction)
        self.truc.vineyard_update()
        return self
    def get_representative_cycles(self, bool update=True):
        """
        Returns the representative cycles of the current barcode.
        Recomputes the generators if update=True
        """
        return self.truc.get_representative_cycles(update)
    def get_permutation(self):
        """
        Returns the current generator permutation (w.r.t. vineyard).
        """
        return self.truc.get_current_order()

    @staticmethod
    def from_bitmap(self):
      raise ValueError("Not implemented.")

#------------------------------------------------------------------------------
cdef class _KSlicer0_vine_f32:
    cdef C_KSlicer0_vine_f32 truc
    cdef public vector[vector[double]] filtration_grid
    @property
    def is_squeezed(self)->bool:
        return self.filtration_grid.size() > 0 and self.filtration_grid[0].size() > 0

    def get_ptr(self):
        """
        Returns a pointer to the underlying C++ slicer.
        """
        return <intptr_t>(&self.truc)
    def __init__(self, generator_maps=[], generator_dimensions=[], filtration_values=[]):        
        """
        Constructs a slicer from
         - scc-like blocks 
         or 
         - generator maps (Iterable of list of ints)
         - generator dimensions (Iterable of int)
         - filtration values (Iterable of filtration values)
        """
        pass
    def __cinit__(self, generator_maps=[], generator_dimensions=[], filtration_values=[]):
        """
        Cython constructor
        """
        if len(generator_maps)>0 and len(generator_dimensions) == 0 and len(filtration_values) == 0:
          from multipers._slicer_meta import _blocks2boundary_dimension_grades
          generator_maps, generator_dimensions, filtration_values = _blocks2boundary_dimension_grades(
                  generator_maps,
                  inplace=False,
              )
        cdef uint32_t num_generators = len(generator_maps)
        cdef vector[vector[uint32_t]] c_generator_maps
        cdef vector[KCriticalFiltration[float]] c_filtration_values
        for stuff in generator_maps:
            c_generator_maps.push_back(<vector[uint32_t]>(stuff))
        cdef KCriticalFiltration[float] cf
        for F in filtration_values:
            cf.clear()
            for f in F:
                cf.add_point(_py21c_f32(f))
            c_filtration_values.push_back(cf)
        cdef vector[int] c_generator_dimensions = generator_dimensions
        assert num_generators == c_generator_maps.size() == c_filtration_values.size(), "Invalid input, shape do not coincide."
        self.truc = C_KSlicer0_vine_f32(c_generator_maps,c_generator_dimensions, c_filtration_values)
    def copy(self):
        """
        Returns a copy of the slicer.
        """
        copy_ = _KSlicer0_vine_f32()
        copy_.truc = self.truc
        return copy_
    def get_barcode(self):
        """
        Returns the current barcode.
        """
        return self.truc.get_barcode()
    def push_to_line(self, basepoint, direction=None):
        """
        Pushes the current slicer to the line
        """
        cdef Line[float] line
        if direction is None:
            line = Line[float](_py21c_f32(basepoint))
        else:
            line = Line[float](_py21c_f32(basepoint),_py21c_f32(direction))
        self.truc.push_to(line)        
        return self

    def persistence_on_line(self,basepoint,direction=None):
        """
        Computes the persistence on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        self.truc.compute_persistence()
        return self.truc.get_barcode()
    def compute_persistence(self,one_filtration=None):
        """
        Computes the current persistence, or the persistence
        given by the filtration one_filtration (num_generators,).
        """
        if one_filtration is not None:
            self.truc.set_one_filtration(one_filtration)
        self.truc.compute_persistence()
        # return self.truc.get_barcode()
    def get_barcode(self):
        """
        Returns the barcode of the current 1d-persistence.
        """
        return self.truc.get_barcode()
    def sliced_filtration(self,basepoint, direction=None):
        """
        Computes the filtration on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        return np.asarray(self.truc.get_one_filtration())
    def __len__(self):
        return self.truc.num_generators()
    @property
    def num_generators(self):
        return self.truc.num_generators()
    @property
    def num_parameters(self):
        return self.truc.num_parameters()
    def info(self):
        return self.truc.to_str().decode()
    def compute_box(self):
        """
        Computes the bounding box of the current persistence.
        """
        cdef pair[Finitely_critical_multi_filtration[float],Finitely_critical_multi_filtration[float]] box = self.truc.get_bounding_box()
        cdef cnp.ndarray[float, ndim=1] a = _ff21cview_f32(&box.first)
        cdef cnp.ndarray[float, ndim=1] b = _ff21cview_f32(&box.second)
        return np.asarray([a,b])
    def get_filtrations_values(self):
        """
        Returns the current filtration values of the slicer.
        """
        cdef vector[Finitely_critical_multi_filtration[float]] v = self.truc.get_filtration_values()
        out = _vff21cview_f32(v, copy=True)
        return np.asarray(out)
    def get_filtrations(self):
        return _vff2kcview_f32(self.truc.get_filtrations(), copy=True)

    def get_dimensions(self):
        """
        Returns the ordered dimensions of the generators.
        """
        return np.asarray(self.truc.get_dimensions())
    def get_boundaries(self):
        """
        Returns the boundaries of the generators.
        """
        return tuple(tuple(b) for b in self.truc.get_boundaries())
    def grid_squeeze(self, filtration_grid=None, grid_strategy="exact", resolution=-1, bool coordinates=True, bool inplace = False, bool force=False):
        """
        Squeeze the filtration values on a grid.
        """
        if force and self.is_squeezed:
            raise ValueError("The slicer seems to be already squeezed. Use force=True to resqueeze.")
        if filtration_grid is None:
            filtration_grid = mpg.compute_grid(
                    self.get_filtrations_values().T,
                    strategy=grid_strategy,
                    resolution=resolution)
        cdef vector[vector[float]] grid = filtration_grid
        if inplace or not coordinates:
            self.truc.coarsen_on_grid_inplace(grid, coordinates)
            self.filtration_grid = filtration_grid
        else:
          out = _KSlicer0_vine_i32()
          out.truc = self.truc.coarsen_on_grid(grid)
          out.filtration_grid = filtration_grid
          return out
        return self
    def minpres(self,
        int degree = 1, 
        list[int] degrees=[],
        str backend:Literal["mpfree", "2pac"]="mpfree", 
        str slicer_backend:Literal["matrix","clement","graph"]="matrix",
        bool vineyard=True, 
        id :Optional[str] = None,
        dtype = np.float32,
        **minpres_kwargs
        ):
        """
        Computes the minimal presentation of the slicer, and returns it as a new slicer.
        """
        new_slicer = minimal_presentation(self, degree=degree, degrees=degrees, backend=backend, slicer_backend=slicer_backend, vineyard=vineyard, id=id, **minpres_kwargs)
        return new_slicer

    @property
    def dtype(self)->type:
      return np.float32
    @property
    def col_type(self)->str:
      return "INTRUSIVE_SET"
    @property
    def is_vine(self)->bool:
      return True
    @property
    def is_kcritical(self)->bool:
      return True


    def vine_update(self,basepoint,direction=None):
        """
        Updates the barcode, on a line, using the vineyard algorithm.
        """
        self.push_to_line(basepoint,direction)
        self.truc.vineyard_update()
        return self
    def get_representative_cycles(self, bool update=True):
        """
        Returns the representative cycles of the current barcode.
        Recomputes the generators if update=True
        """
        return self.truc.get_representative_cycles(update)
    def get_permutation(self):
        """
        Returns the current generator permutation (w.r.t. vineyard).
        """
        return self.truc.get_current_order()

    @staticmethod
    def from_bitmap(self):
      raise ValueError("Not implemented.")

#------------------------------------------------------------------------------
cdef class _KSlicer0_vine_f64:
    cdef C_KSlicer0_vine_f64 truc
    cdef public vector[vector[double]] filtration_grid
    @property
    def is_squeezed(self)->bool:
        return self.filtration_grid.size() > 0 and self.filtration_grid[0].size() > 0

    def get_ptr(self):
        """
        Returns a pointer to the underlying C++ slicer.
        """
        return <intptr_t>(&self.truc)
    def __init__(self, generator_maps=[], generator_dimensions=[], filtration_values=[]):        
        """
        Constructs a slicer from
         - scc-like blocks 
         or 
         - generator maps (Iterable of list of ints)
         - generator dimensions (Iterable of int)
         - filtration values (Iterable of filtration values)
        """
        pass
    def __cinit__(self, generator_maps=[], generator_dimensions=[], filtration_values=[]):
        """
        Cython constructor
        """
        if len(generator_maps)>0 and len(generator_dimensions) == 0 and len(filtration_values) == 0:
          from multipers._slicer_meta import _blocks2boundary_dimension_grades
          generator_maps, generator_dimensions, filtration_values = _blocks2boundary_dimension_grades(
                  generator_maps,
                  inplace=False,
              )
        cdef uint32_t num_generators = len(generator_maps)
        cdef vector[vector[uint32_t]] c_generator_maps
        cdef vector[KCriticalFiltration[double]] c_filtration_values
        for stuff in generator_maps:
            c_generator_maps.push_back(<vector[uint32_t]>(stuff))
        cdef KCriticalFiltration[double] cf
        for F in filtration_values:
            cf.clear()
            for f in F:
                cf.add_point(_py21c_f64(f))
            c_filtration_values.push_back(cf)
        cdef vector[int] c_generator_dimensions = generator_dimensions
        assert num_generators == c_generator_maps.size() == c_filtration_values.size(), "Invalid input, shape do not coincide."
        self.truc = C_KSlicer0_vine_f64(c_generator_maps,c_generator_dimensions, c_filtration_values)
    def copy(self):
        """
        Returns a copy of the slicer.
        """
        copy_ = _KSlicer0_vine_f64()
        copy_.truc = self.truc
        return copy_
    def get_barcode(self):
        """
        Returns the current barcode.
        """
        return self.truc.get_barcode()
    def push_to_line(self, basepoint, direction=None):
        """
        Pushes the current slicer to the line
        """
        cdef Line[double] line
        if direction is None:
            line = Line[double](_py21c_f64(basepoint))
        else:
            line = Line[double](_py21c_f64(basepoint),_py21c_f64(direction))
        self.truc.push_to(line)        
        return self

    def persistence_on_line(self,basepoint,direction=None):
        """
        Computes the persistence on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        self.truc.compute_persistence()
        return self.truc.get_barcode()
    def compute_persistence(self,one_filtration=None):
        """
        Computes the current persistence, or the persistence
        given by the filtration one_filtration (num_generators,).
        """
        if one_filtration is not None:
            self.truc.set_one_filtration(one_filtration)
        self.truc.compute_persistence()
        # return self.truc.get_barcode()
    def get_barcode(self):
        """
        Returns the barcode of the current 1d-persistence.
        """
        return self.truc.get_barcode()
    def sliced_filtration(self,basepoint, direction=None):
        """
        Computes the filtration on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        return np.asarray(self.truc.get_one_filtration())
    def __len__(self):
        return self.truc.num_generators()
    @property
    def num_generators(self):
        return self.truc.num_generators()
    @property
    def num_parameters(self):
        return self.truc.num_parameters()
    def info(self):
        return self.truc.to_str().decode()
    def compute_box(self):
        """
        Computes the bounding box of the current persistence.
        """
        cdef pair[Finitely_critical_multi_filtration[double],Finitely_critical_multi_filtration[double]] box = self.truc.get_bounding_box()
        cdef cnp.ndarray[double, ndim=1] a = _ff21cview_f64(&box.first)
        cdef cnp.ndarray[double, ndim=1] b = _ff21cview_f64(&box.second)
        return np.asarray([a,b])
    def get_filtrations_values(self):
        """
        Returns the current filtration values of the slicer.
        """
        cdef vector[Finitely_critical_multi_filtration[double]] v = self.truc.get_filtration_values()
        out = _vff21cview_f64(v, copy=True)
        return np.asarray(out)
    def get_filtrations(self):
        return _vff2kcview_f64(self.truc.get_filtrations(), copy=True)

    def get_dimensions(self):
        """
        Returns the ordered dimensions of the generators.
        """
        return np.asarray(self.truc.get_dimensions())
    def get_boundaries(self):
        """
        Returns the boundaries of the generators.
        """
        return tuple(tuple(b) for b in self.truc.get_boundaries())
    def grid_squeeze(self, filtration_grid=None, grid_strategy="exact", resolution=-1, bool coordinates=True, bool inplace = False, bool force=False):
        """
        Squeeze the filtration values on a grid.
        """
        if force and self.is_squeezed:
            raise ValueError("The slicer seems to be already squeezed. Use force=True to resqueeze.")
        if filtration_grid is None:
            filtration_grid = mpg.compute_grid(
                    self.get_filtrations_values().T,
                    strategy=grid_strategy,
                    resolution=resolution)
        cdef vector[vector[double]] grid = filtration_grid
        if inplace or not coordinates:
            self.truc.coarsen_on_grid_inplace(grid, coordinates)
            self.filtration_grid = filtration_grid
        else:
          out = _KSlicer0_vine_i32()
          out.truc = self.truc.coarsen_on_grid(grid)
          out.filtration_grid = filtration_grid
          return out
        return self
    def minpres(self,
        int degree = 1, 
        list[int] degrees=[],
        str backend:Literal["mpfree", "2pac"]="mpfree", 
        str slicer_backend:Literal["matrix","clement","graph"]="matrix",
        bool vineyard=True, 
        id :Optional[str] = None,
        dtype = np.float64,
        **minpres_kwargs
        ):
        """
        Computes the minimal presentation of the slicer, and returns it as a new slicer.
        """
        new_slicer = minimal_presentation(self, degree=degree, degrees=degrees, backend=backend, slicer_backend=slicer_backend, vineyard=vineyard, id=id, **minpres_kwargs)
        return new_slicer

    @property
    def dtype(self)->type:
      return np.float64
    @property
    def col_type(self)->str:
      return "INTRUSIVE_SET"
    @property
    def is_vine(self)->bool:
      return True
    @property
    def is_kcritical(self)->bool:
      return True


    def vine_update(self,basepoint,direction=None):
        """
        Updates the barcode, on a line, using the vineyard algorithm.
        """
        self.push_to_line(basepoint,direction)
        self.truc.vineyard_update()
        return self
    def get_representative_cycles(self, bool update=True):
        """
        Returns the representative cycles of the current barcode.
        Recomputes the generators if update=True
        """
        return self.truc.get_representative_cycles(update)
    def get_permutation(self):
        """
        Returns the current generator permutation (w.r.t. vineyard).
        """
        return self.truc.get_current_order()

    @staticmethod
    def from_bitmap(self):
      raise ValueError("Not implemented.")

#------------------------------------------------------------------------------
cdef class _Slicer0_vine_i32:
    cdef C_Slicer0_vine_i32 truc
    cdef public vector[vector[double]] filtration_grid
    @property
    def is_squeezed(self)->bool:
        return self.filtration_grid.size() > 0 and self.filtration_grid[0].size() > 0

    def get_ptr(self):
        """
        Returns a pointer to the underlying C++ slicer.
        """
        return <intptr_t>(&self.truc)
    def __init__(self, generator_maps=[], generator_dimensions=[], filtration_values=[]):        
        """
        Constructs a slicer from
         - generator maps (Iterable of list of ints)
         - generator dimensions (Iterable of int)
         - filtration values (Iterable of filtration values)
        """
        pass
    def __cinit__(self, generator_maps=[], generator_dimensions=[], filtration_values=[]):
        """
        Cython constructor
        """
        cdef uint32_t num_generators = len(generator_maps)
        cdef vector[vector[uint32_t]] c_generator_maps
        cdef vector[Finitely_critical_multi_filtration[int32_t]] c_filtration_values
        for stuff in generator_maps:
            c_generator_maps.push_back(<vector[uint32_t]>(stuff))
        for f in filtration_values:
            # cf.clear()
            # for truc in f:
            #     cf.push_back(truc)
            c_filtration_values.push_back(_py21c_i32(f))
        cdef vector[int] c_generator_dimensions = generator_dimensions
        assert num_generators == c_generator_maps.size() == c_filtration_values.size(), "Invalid input, shape do not coincide."
        self.truc = C_Slicer0_vine_i32(c_generator_maps,c_generator_dimensions, c_filtration_values)
    def copy(self):
        """
        Returns a copy of the slicer.
        """
        copy_ = _Slicer0_vine_i32()
        copy_.truc = self.truc
        return copy_
    def get_barcode(self):
        """
        Returns the current barcode.
        """
        return self.truc.get_barcode()
    def push_to_line(self, basepoint, direction=None):
        """
        Pushes the current slicer to the line
        """
        cdef Line[int32_t] line
        if direction is None:
            line = Line[int32_t](_py21c_i32(basepoint))
        else:
            line = Line[int32_t](_py21c_i32(basepoint),_py21c_i32(direction))
        self.truc.push_to(line)        
        return self

    def persistence_on_line(self,basepoint,direction=None):
        """
        Computes the persistence on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        self.truc.compute_persistence()
        return self.truc.get_barcode()
    def compute_persistence(self,one_filtration=None):
        """
        Computes the current persistence, or the persistence
        given by the filtration one_filtration (num_generators,).
        """
        if one_filtration is not None:
            self.truc.set_one_filtration(one_filtration)
        self.truc.compute_persistence()
        # return self.truc.get_barcode()
    def get_barcode(self):
        """
        Returns the barcode of the current 1d-persistence.
        """
        return self.truc.get_barcode()
    def sliced_filtration(self,basepoint, direction=None):
        """
        Computes the filtration on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        return np.asarray(self.truc.get_one_filtration())
    def __len__(self):
        return self.truc.num_generators()
    @property
    def num_generators(self):
        return self.truc.num_generators()
    @property
    def num_parameters(self):
        return self.truc.num_parameters()
    def info(self):
        return self.truc.to_str().decode()
    def compute_box(self):
        """
        Computes the bounding box of the current persistence.
        """
        cdef pair[Finitely_critical_multi_filtration[int32_t],Finitely_critical_multi_filtration[int32_t]] box = self.truc.get_bounding_box()
        cdef cnp.ndarray[int32_t, ndim=1] a = _ff21cview_i32(&box.first)
        cdef cnp.ndarray[int32_t, ndim=1] b = _ff21cview_i32(&box.second)
        return np.asarray([a,b])
    def get_filtrations_values(self):
        """
        Returns the current filtration values of the slicer.
        """
        cdef vector[Finitely_critical_multi_filtration[int32_t]] v = self.truc.get_filtration_values()
        out = _vff21cview_i32(v, copy=True)
        return np.asarray(out)
    def get_filtrations(self):
        return _vff21cview_i32(self.truc.get_filtrations(), copy=True)

    def get_dimensions(self):
        """
        Returns the ordered dimensions of the generators.
        """
        return np.asarray(self.truc.get_dimensions())
    def get_boundaries(self):
        """
        Returns the boundaries of the generators.
        """
        return tuple(tuple(b) for b in self.truc.get_boundaries())
    def grid_squeeze(self, filtration_grid=None, grid_strategy="exact", resolution=-1, bool coordinates=True, bool inplace = False, bool force=False):
        """
        Squeeze the filtration values on a grid.
        """
        if force and self.is_squeezed:
            raise ValueError("The slicer seems to be already squeezed. Use force=True to resqueeze.")
        if filtration_grid is None:
            filtration_grid = mpg.compute_grid(
                    self.get_filtrations_values().T,
                    strategy=grid_strategy,
                    resolution=resolution)
        cdef vector[vector[int32_t]] grid = filtration_grid
        if inplace or not coordinates:
            self.truc.coarsen_on_grid_inplace(grid, coordinates)
            self.filtration_grid = filtration_grid
        else:
          out = _Slicer0_vine_i32()
          out.truc = self.truc.coarsen_on_grid(grid)
          out.filtration_grid = filtration_grid
          return out
        return self
    def minpres(self,
        int degree = 1, 
        list[int] degrees=[],
        str backend:Literal["mpfree", "2pac"]="mpfree", 
        str slicer_backend:Literal["matrix","clement","graph"]="matrix",
        bool vineyard=True, 
        id :Optional[str] = None,
        dtype = np.int32,
        **minpres_kwargs
        ):
        """
        Computes the minimal presentation of the slicer, and returns it as a new slicer.
        """
        new_slicer = minimal_presentation(self, degree=degree, degrees=degrees, backend=backend, slicer_backend=slicer_backend, vineyard=vineyard, id=id, **minpres_kwargs)
        return new_slicer

    @property
    def dtype(self)->type:
      return np.int32
    @property
    def col_type(self)->str:
      return "INTRUSIVE_SET"
    @property
    def is_vine(self)->bool:
      return True
    @property
    def is_kcritical(self)->bool:
      return False


    def vine_update(self,basepoint,direction=None):
        """
        Updates the barcode, on a line, using the vineyard algorithm.
        """
        self.push_to_line(basepoint,direction)
        self.truc.vineyard_update()
        return self
    def get_representative_cycles(self, bool update=True):
        """
        Returns the representative cycles of the current barcode.
        Recomputes the generators if update=True
        """
        return self.truc.get_representative_cycles(update)
    def get_permutation(self):
        """
        Returns the current generator permutation (w.r.t. vineyard).
        """
        return self.truc.get_current_order()

    @staticmethod
    def from_bitmap(self):
      raise ValueError("Not implemented.")

#------------------------------------------------------------------------------
cdef class _Slicer0_vine_f32:
    cdef C_Slicer0_vine_f32 truc
    cdef public vector[vector[double]] filtration_grid
    @property
    def is_squeezed(self)->bool:
        return self.filtration_grid.size() > 0 and self.filtration_grid[0].size() > 0

    def get_ptr(self):
        """
        Returns a pointer to the underlying C++ slicer.
        """
        return <intptr_t>(&self.truc)
    def __init__(self, generator_maps=[], generator_dimensions=[], filtration_values=[]):        
        """
        Constructs a slicer from
         - generator maps (Iterable of list of ints)
         - generator dimensions (Iterable of int)
         - filtration values (Iterable of filtration values)
        """
        pass
    def __cinit__(self, generator_maps=[], generator_dimensions=[], filtration_values=[]):
        """
        Cython constructor
        """
        cdef uint32_t num_generators = len(generator_maps)
        cdef vector[vector[uint32_t]] c_generator_maps
        cdef vector[Finitely_critical_multi_filtration[float]] c_filtration_values
        for stuff in generator_maps:
            c_generator_maps.push_back(<vector[uint32_t]>(stuff))
        for f in filtration_values:
            # cf.clear()
            # for truc in f:
            #     cf.push_back(truc)
            c_filtration_values.push_back(_py21c_f32(f))
        cdef vector[int] c_generator_dimensions = generator_dimensions
        assert num_generators == c_generator_maps.size() == c_filtration_values.size(), "Invalid input, shape do not coincide."
        self.truc = C_Slicer0_vine_f32(c_generator_maps,c_generator_dimensions, c_filtration_values)
    def copy(self):
        """
        Returns a copy of the slicer.
        """
        copy_ = _Slicer0_vine_f32()
        copy_.truc = self.truc
        return copy_
    def get_barcode(self):
        """
        Returns the current barcode.
        """
        return self.truc.get_barcode()
    def push_to_line(self, basepoint, direction=None):
        """
        Pushes the current slicer to the line
        """
        cdef Line[float] line
        if direction is None:
            line = Line[float](_py21c_f32(basepoint))
        else:
            line = Line[float](_py21c_f32(basepoint),_py21c_f32(direction))
        self.truc.push_to(line)        
        return self

    def persistence_on_line(self,basepoint,direction=None):
        """
        Computes the persistence on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        self.truc.compute_persistence()
        return self.truc.get_barcode()
    def compute_persistence(self,one_filtration=None):
        """
        Computes the current persistence, or the persistence
        given by the filtration one_filtration (num_generators,).
        """
        if one_filtration is not None:
            self.truc.set_one_filtration(one_filtration)
        self.truc.compute_persistence()
        # return self.truc.get_barcode()
    def get_barcode(self):
        """
        Returns the barcode of the current 1d-persistence.
        """
        return self.truc.get_barcode()
    def sliced_filtration(self,basepoint, direction=None):
        """
        Computes the filtration on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        return np.asarray(self.truc.get_one_filtration())
    def __len__(self):
        return self.truc.num_generators()
    @property
    def num_generators(self):
        return self.truc.num_generators()
    @property
    def num_parameters(self):
        return self.truc.num_parameters()
    def info(self):
        return self.truc.to_str().decode()
    def compute_box(self):
        """
        Computes the bounding box of the current persistence.
        """
        cdef pair[Finitely_critical_multi_filtration[float],Finitely_critical_multi_filtration[float]] box = self.truc.get_bounding_box()
        cdef cnp.ndarray[float, ndim=1] a = _ff21cview_f32(&box.first)
        cdef cnp.ndarray[float, ndim=1] b = _ff21cview_f32(&box.second)
        return np.asarray([a,b])
    def get_filtrations_values(self):
        """
        Returns the current filtration values of the slicer.
        """
        cdef vector[Finitely_critical_multi_filtration[float]] v = self.truc.get_filtration_values()
        out = _vff21cview_f32(v, copy=True)
        return np.asarray(out)
    def get_filtrations(self):
        return _vff21cview_f32(self.truc.get_filtrations(), copy=True)

    def get_dimensions(self):
        """
        Returns the ordered dimensions of the generators.
        """
        return np.asarray(self.truc.get_dimensions())
    def get_boundaries(self):
        """
        Returns the boundaries of the generators.
        """
        return tuple(tuple(b) for b in self.truc.get_boundaries())
    def grid_squeeze(self, filtration_grid=None, grid_strategy="exact", resolution=-1, bool coordinates=True, bool inplace = False, bool force=False):
        """
        Squeeze the filtration values on a grid.
        """
        if force and self.is_squeezed:
            raise ValueError("The slicer seems to be already squeezed. Use force=True to resqueeze.")
        if filtration_grid is None:
            filtration_grid = mpg.compute_grid(
                    self.get_filtrations_values().T,
                    strategy=grid_strategy,
                    resolution=resolution)
        cdef vector[vector[float]] grid = filtration_grid
        if inplace or not coordinates:
            self.truc.coarsen_on_grid_inplace(grid, coordinates)
            self.filtration_grid = filtration_grid
        else:
          out = _Slicer0_vine_i32()
          out.truc = self.truc.coarsen_on_grid(grid)
          out.filtration_grid = filtration_grid
          return out
        return self
    def minpres(self,
        int degree = 1, 
        list[int] degrees=[],
        str backend:Literal["mpfree", "2pac"]="mpfree", 
        str slicer_backend:Literal["matrix","clement","graph"]="matrix",
        bool vineyard=True, 
        id :Optional[str] = None,
        dtype = np.float32,
        **minpres_kwargs
        ):
        """
        Computes the minimal presentation of the slicer, and returns it as a new slicer.
        """
        new_slicer = minimal_presentation(self, degree=degree, degrees=degrees, backend=backend, slicer_backend=slicer_backend, vineyard=vineyard, id=id, **minpres_kwargs)
        return new_slicer

    @property
    def dtype(self)->type:
      return np.float32
    @property
    def col_type(self)->str:
      return "INTRUSIVE_SET"
    @property
    def is_vine(self)->bool:
      return True
    @property
    def is_kcritical(self)->bool:
      return False


    def vine_update(self,basepoint,direction=None):
        """
        Updates the barcode, on a line, using the vineyard algorithm.
        """
        self.push_to_line(basepoint,direction)
        self.truc.vineyard_update()
        return self
    def get_representative_cycles(self, bool update=True):
        """
        Returns the representative cycles of the current barcode.
        Recomputes the generators if update=True
        """
        return self.truc.get_representative_cycles(update)
    def get_permutation(self):
        """
        Returns the current generator permutation (w.r.t. vineyard).
        """
        return self.truc.get_current_order()

    @staticmethod
    def from_bitmap(self):
      raise ValueError("Not implemented.")

#------------------------------------------------------------------------------
cdef class _Slicer0_vine_f64:
    cdef C_Slicer0_vine_f64 truc
    cdef public vector[vector[double]] filtration_grid
    @property
    def is_squeezed(self)->bool:
        return self.filtration_grid.size() > 0 and self.filtration_grid[0].size() > 0

    def get_ptr(self):
        """
        Returns a pointer to the underlying C++ slicer.
        """
        return <intptr_t>(&self.truc)
    def __init__(self, generator_maps=[], generator_dimensions=[], filtration_values=[]):        
        """
        Constructs a slicer from
         - generator maps (Iterable of list of ints)
         - generator dimensions (Iterable of int)
         - filtration values (Iterable of filtration values)
        """
        pass
    def __cinit__(self, generator_maps=[], generator_dimensions=[], filtration_values=[]):
        """
        Cython constructor
        """
        cdef uint32_t num_generators = len(generator_maps)
        cdef vector[vector[uint32_t]] c_generator_maps
        cdef vector[Finitely_critical_multi_filtration[double]] c_filtration_values
        for stuff in generator_maps:
            c_generator_maps.push_back(<vector[uint32_t]>(stuff))
        for f in filtration_values:
            # cf.clear()
            # for truc in f:
            #     cf.push_back(truc)
            c_filtration_values.push_back(_py21c_f64(f))
        cdef vector[int] c_generator_dimensions = generator_dimensions
        assert num_generators == c_generator_maps.size() == c_filtration_values.size(), "Invalid input, shape do not coincide."
        self.truc = C_Slicer0_vine_f64(c_generator_maps,c_generator_dimensions, c_filtration_values)
    def copy(self):
        """
        Returns a copy of the slicer.
        """
        copy_ = _Slicer0_vine_f64()
        copy_.truc = self.truc
        return copy_
    def get_barcode(self):
        """
        Returns the current barcode.
        """
        return self.truc.get_barcode()
    def push_to_line(self, basepoint, direction=None):
        """
        Pushes the current slicer to the line
        """
        cdef Line[double] line
        if direction is None:
            line = Line[double](_py21c_f64(basepoint))
        else:
            line = Line[double](_py21c_f64(basepoint),_py21c_f64(direction))
        self.truc.push_to(line)        
        return self

    def persistence_on_line(self,basepoint,direction=None):
        """
        Computes the persistence on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        self.truc.compute_persistence()
        return self.truc.get_barcode()
    def compute_persistence(self,one_filtration=None):
        """
        Computes the current persistence, or the persistence
        given by the filtration one_filtration (num_generators,).
        """
        if one_filtration is not None:
            self.truc.set_one_filtration(one_filtration)
        self.truc.compute_persistence()
        # return self.truc.get_barcode()
    def get_barcode(self):
        """
        Returns the barcode of the current 1d-persistence.
        """
        return self.truc.get_barcode()
    def sliced_filtration(self,basepoint, direction=None):
        """
        Computes the filtration on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        return np.asarray(self.truc.get_one_filtration())
    def __len__(self):
        return self.truc.num_generators()
    @property
    def num_generators(self):
        return self.truc.num_generators()
    @property
    def num_parameters(self):
        return self.truc.num_parameters()
    def info(self):
        return self.truc.to_str().decode()
    def compute_box(self):
        """
        Computes the bounding box of the current persistence.
        """
        cdef pair[Finitely_critical_multi_filtration[double],Finitely_critical_multi_filtration[double]] box = self.truc.get_bounding_box()
        cdef cnp.ndarray[double, ndim=1] a = _ff21cview_f64(&box.first)
        cdef cnp.ndarray[double, ndim=1] b = _ff21cview_f64(&box.second)
        return np.asarray([a,b])
    def get_filtrations_values(self):
        """
        Returns the current filtration values of the slicer.
        """
        cdef vector[Finitely_critical_multi_filtration[double]] v = self.truc.get_filtration_values()
        out = _vff21cview_f64(v, copy=True)
        return np.asarray(out)
    def get_filtrations(self):
        return _vff21cview_f64(self.truc.get_filtrations(), copy=True)

    def get_dimensions(self):
        """
        Returns the ordered dimensions of the generators.
        """
        return np.asarray(self.truc.get_dimensions())
    def get_boundaries(self):
        """
        Returns the boundaries of the generators.
        """
        return tuple(tuple(b) for b in self.truc.get_boundaries())
    def grid_squeeze(self, filtration_grid=None, grid_strategy="exact", resolution=-1, bool coordinates=True, bool inplace = False, bool force=False):
        """
        Squeeze the filtration values on a grid.
        """
        if force and self.is_squeezed:
            raise ValueError("The slicer seems to be already squeezed. Use force=True to resqueeze.")
        if filtration_grid is None:
            filtration_grid = mpg.compute_grid(
                    self.get_filtrations_values().T,
                    strategy=grid_strategy,
                    resolution=resolution)
        cdef vector[vector[double]] grid = filtration_grid
        if inplace or not coordinates:
            self.truc.coarsen_on_grid_inplace(grid, coordinates)
            self.filtration_grid = filtration_grid
        else:
          out = _Slicer0_vine_i32()
          out.truc = self.truc.coarsen_on_grid(grid)
          out.filtration_grid = filtration_grid
          return out
        return self
    def minpres(self,
        int degree = 1, 
        list[int] degrees=[],
        str backend:Literal["mpfree", "2pac"]="mpfree", 
        str slicer_backend:Literal["matrix","clement","graph"]="matrix",
        bool vineyard=True, 
        id :Optional[str] = None,
        dtype = np.float64,
        **minpres_kwargs
        ):
        """
        Computes the minimal presentation of the slicer, and returns it as a new slicer.
        """
        new_slicer = minimal_presentation(self, degree=degree, degrees=degrees, backend=backend, slicer_backend=slicer_backend, vineyard=vineyard, id=id, **minpres_kwargs)
        return new_slicer

    @property
    def dtype(self)->type:
      return np.float64
    @property
    def col_type(self)->str:
      return "INTRUSIVE_SET"
    @property
    def is_vine(self)->bool:
      return True
    @property
    def is_kcritical(self)->bool:
      return False


    def vine_update(self,basepoint,direction=None):
        """
        Updates the barcode, on a line, using the vineyard algorithm.
        """
        self.push_to_line(basepoint,direction)
        self.truc.vineyard_update()
        return self
    def get_representative_cycles(self, bool update=True):
        """
        Returns the representative cycles of the current barcode.
        Recomputes the generators if update=True
        """
        return self.truc.get_representative_cycles(update)
    def get_permutation(self):
        """
        Returns the current generator permutation (w.r.t. vineyard).
        """
        return self.truc.get_current_order()

    @staticmethod
    def from_bitmap(self):
      raise ValueError("Not implemented.")

#------------------------------------------------------------------------------
cdef class _KSlicer0_i32:
    cdef C_KSlicer0_i32 truc
    cdef public vector[vector[double]] filtration_grid
    @property
    def is_squeezed(self)->bool:
        return self.filtration_grid.size() > 0 and self.filtration_grid[0].size() > 0

    def get_ptr(self):
        """
        Returns a pointer to the underlying C++ slicer.
        """
        return <intptr_t>(&self.truc)
    def __init__(self, generator_maps=[], generator_dimensions=[], filtration_values=[]):        
        """
        Constructs a slicer from
         - scc-like blocks 
         or 
         - generator maps (Iterable of list of ints)
         - generator dimensions (Iterable of int)
         - filtration values (Iterable of filtration values)
        """
        pass
    def __cinit__(self, generator_maps=[], generator_dimensions=[], filtration_values=[]):
        """
        Cython constructor
        """
        if len(generator_maps)>0 and len(generator_dimensions) == 0 and len(filtration_values) == 0:
          from multipers._slicer_meta import _blocks2boundary_dimension_grades
          generator_maps, generator_dimensions, filtration_values = _blocks2boundary_dimension_grades(
                  generator_maps,
                  inplace=False,
              )
        cdef uint32_t num_generators = len(generator_maps)
        cdef vector[vector[uint32_t]] c_generator_maps
        cdef vector[KCriticalFiltration[int32_t]] c_filtration_values
        for stuff in generator_maps:
            c_generator_maps.push_back(<vector[uint32_t]>(stuff))
        cdef KCriticalFiltration[int32_t] cf
        for F in filtration_values:
            cf.clear()
            for f in F:
                cf.add_point(_py21c_i32(f))
            c_filtration_values.push_back(cf)
        cdef vector[int] c_generator_dimensions = generator_dimensions
        assert num_generators == c_generator_maps.size() == c_filtration_values.size(), "Invalid input, shape do not coincide."
        self.truc = C_KSlicer0_i32(c_generator_maps,c_generator_dimensions, c_filtration_values)
    def copy(self):
        """
        Returns a copy of the slicer.
        """
        copy_ = _KSlicer0_i32()
        copy_.truc = self.truc
        return copy_
    def get_barcode(self):
        """
        Returns the current barcode.
        """
        return self.truc.get_barcode()
    def push_to_line(self, basepoint, direction=None):
        """
        Pushes the current slicer to the line
        """
        cdef Line[int32_t] line
        if direction is None:
            line = Line[int32_t](_py21c_i32(basepoint))
        else:
            line = Line[int32_t](_py21c_i32(basepoint),_py21c_i32(direction))
        self.truc.push_to(line)        
        return self

    def persistence_on_line(self,basepoint,direction=None):
        """
        Computes the persistence on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        self.truc.compute_persistence()
        return self.truc.get_barcode()
    def compute_persistence(self,one_filtration=None):
        """
        Computes the current persistence, or the persistence
        given by the filtration one_filtration (num_generators,).
        """
        if one_filtration is not None:
            self.truc.set_one_filtration(one_filtration)
        self.truc.compute_persistence()
        # return self.truc.get_barcode()
    def get_barcode(self):
        """
        Returns the barcode of the current 1d-persistence.
        """
        return self.truc.get_barcode()
    def sliced_filtration(self,basepoint, direction=None):
        """
        Computes the filtration on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        return np.asarray(self.truc.get_one_filtration())
    def __len__(self):
        return self.truc.num_generators()
    @property
    def num_generators(self):
        return self.truc.num_generators()
    @property
    def num_parameters(self):
        return self.truc.num_parameters()
    def info(self):
        return self.truc.to_str().decode()
    def compute_box(self):
        """
        Computes the bounding box of the current persistence.
        """
        cdef pair[Finitely_critical_multi_filtration[int32_t],Finitely_critical_multi_filtration[int32_t]] box = self.truc.get_bounding_box()
        cdef cnp.ndarray[int32_t, ndim=1] a = _ff21cview_i32(&box.first)
        cdef cnp.ndarray[int32_t, ndim=1] b = _ff21cview_i32(&box.second)
        return np.asarray([a,b])
    def get_filtrations_values(self):
        """
        Returns the current filtration values of the slicer.
        """
        cdef vector[Finitely_critical_multi_filtration[int32_t]] v = self.truc.get_filtration_values()
        out = _vff21cview_i32(v, copy=True)
        return np.asarray(out)
    def get_filtrations(self):
        return _vff2kcview_i32(self.truc.get_filtrations(), copy=True)

    def get_dimensions(self):
        """
        Returns the ordered dimensions of the generators.
        """
        return np.asarray(self.truc.get_dimensions())
    def get_boundaries(self):
        """
        Returns the boundaries of the generators.
        """
        return tuple(tuple(b) for b in self.truc.get_boundaries())
    def grid_squeeze(self, filtration_grid=None, grid_strategy="exact", resolution=-1, bool coordinates=True, bool inplace = False, bool force=False):
        """
        Squeeze the filtration values on a grid.
        """
        if force and self.is_squeezed:
            raise ValueError("The slicer seems to be already squeezed. Use force=True to resqueeze.")
        if filtration_grid is None:
            filtration_grid = mpg.compute_grid(
                    self.get_filtrations_values().T,
                    strategy=grid_strategy,
                    resolution=resolution)
        cdef vector[vector[int32_t]] grid = filtration_grid
        if inplace or not coordinates:
            self.truc.coarsen_on_grid_inplace(grid, coordinates)
            self.filtration_grid = filtration_grid
        else:
          out = _KSlicer0_i32()
          out.truc = self.truc.coarsen_on_grid(grid)
          out.filtration_grid = filtration_grid
          return out
        return self
    def minpres(self,
        int degree = 1, 
        list[int] degrees=[],
        str backend:Literal["mpfree", "2pac"]="mpfree", 
        str slicer_backend:Literal["matrix","clement","graph"]="matrix",
        bool vineyard=False, 
        id :Optional[str] = None,
        dtype = np.int32,
        **minpres_kwargs
        ):
        """
        Computes the minimal presentation of the slicer, and returns it as a new slicer.
        """
        new_slicer = minimal_presentation(self, degree=degree, degrees=degrees, backend=backend, slicer_backend=slicer_backend, vineyard=vineyard, id=id, **minpres_kwargs)
        return new_slicer

    @property
    def dtype(self)->type:
      return np.int32
    @property
    def col_type(self)->str:
      return "INTRUSIVE_SET"
    @property
    def is_vine(self)->bool:
      return False
    @property
    def is_kcritical(self)->bool:
      return True



    @staticmethod
    def from_bitmap(self):
      raise ValueError("Not implemented.")

#------------------------------------------------------------------------------
cdef class _KSlicer0_f32:
    cdef C_KSlicer0_f32 truc
    cdef public vector[vector[double]] filtration_grid
    @property
    def is_squeezed(self)->bool:
        return self.filtration_grid.size() > 0 and self.filtration_grid[0].size() > 0

    def get_ptr(self):
        """
        Returns a pointer to the underlying C++ slicer.
        """
        return <intptr_t>(&self.truc)
    def __init__(self, generator_maps=[], generator_dimensions=[], filtration_values=[]):        
        """
        Constructs a slicer from
         - scc-like blocks 
         or 
         - generator maps (Iterable of list of ints)
         - generator dimensions (Iterable of int)
         - filtration values (Iterable of filtration values)
        """
        pass
    def __cinit__(self, generator_maps=[], generator_dimensions=[], filtration_values=[]):
        """
        Cython constructor
        """
        if len(generator_maps)>0 and len(generator_dimensions) == 0 and len(filtration_values) == 0:
          from multipers._slicer_meta import _blocks2boundary_dimension_grades
          generator_maps, generator_dimensions, filtration_values = _blocks2boundary_dimension_grades(
                  generator_maps,
                  inplace=False,
              )
        cdef uint32_t num_generators = len(generator_maps)
        cdef vector[vector[uint32_t]] c_generator_maps
        cdef vector[KCriticalFiltration[float]] c_filtration_values
        for stuff in generator_maps:
            c_generator_maps.push_back(<vector[uint32_t]>(stuff))
        cdef KCriticalFiltration[float] cf
        for F in filtration_values:
            cf.clear()
            for f in F:
                cf.add_point(_py21c_f32(f))
            c_filtration_values.push_back(cf)
        cdef vector[int] c_generator_dimensions = generator_dimensions
        assert num_generators == c_generator_maps.size() == c_filtration_values.size(), "Invalid input, shape do not coincide."
        self.truc = C_KSlicer0_f32(c_generator_maps,c_generator_dimensions, c_filtration_values)
    def copy(self):
        """
        Returns a copy of the slicer.
        """
        copy_ = _KSlicer0_f32()
        copy_.truc = self.truc
        return copy_
    def get_barcode(self):
        """
        Returns the current barcode.
        """
        return self.truc.get_barcode()
    def push_to_line(self, basepoint, direction=None):
        """
        Pushes the current slicer to the line
        """
        cdef Line[float] line
        if direction is None:
            line = Line[float](_py21c_f32(basepoint))
        else:
            line = Line[float](_py21c_f32(basepoint),_py21c_f32(direction))
        self.truc.push_to(line)        
        return self

    def persistence_on_line(self,basepoint,direction=None):
        """
        Computes the persistence on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        self.truc.compute_persistence()
        return self.truc.get_barcode()
    def compute_persistence(self,one_filtration=None):
        """
        Computes the current persistence, or the persistence
        given by the filtration one_filtration (num_generators,).
        """
        if one_filtration is not None:
            self.truc.set_one_filtration(one_filtration)
        self.truc.compute_persistence()
        # return self.truc.get_barcode()
    def get_barcode(self):
        """
        Returns the barcode of the current 1d-persistence.
        """
        return self.truc.get_barcode()
    def sliced_filtration(self,basepoint, direction=None):
        """
        Computes the filtration on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        return np.asarray(self.truc.get_one_filtration())
    def __len__(self):
        return self.truc.num_generators()
    @property
    def num_generators(self):
        return self.truc.num_generators()
    @property
    def num_parameters(self):
        return self.truc.num_parameters()
    def info(self):
        return self.truc.to_str().decode()
    def compute_box(self):
        """
        Computes the bounding box of the current persistence.
        """
        cdef pair[Finitely_critical_multi_filtration[float],Finitely_critical_multi_filtration[float]] box = self.truc.get_bounding_box()
        cdef cnp.ndarray[float, ndim=1] a = _ff21cview_f32(&box.first)
        cdef cnp.ndarray[float, ndim=1] b = _ff21cview_f32(&box.second)
        return np.asarray([a,b])
    def get_filtrations_values(self):
        """
        Returns the current filtration values of the slicer.
        """
        cdef vector[Finitely_critical_multi_filtration[float]] v = self.truc.get_filtration_values()
        out = _vff21cview_f32(v, copy=True)
        return np.asarray(out)
    def get_filtrations(self):
        return _vff2kcview_f32(self.truc.get_filtrations(), copy=True)

    def get_dimensions(self):
        """
        Returns the ordered dimensions of the generators.
        """
        return np.asarray(self.truc.get_dimensions())
    def get_boundaries(self):
        """
        Returns the boundaries of the generators.
        """
        return tuple(tuple(b) for b in self.truc.get_boundaries())
    def grid_squeeze(self, filtration_grid=None, grid_strategy="exact", resolution=-1, bool coordinates=True, bool inplace = False, bool force=False):
        """
        Squeeze the filtration values on a grid.
        """
        if force and self.is_squeezed:
            raise ValueError("The slicer seems to be already squeezed. Use force=True to resqueeze.")
        if filtration_grid is None:
            filtration_grid = mpg.compute_grid(
                    self.get_filtrations_values().T,
                    strategy=grid_strategy,
                    resolution=resolution)
        cdef vector[vector[float]] grid = filtration_grid
        if inplace or not coordinates:
            self.truc.coarsen_on_grid_inplace(grid, coordinates)
            self.filtration_grid = filtration_grid
        else:
          out = _KSlicer0_i32()
          out.truc = self.truc.coarsen_on_grid(grid)
          out.filtration_grid = filtration_grid
          return out
        return self
    def minpres(self,
        int degree = 1, 
        list[int] degrees=[],
        str backend:Literal["mpfree", "2pac"]="mpfree", 
        str slicer_backend:Literal["matrix","clement","graph"]="matrix",
        bool vineyard=False, 
        id :Optional[str] = None,
        dtype = np.float32,
        **minpres_kwargs
        ):
        """
        Computes the minimal presentation of the slicer, and returns it as a new slicer.
        """
        new_slicer = minimal_presentation(self, degree=degree, degrees=degrees, backend=backend, slicer_backend=slicer_backend, vineyard=vineyard, id=id, **minpres_kwargs)
        return new_slicer

    @property
    def dtype(self)->type:
      return np.float32
    @property
    def col_type(self)->str:
      return "INTRUSIVE_SET"
    @property
    def is_vine(self)->bool:
      return False
    @property
    def is_kcritical(self)->bool:
      return True



    @staticmethod
    def from_bitmap(self):
      raise ValueError("Not implemented.")

#------------------------------------------------------------------------------
cdef class _KSlicer0_f64:
    cdef C_KSlicer0_f64 truc
    cdef public vector[vector[double]] filtration_grid
    @property
    def is_squeezed(self)->bool:
        return self.filtration_grid.size() > 0 and self.filtration_grid[0].size() > 0

    def get_ptr(self):
        """
        Returns a pointer to the underlying C++ slicer.
        """
        return <intptr_t>(&self.truc)
    def __init__(self, generator_maps=[], generator_dimensions=[], filtration_values=[]):        
        """
        Constructs a slicer from
         - scc-like blocks 
         or 
         - generator maps (Iterable of list of ints)
         - generator dimensions (Iterable of int)
         - filtration values (Iterable of filtration values)
        """
        pass
    def __cinit__(self, generator_maps=[], generator_dimensions=[], filtration_values=[]):
        """
        Cython constructor
        """
        if len(generator_maps)>0 and len(generator_dimensions) == 0 and len(filtration_values) == 0:
          from multipers._slicer_meta import _blocks2boundary_dimension_grades
          generator_maps, generator_dimensions, filtration_values = _blocks2boundary_dimension_grades(
                  generator_maps,
                  inplace=False,
              )
        cdef uint32_t num_generators = len(generator_maps)
        cdef vector[vector[uint32_t]] c_generator_maps
        cdef vector[KCriticalFiltration[double]] c_filtration_values
        for stuff in generator_maps:
            c_generator_maps.push_back(<vector[uint32_t]>(stuff))
        cdef KCriticalFiltration[double] cf
        for F in filtration_values:
            cf.clear()
            for f in F:
                cf.add_point(_py21c_f64(f))
            c_filtration_values.push_back(cf)
        cdef vector[int] c_generator_dimensions = generator_dimensions
        assert num_generators == c_generator_maps.size() == c_filtration_values.size(), "Invalid input, shape do not coincide."
        self.truc = C_KSlicer0_f64(c_generator_maps,c_generator_dimensions, c_filtration_values)
    def copy(self):
        """
        Returns a copy of the slicer.
        """
        copy_ = _KSlicer0_f64()
        copy_.truc = self.truc
        return copy_
    def get_barcode(self):
        """
        Returns the current barcode.
        """
        return self.truc.get_barcode()
    def push_to_line(self, basepoint, direction=None):
        """
        Pushes the current slicer to the line
        """
        cdef Line[double] line
        if direction is None:
            line = Line[double](_py21c_f64(basepoint))
        else:
            line = Line[double](_py21c_f64(basepoint),_py21c_f64(direction))
        self.truc.push_to(line)        
        return self

    def persistence_on_line(self,basepoint,direction=None):
        """
        Computes the persistence on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        self.truc.compute_persistence()
        return self.truc.get_barcode()
    def compute_persistence(self,one_filtration=None):
        """
        Computes the current persistence, or the persistence
        given by the filtration one_filtration (num_generators,).
        """
        if one_filtration is not None:
            self.truc.set_one_filtration(one_filtration)
        self.truc.compute_persistence()
        # return self.truc.get_barcode()
    def get_barcode(self):
        """
        Returns the barcode of the current 1d-persistence.
        """
        return self.truc.get_barcode()
    def sliced_filtration(self,basepoint, direction=None):
        """
        Computes the filtration on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        return np.asarray(self.truc.get_one_filtration())
    def __len__(self):
        return self.truc.num_generators()
    @property
    def num_generators(self):
        return self.truc.num_generators()
    @property
    def num_parameters(self):
        return self.truc.num_parameters()
    def info(self):
        return self.truc.to_str().decode()
    def compute_box(self):
        """
        Computes the bounding box of the current persistence.
        """
        cdef pair[Finitely_critical_multi_filtration[double],Finitely_critical_multi_filtration[double]] box = self.truc.get_bounding_box()
        cdef cnp.ndarray[double, ndim=1] a = _ff21cview_f64(&box.first)
        cdef cnp.ndarray[double, ndim=1] b = _ff21cview_f64(&box.second)
        return np.asarray([a,b])
    def get_filtrations_values(self):
        """
        Returns the current filtration values of the slicer.
        """
        cdef vector[Finitely_critical_multi_filtration[double]] v = self.truc.get_filtration_values()
        out = _vff21cview_f64(v, copy=True)
        return np.asarray(out)
    def get_filtrations(self):
        return _vff2kcview_f64(self.truc.get_filtrations(), copy=True)

    def get_dimensions(self):
        """
        Returns the ordered dimensions of the generators.
        """
        return np.asarray(self.truc.get_dimensions())
    def get_boundaries(self):
        """
        Returns the boundaries of the generators.
        """
        return tuple(tuple(b) for b in self.truc.get_boundaries())
    def grid_squeeze(self, filtration_grid=None, grid_strategy="exact", resolution=-1, bool coordinates=True, bool inplace = False, bool force=False):
        """
        Squeeze the filtration values on a grid.
        """
        if force and self.is_squeezed:
            raise ValueError("The slicer seems to be already squeezed. Use force=True to resqueeze.")
        if filtration_grid is None:
            filtration_grid = mpg.compute_grid(
                    self.get_filtrations_values().T,
                    strategy=grid_strategy,
                    resolution=resolution)
        cdef vector[vector[double]] grid = filtration_grid
        if inplace or not coordinates:
            self.truc.coarsen_on_grid_inplace(grid, coordinates)
            self.filtration_grid = filtration_grid
        else:
          out = _KSlicer0_i32()
          out.truc = self.truc.coarsen_on_grid(grid)
          out.filtration_grid = filtration_grid
          return out
        return self
    def minpres(self,
        int degree = 1, 
        list[int] degrees=[],
        str backend:Literal["mpfree", "2pac"]="mpfree", 
        str slicer_backend:Literal["matrix","clement","graph"]="matrix",
        bool vineyard=False, 
        id :Optional[str] = None,
        dtype = np.float64,
        **minpres_kwargs
        ):
        """
        Computes the minimal presentation of the slicer, and returns it as a new slicer.
        """
        new_slicer = minimal_presentation(self, degree=degree, degrees=degrees, backend=backend, slicer_backend=slicer_backend, vineyard=vineyard, id=id, **minpres_kwargs)
        return new_slicer

    @property
    def dtype(self)->type:
      return np.float64
    @property
    def col_type(self)->str:
      return "INTRUSIVE_SET"
    @property
    def is_vine(self)->bool:
      return False
    @property
    def is_kcritical(self)->bool:
      return True



    @staticmethod
    def from_bitmap(self):
      raise ValueError("Not implemented.")

#------------------------------------------------------------------------------
cdef class _Slicer0_i32:
    cdef C_Slicer0_i32 truc
    cdef public vector[vector[double]] filtration_grid
    @property
    def is_squeezed(self)->bool:
        return self.filtration_grid.size() > 0 and self.filtration_grid[0].size() > 0

    def get_ptr(self):
        """
        Returns a pointer to the underlying C++ slicer.
        """
        return <intptr_t>(&self.truc)
    def __init__(self, generator_maps=[], generator_dimensions=[], filtration_values=[]):        
        """
        Constructs a slicer from
         - generator maps (Iterable of list of ints)
         - generator dimensions (Iterable of int)
         - filtration values (Iterable of filtration values)
        """
        pass
    def __cinit__(self, generator_maps=[], generator_dimensions=[], filtration_values=[]):
        """
        Cython constructor
        """
        cdef uint32_t num_generators = len(generator_maps)
        cdef vector[vector[uint32_t]] c_generator_maps
        cdef vector[Finitely_critical_multi_filtration[int32_t]] c_filtration_values
        for stuff in generator_maps:
            c_generator_maps.push_back(<vector[uint32_t]>(stuff))
        for f in filtration_values:
            # cf.clear()
            # for truc in f:
            #     cf.push_back(truc)
            c_filtration_values.push_back(_py21c_i32(f))
        cdef vector[int] c_generator_dimensions = generator_dimensions
        assert num_generators == c_generator_maps.size() == c_filtration_values.size(), "Invalid input, shape do not coincide."
        self.truc = C_Slicer0_i32(c_generator_maps,c_generator_dimensions, c_filtration_values)
    def copy(self):
        """
        Returns a copy of the slicer.
        """
        copy_ = _Slicer0_i32()
        copy_.truc = self.truc
        return copy_
    def get_barcode(self):
        """
        Returns the current barcode.
        """
        return self.truc.get_barcode()
    def push_to_line(self, basepoint, direction=None):
        """
        Pushes the current slicer to the line
        """
        cdef Line[int32_t] line
        if direction is None:
            line = Line[int32_t](_py21c_i32(basepoint))
        else:
            line = Line[int32_t](_py21c_i32(basepoint),_py21c_i32(direction))
        self.truc.push_to(line)        
        return self

    def persistence_on_line(self,basepoint,direction=None):
        """
        Computes the persistence on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        self.truc.compute_persistence()
        return self.truc.get_barcode()
    def compute_persistence(self,one_filtration=None):
        """
        Computes the current persistence, or the persistence
        given by the filtration one_filtration (num_generators,).
        """
        if one_filtration is not None:
            self.truc.set_one_filtration(one_filtration)
        self.truc.compute_persistence()
        # return self.truc.get_barcode()
    def get_barcode(self):
        """
        Returns the barcode of the current 1d-persistence.
        """
        return self.truc.get_barcode()
    def sliced_filtration(self,basepoint, direction=None):
        """
        Computes the filtration on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        return np.asarray(self.truc.get_one_filtration())
    def __len__(self):
        return self.truc.num_generators()
    @property
    def num_generators(self):
        return self.truc.num_generators()
    @property
    def num_parameters(self):
        return self.truc.num_parameters()
    def info(self):
        return self.truc.to_str().decode()
    def compute_box(self):
        """
        Computes the bounding box of the current persistence.
        """
        cdef pair[Finitely_critical_multi_filtration[int32_t],Finitely_critical_multi_filtration[int32_t]] box = self.truc.get_bounding_box()
        cdef cnp.ndarray[int32_t, ndim=1] a = _ff21cview_i32(&box.first)
        cdef cnp.ndarray[int32_t, ndim=1] b = _ff21cview_i32(&box.second)
        return np.asarray([a,b])
    def get_filtrations_values(self):
        """
        Returns the current filtration values of the slicer.
        """
        cdef vector[Finitely_critical_multi_filtration[int32_t]] v = self.truc.get_filtration_values()
        out = _vff21cview_i32(v, copy=True)
        return np.asarray(out)
    def get_filtrations(self):
        return _vff21cview_i32(self.truc.get_filtrations(), copy=True)

    def get_dimensions(self):
        """
        Returns the ordered dimensions of the generators.
        """
        return np.asarray(self.truc.get_dimensions())
    def get_boundaries(self):
        """
        Returns the boundaries of the generators.
        """
        return tuple(tuple(b) for b in self.truc.get_boundaries())
    def grid_squeeze(self, filtration_grid=None, grid_strategy="exact", resolution=-1, bool coordinates=True, bool inplace = False, bool force=False):
        """
        Squeeze the filtration values on a grid.
        """
        if force and self.is_squeezed:
            raise ValueError("The slicer seems to be already squeezed. Use force=True to resqueeze.")
        if filtration_grid is None:
            filtration_grid = mpg.compute_grid(
                    self.get_filtrations_values().T,
                    strategy=grid_strategy,
                    resolution=resolution)
        cdef vector[vector[int32_t]] grid = filtration_grid
        if inplace or not coordinates:
            self.truc.coarsen_on_grid_inplace(grid, coordinates)
            self.filtration_grid = filtration_grid
        else:
          out = _Slicer0_i32()
          out.truc = self.truc.coarsen_on_grid(grid)
          out.filtration_grid = filtration_grid
          return out
        return self
    def minpres(self,
        int degree = 1, 
        list[int] degrees=[],
        str backend:Literal["mpfree", "2pac"]="mpfree", 
        str slicer_backend:Literal["matrix","clement","graph"]="matrix",
        bool vineyard=False, 
        id :Optional[str] = None,
        dtype = np.int32,
        **minpres_kwargs
        ):
        """
        Computes the minimal presentation of the slicer, and returns it as a new slicer.
        """
        new_slicer = minimal_presentation(self, degree=degree, degrees=degrees, backend=backend, slicer_backend=slicer_backend, vineyard=vineyard, id=id, **minpres_kwargs)
        return new_slicer

    @property
    def dtype(self)->type:
      return np.int32
    @property
    def col_type(self)->str:
      return "INTRUSIVE_SET"
    @property
    def is_vine(self)->bool:
      return False
    @property
    def is_kcritical(self)->bool:
      return False



    @staticmethod
    def from_bitmap(self):
      raise ValueError("Not implemented.")

#------------------------------------------------------------------------------
cdef class _Slicer0_f32:
    cdef C_Slicer0_f32 truc
    cdef public vector[vector[double]] filtration_grid
    @property
    def is_squeezed(self)->bool:
        return self.filtration_grid.size() > 0 and self.filtration_grid[0].size() > 0

    def get_ptr(self):
        """
        Returns a pointer to the underlying C++ slicer.
        """
        return <intptr_t>(&self.truc)
    def __init__(self, generator_maps=[], generator_dimensions=[], filtration_values=[]):        
        """
        Constructs a slicer from
         - generator maps (Iterable of list of ints)
         - generator dimensions (Iterable of int)
         - filtration values (Iterable of filtration values)
        """
        pass
    def __cinit__(self, generator_maps=[], generator_dimensions=[], filtration_values=[]):
        """
        Cython constructor
        """
        cdef uint32_t num_generators = len(generator_maps)
        cdef vector[vector[uint32_t]] c_generator_maps
        cdef vector[Finitely_critical_multi_filtration[float]] c_filtration_values
        for stuff in generator_maps:
            c_generator_maps.push_back(<vector[uint32_t]>(stuff))
        for f in filtration_values:
            # cf.clear()
            # for truc in f:
            #     cf.push_back(truc)
            c_filtration_values.push_back(_py21c_f32(f))
        cdef vector[int] c_generator_dimensions = generator_dimensions
        assert num_generators == c_generator_maps.size() == c_filtration_values.size(), "Invalid input, shape do not coincide."
        self.truc = C_Slicer0_f32(c_generator_maps,c_generator_dimensions, c_filtration_values)
    def copy(self):
        """
        Returns a copy of the slicer.
        """
        copy_ = _Slicer0_f32()
        copy_.truc = self.truc
        return copy_
    def get_barcode(self):
        """
        Returns the current barcode.
        """
        return self.truc.get_barcode()
    def push_to_line(self, basepoint, direction=None):
        """
        Pushes the current slicer to the line
        """
        cdef Line[float] line
        if direction is None:
            line = Line[float](_py21c_f32(basepoint))
        else:
            line = Line[float](_py21c_f32(basepoint),_py21c_f32(direction))
        self.truc.push_to(line)        
        return self

    def persistence_on_line(self,basepoint,direction=None):
        """
        Computes the persistence on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        self.truc.compute_persistence()
        return self.truc.get_barcode()
    def compute_persistence(self,one_filtration=None):
        """
        Computes the current persistence, or the persistence
        given by the filtration one_filtration (num_generators,).
        """
        if one_filtration is not None:
            self.truc.set_one_filtration(one_filtration)
        self.truc.compute_persistence()
        # return self.truc.get_barcode()
    def get_barcode(self):
        """
        Returns the barcode of the current 1d-persistence.
        """
        return self.truc.get_barcode()
    def sliced_filtration(self,basepoint, direction=None):
        """
        Computes the filtration on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        return np.asarray(self.truc.get_one_filtration())
    def __len__(self):
        return self.truc.num_generators()
    @property
    def num_generators(self):
        return self.truc.num_generators()
    @property
    def num_parameters(self):
        return self.truc.num_parameters()
    def info(self):
        return self.truc.to_str().decode()
    def compute_box(self):
        """
        Computes the bounding box of the current persistence.
        """
        cdef pair[Finitely_critical_multi_filtration[float],Finitely_critical_multi_filtration[float]] box = self.truc.get_bounding_box()
        cdef cnp.ndarray[float, ndim=1] a = _ff21cview_f32(&box.first)
        cdef cnp.ndarray[float, ndim=1] b = _ff21cview_f32(&box.second)
        return np.asarray([a,b])
    def get_filtrations_values(self):
        """
        Returns the current filtration values of the slicer.
        """
        cdef vector[Finitely_critical_multi_filtration[float]] v = self.truc.get_filtration_values()
        out = _vff21cview_f32(v, copy=True)
        return np.asarray(out)
    def get_filtrations(self):
        return _vff21cview_f32(self.truc.get_filtrations(), copy=True)

    def get_dimensions(self):
        """
        Returns the ordered dimensions of the generators.
        """
        return np.asarray(self.truc.get_dimensions())
    def get_boundaries(self):
        """
        Returns the boundaries of the generators.
        """
        return tuple(tuple(b) for b in self.truc.get_boundaries())
    def grid_squeeze(self, filtration_grid=None, grid_strategy="exact", resolution=-1, bool coordinates=True, bool inplace = False, bool force=False):
        """
        Squeeze the filtration values on a grid.
        """
        if force and self.is_squeezed:
            raise ValueError("The slicer seems to be already squeezed. Use force=True to resqueeze.")
        if filtration_grid is None:
            filtration_grid = mpg.compute_grid(
                    self.get_filtrations_values().T,
                    strategy=grid_strategy,
                    resolution=resolution)
        cdef vector[vector[float]] grid = filtration_grid
        if inplace or not coordinates:
            self.truc.coarsen_on_grid_inplace(grid, coordinates)
            self.filtration_grid = filtration_grid
        else:
          out = _Slicer0_i32()
          out.truc = self.truc.coarsen_on_grid(grid)
          out.filtration_grid = filtration_grid
          return out
        return self
    def minpres(self,
        int degree = 1, 
        list[int] degrees=[],
        str backend:Literal["mpfree", "2pac"]="mpfree", 
        str slicer_backend:Literal["matrix","clement","graph"]="matrix",
        bool vineyard=False, 
        id :Optional[str] = None,
        dtype = np.float32,
        **minpres_kwargs
        ):
        """
        Computes the minimal presentation of the slicer, and returns it as a new slicer.
        """
        new_slicer = minimal_presentation(self, degree=degree, degrees=degrees, backend=backend, slicer_backend=slicer_backend, vineyard=vineyard, id=id, **minpres_kwargs)
        return new_slicer

    @property
    def dtype(self)->type:
      return np.float32
    @property
    def col_type(self)->str:
      return "INTRUSIVE_SET"
    @property
    def is_vine(self)->bool:
      return False
    @property
    def is_kcritical(self)->bool:
      return False



    @staticmethod
    def from_bitmap(self):
      raise ValueError("Not implemented.")

#------------------------------------------------------------------------------
cdef class _Slicer0_f64:
    cdef C_Slicer0_f64 truc
    cdef public vector[vector[double]] filtration_grid
    @property
    def is_squeezed(self)->bool:
        return self.filtration_grid.size() > 0 and self.filtration_grid[0].size() > 0

    def get_ptr(self):
        """
        Returns a pointer to the underlying C++ slicer.
        """
        return <intptr_t>(&self.truc)
    def __init__(self, generator_maps=[], generator_dimensions=[], filtration_values=[]):        
        """
        Constructs a slicer from
         - generator maps (Iterable of list of ints)
         - generator dimensions (Iterable of int)
         - filtration values (Iterable of filtration values)
        """
        pass
    def __cinit__(self, generator_maps=[], generator_dimensions=[], filtration_values=[]):
        """
        Cython constructor
        """
        cdef uint32_t num_generators = len(generator_maps)
        cdef vector[vector[uint32_t]] c_generator_maps
        cdef vector[Finitely_critical_multi_filtration[double]] c_filtration_values
        for stuff in generator_maps:
            c_generator_maps.push_back(<vector[uint32_t]>(stuff))
        for f in filtration_values:
            # cf.clear()
            # for truc in f:
            #     cf.push_back(truc)
            c_filtration_values.push_back(_py21c_f64(f))
        cdef vector[int] c_generator_dimensions = generator_dimensions
        assert num_generators == c_generator_maps.size() == c_filtration_values.size(), "Invalid input, shape do not coincide."
        self.truc = C_Slicer0_f64(c_generator_maps,c_generator_dimensions, c_filtration_values)
    def copy(self):
        """
        Returns a copy of the slicer.
        """
        copy_ = _Slicer0_f64()
        copy_.truc = self.truc
        return copy_
    def get_barcode(self):
        """
        Returns the current barcode.
        """
        return self.truc.get_barcode()
    def push_to_line(self, basepoint, direction=None):
        """
        Pushes the current slicer to the line
        """
        cdef Line[double] line
        if direction is None:
            line = Line[double](_py21c_f64(basepoint))
        else:
            line = Line[double](_py21c_f64(basepoint),_py21c_f64(direction))
        self.truc.push_to(line)        
        return self

    def persistence_on_line(self,basepoint,direction=None):
        """
        Computes the persistence on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        self.truc.compute_persistence()
        return self.truc.get_barcode()
    def compute_persistence(self,one_filtration=None):
        """
        Computes the current persistence, or the persistence
        given by the filtration one_filtration (num_generators,).
        """
        if one_filtration is not None:
            self.truc.set_one_filtration(one_filtration)
        self.truc.compute_persistence()
        # return self.truc.get_barcode()
    def get_barcode(self):
        """
        Returns the barcode of the current 1d-persistence.
        """
        return self.truc.get_barcode()
    def sliced_filtration(self,basepoint, direction=None):
        """
        Computes the filtration on a line L defined by 
         - a basepoint (num_parameters,) array
         - an optional direction (num_parameters,) array
        """
        self.push_to_line(basepoint,direction)
        return np.asarray(self.truc.get_one_filtration())
    def __len__(self):
        return self.truc.num_generators()
    @property
    def num_generators(self):
        return self.truc.num_generators()
    @property
    def num_parameters(self):
        return self.truc.num_parameters()
    def info(self):
        return self.truc.to_str().decode()
    def compute_box(self):
        """
        Computes the bounding box of the current persistence.
        """
        cdef pair[Finitely_critical_multi_filtration[double],Finitely_critical_multi_filtration[double]] box = self.truc.get_bounding_box()
        cdef cnp.ndarray[double, ndim=1] a = _ff21cview_f64(&box.first)
        cdef cnp.ndarray[double, ndim=1] b = _ff21cview_f64(&box.second)
        return np.asarray([a,b])
    def get_filtrations_values(self):
        """
        Returns the current filtration values of the slicer.
        """
        cdef vector[Finitely_critical_multi_filtration[double]] v = self.truc.get_filtration_values()
        out = _vff21cview_f64(v, copy=True)
        return np.asarray(out)
    def get_filtrations(self):
        return _vff21cview_f64(self.truc.get_filtrations(), copy=True)

    def get_dimensions(self):
        """
        Returns the ordered dimensions of the generators.
        """
        return np.asarray(self.truc.get_dimensions())
    def get_boundaries(self):
        """
        Returns the boundaries of the generators.
        """
        return tuple(tuple(b) for b in self.truc.get_boundaries())
    def grid_squeeze(self, filtration_grid=None, grid_strategy="exact", resolution=-1, bool coordinates=True, bool inplace = False, bool force=False):
        """
        Squeeze the filtration values on a grid.
        """
        if force and self.is_squeezed:
            raise ValueError("The slicer seems to be already squeezed. Use force=True to resqueeze.")
        if filtration_grid is None:
            filtration_grid = mpg.compute_grid(
                    self.get_filtrations_values().T,
                    strategy=grid_strategy,
                    resolution=resolution)
        cdef vector[vector[double]] grid = filtration_grid
        if inplace or not coordinates:
            self.truc.coarsen_on_grid_inplace(grid, coordinates)
            self.filtration_grid = filtration_grid
        else:
          out = _Slicer0_i32()
          out.truc = self.truc.coarsen_on_grid(grid)
          out.filtration_grid = filtration_grid
          return out
        return self
    def minpres(self,
        int degree = 1, 
        list[int] degrees=[],
        str backend:Literal["mpfree", "2pac"]="mpfree", 
        str slicer_backend:Literal["matrix","clement","graph"]="matrix",
        bool vineyard=False, 
        id :Optional[str] = None,
        dtype = np.float64,
        **minpres_kwargs
        ):
        """
        Computes the minimal presentation of the slicer, and returns it as a new slicer.
        """
        new_slicer = minimal_presentation(self, degree=degree, degrees=degrees, backend=backend, slicer_backend=slicer_backend, vineyard=vineyard, id=id, **minpres_kwargs)
        return new_slicer

    @property
    def dtype(self)->type:
      return np.float64
    @property
    def col_type(self)->str:
      return "INTRUSIVE_SET"
    @property
    def is_vine(self)->bool:
      return False
    @property
    def is_kcritical(self)->bool:
      return False



    @staticmethod
    def from_bitmap(self):
      raise ValueError("Not implemented.")


def from_function_delaunay(
    points,
    grades,
    int degree=-1,
    str backend: Literal["matrix", "clement"] = "matrix",
    bool vineyard=True,
    bool verbose = False,
    bool clear = True,
):
    """
    Given points in $\mathbb R^n$ and function grades, compute the function-delaunay
    bifiltration as a in an scc format, and converts it into a slicer.

    points : (num_pts, n) float array
    grades : (num_pts,) float array
    degree (opt) : if given, computes a minimal presentation of this homological degree first
    backend : slicer backend, e.g. "matrix", "clement"
    vineyard : bool, use a vineyard-compatible backend
    """
    blocks = mio.function_delaunay_presentation(points, grades, degree=degree, verbose=verbose,clear=clear)
    return multipers.Slicer(blocks, backend=backend, vineyard=vineyard)

def slicer2blocks(slicer, int degree = -1, bool reverse=True):
    """
    Convert any slicer to the block format a.k.a. scc format for python
    """
    dims = slicer.get_dimensions()
    num_empty_blocks_to_add = 1 if degree == -1 else dims.min()-degree +1
    _,counts = np.unique(dims, return_counts=True, )
    indices = np.concatenate([[0],counts], dtype=np.int32).cumsum()
    filtration_values = slicer.get_filtrations()
    filtration_values = [filtration_values[indices[i]:indices[i+1]] for i in range(len(indices)-1)]
    boundaries = slicer.get_boundaries()
    boundaries = [boundaries[indices[i]:indices[i+1]] for i in range(len(indices)-1)]
    shift = np.concatenate([[0], indices], dtype=np.int32)
    boundaries = [tuple(np.asarray(x-s, dtype=np.int32) for x in block)  for s,block in zip(shift,boundaries)]
    blocks = [tuple((f,tuple(b))) for b,f in zip(boundaries,filtration_values)]
    blocks = ([(np.empty((0,)),[])]*num_empty_blocks_to_add) + blocks
    if reverse:
        blocks.reverse()
    return blocks

def minimal_presentation(
        slicer,
        int degree = 1, 
        list[int] degrees=[],
        str backend:Literal["mpfree", "2pac"]="mpfree", 
        str slicer_backend:Literal["matrix","clement","graph"]="matrix",
        bool vineyard=True, 
        id :Optional[str] =None,
        dtype=None,
        **minpres_kwargs
        ):
    """
    Computes a minimal presentation of the multifiltered complex given by the slicer,
    and returns it as a slicer.
    Only works for mpfree for the moment.
    """
    if len(degrees)>0:
        return tuple(minimal_presentation(slicer, degree=d, backend=backend, slicer_backend=slicer_backend, vineyard=vineyard, id=id, **minpres_kwargs) for d in degrees)
    filtration_grid = slicer.filtration_grid if slicer.is_squeezed else None
    blocks = to_blocks(slicer)
    if id is None:
        id = str(threading.get_native_id())
    if dtype is None:
        dtype = slicer.dtype
    mio._init_external_softwares(requires=[backend])
    mio.scc2disk(blocks,path=mio.input_path+id, strip_comments=True)
    dimension = len(blocks) -2 - degree # latest  = L-1, which is empty, -1 for degree 0, -2 for degree 1 etc.
    new_blocks = mio.scc_reduce_from_str(path=mio.input_path+id,dimension=dimension, backend=backend, **minpres_kwargs)
    new_slicer = multipers.Slicer(new_blocks,backend=slicer_backend, vineyard=vineyard, dtype=dtype)
    if filtration_grid is not None:
      new_slicer.filtration_grid = filtration_grid
    return new_slicer


def to_simplextree(s:Slicer_type, max_dim:int=-1):
    """
    Turns a --simplicial-- slicer into a simplextree.

    Warning: Won't work for non-simplicial complexes, 
    i.e., complexes $K$ not satisfying 
    $\forall \sigma \in K,\, \mathrm{dim}(\sigma) = |\partial \sigma|-1$
    """
    dims = s.get_dimensions()
    assert np.all(dims[:-1] <= dims[1:]), "Dims is not sorted."
    idx = np.searchsorted(dims, np.unique(dims))
    idx = np.concatenate([idx, [dims.shape[0]]])
    if max_dim>=0:
        idx = idx[:max_dim+2]

    cdef vector[vector[int]] boundaries_ = s.get_boundaries()
    cdef int a
    cdef int b
    if len(idx)>2:
        a = idx[2]
        b = idx[-1]
        for i in range(a, b):
            boundaries_[i] = np.unique(np.concatenate([boundaries_[k] for k in boundaries_[i]]))
    boundaries = [np.asarray(boundaries_[idx[i]:idx[i+1]]).T for i in range(len(idx)-1)]
    boundaries[0] = np.arange(boundaries[0].shape[1])[None,:]
    filtrations = s.get_filtrations()
    num_parameters  = s.num_parameters
    filtrations=tuple(filtrations[idx[i]:idx[i+1]] for i in range(len(idx)-1)) # TODO : optimize ?
    st = SimplexTreeMulti(num_parameters = num_parameters, dtype = s.dtype)
    for i in range(len(filtrations)):
        if s.is_kcritical:
          for f in filtrations[i]:
            st.insert(np.asarray(boundaries[i], dtype = np.int32),np.asarray(f, dtype=s.dtype))
        else:
          st.insert_batch(np.asarray(boundaries[i], dtype= np.int32),np.asarray(filtrations[i], dtype=s.dtype))
    return st


def is_slicer(object input)->bool:
    return (False 
        or isinstance(input, _SlicerClement)
        or isinstance(input, _SlicerVineGraph)
        or isinstance(input, _SlicerVineSimplicial)
        or isinstance(input, _SlicerNoVineSimplicial)
        or isinstance(input, _KSlicer0_vine_i32)
        or isinstance(input, _KSlicer0_vine_f32)
        or isinstance(input, _KSlicer0_vine_f64)
        or isinstance(input, _Slicer0_vine_i32)
        or isinstance(input, _Slicer0_vine_f32)
        or isinstance(input, _Slicer0_vine_f64)
        or isinstance(input, _KSlicer0_i32)
        or isinstance(input, _KSlicer0_f32)
        or isinstance(input, _KSlicer0_f64)
        or isinstance(input, _Slicer0_i32)
        or isinstance(input, _Slicer0_f32)
        or isinstance(input, _Slicer0_f64)
      )


def to_blocks(input):
    """
    Converts input to blocks, if possible.
    """
    if is_slicer(input):
      return slicer2blocks(input)
    if isinstance(input, list) or isinstance(input, tuple):
      return input
    if isinstance(input, multipers.simplex_tree_multi.SimplexTreeMulti):
      return mio.simplextree2scc(input)
    if isinstance(input, str) or isinstance(input, os.PathLike):
      return mio.scc_parser(input)
    raise ValueError("Input cannot be converted to blocks.")



cdef dict[tuple[bool,bool,type],object] slicer_dict = {
  (True, False, np.dtype(np.float32), ""): _SlicerClement,
  (True, True, np.dtype(np.int32), "INTRUSIVE_SET"): _KSlicer0_vine_i32,
  (True, True, np.dtype(np.float32), "INTRUSIVE_SET"): _KSlicer0_vine_f32,
  (True, True, np.dtype(np.float64), "INTRUSIVE_SET"): _KSlicer0_vine_f64,
  (True, False, np.dtype(np.int32), "INTRUSIVE_SET"): _Slicer0_vine_i32,
  (True, False, np.dtype(np.float32), "INTRUSIVE_SET"): _Slicer0_vine_f32,
  (True, False, np.dtype(np.float64), "INTRUSIVE_SET"): _Slicer0_vine_f64,
  (False, True, np.dtype(np.int32), "INTRUSIVE_SET"): _KSlicer0_i32,
  (False, True, np.dtype(np.float32), "INTRUSIVE_SET"): _KSlicer0_f32,
  (False, True, np.dtype(np.float64), "INTRUSIVE_SET"): _KSlicer0_f64,
  (False, False, np.dtype(np.int32), "INTRUSIVE_SET"): _Slicer0_i32,
  (False, False, np.dtype(np.float32), "INTRUSIVE_SET"): _Slicer0_f32,
  (False, False, np.dtype(np.float64), "INTRUSIVE_SET"): _Slicer0_f64,
}

def get_matrix_slicer(bool is_vineyard, bool is_k_critical, type dtype, str col):
  slicer = slicer_dict.get((is_vineyard, is_k_critical, np.dtype(dtype), col), None)
  if slicer is None:
    raise ValueError(f"Unimplemented combo for Matrix : {is_vineyard=}, {is_k_critical=}, {dtype=}")
  return slicer




