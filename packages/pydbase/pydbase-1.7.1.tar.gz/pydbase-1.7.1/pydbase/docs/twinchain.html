<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>twinchain API documentation</title>
<meta name="description" content="&lt;pre&gt; â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>twinchain</code></h1>
</header>
<section id="section-intro">
<pre>

Block chain layer on top of twincore.

   |   Time Now    |   Time  Now    |  Time Now     |
   |   hash256   | |    hash256   | |   hash256   | |
   |   Header    | |    Header    | |   Header    | |
   |   Payload   | |    Payload   | |   Payload   | |
   |   Backlink  | |    Backlink  | |   Backlink  | |
                 |----->---|      |---->---|     |------

   The sum of fields saved to the next backlink.

   History:

   1.1         Tue 20.Feb.2024     Initial release
   1.2.0       Mon 26.Feb.2024     Moved pip home to pydbase/
   1.4.0       Tue 27.Feb.2024     Addedd pgdebug
   1.4.2       Wed 28.Feb.2024     Fixed multiple instances
   1.4.3       Wed 28.Feb.2024     ChainAdm added
   1.4.4       Fri 01.Mar.2024     Tests for chain functions
   1.4.5       Fri 01.Mar.2024     Misc fixes
   1.4.6       Mon 04.Mar.2024     Vacuum count on vacuumed records
   1.4.7       Tue 05.Mar.2024     In place record update
   1.4.8       Sat 09.Mar.2024     Added new locking mechanism
   1.4.9       Mon 01.Apr.2024     Updated to run on MSYS2, new locking
   1.5.0       Tue 02.Apr.2024     Cleaned, pip upload
   1.5.1       Wed 10.Apr.2024     Dangling lock .. fixed

   </pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

&#39;&#39;&#39;
    &lt;pre&gt;

 Block chain layer on top of twincore.

    |   Time Now    |   Time  Now    |  Time Now     |
    |   hash256   | |    hash256   | |   hash256   | |
    |   Header    | |    Header    | |   Header    | |
    |   Payload   | |    Payload   | |   Payload   | |
    |   Backlink  | |    Backlink  | |   Backlink  | |
                  |-----&gt;---|      |----&gt;---|     |------

    The sum of fields saved to the next backlink.

    History:

    1.1         Tue 20.Feb.2024     Initial release
    1.2.0       Mon 26.Feb.2024     Moved pip home to pydbase/
    1.4.0       Tue 27.Feb.2024     Addedd pgdebug
    1.4.2       Wed 28.Feb.2024     Fixed multiple instances
    1.4.3       Wed 28.Feb.2024     ChainAdm added
    1.4.4       Fri 01.Mar.2024     Tests for chain functions
    1.4.5       Fri 01.Mar.2024     Misc fixes
    1.4.6       Mon 04.Mar.2024     Vacuum count on vacuumed records
    1.4.7       Tue 05.Mar.2024     In place record update
    1.4.8       Sat 09.Mar.2024     Added new locking mechanism
    1.4.9       Mon 01.Apr.2024     Updated to run on MSYS2, new locking
    1.5.0       Tue 02.Apr.2024     Cleaned, pip upload
    1.5.1       Wed 10.Apr.2024     Dangling lock .. fixed

    &lt;/pre&gt;
&#39;&#39;&#39;

import  os, sys, getopt, signal, select, socket, time, struct
import  random, stat, os.path, datetime, threading, uuid
import  struct, io, hashlib

import pyvpacker

base = os.path.dirname(os.path.realpath(__file__))
sys.path.append(os.path.join(base, &#39;..&#39;, &#39;pydbase&#39;))

from dbutils import *
from twincore import *

version         = &#34;1.4.3&#34;
ProtocolVersion = &#34;1.0&#34;

# Exceptions for bad records

class DBCheckError(Exception):

    def __init__(self, message):
         self.message = message

class DBLinkError(Exception):

    def __init__(self, message):
         self.message = message

# ------------------------------------------------------------------------

class TwinChain(TwinCore):

    &#39;&#39;&#39;
        Derive from database to accomodate block chain.
    &#39;&#39;&#39;

    def __init__(self, fname = &#34;pydbchain.pydb&#34;, pgdebug = 0, verbose = 0):

        self.chain_verbose = verbose

        # Upper lock name
        ulockname = os.path.splitext(fname)[0] + &#34;.ulock&#34;
        self.ulock = FileLock(ulockname)
        self.ulock.waitlock()    #(self.ulockname)

        super(TwinChain, self).__init__(fname, pgdebug)

        self.packer = pyvpacker.packbin()

        sss = self.getdbsize()
        &#39;&#39;&#39;if sss == 0:
            # Produce initial data structure
            # This is the wron place to produce it, as the chain has no
            # knowledge of the actual structure ... we provide minimum here
            header = str(uuid.uuid1())
            dt = datetime.datetime.utcnow()
            fdt = dt.strftime(&#39;%a, %d %b %Y %H:%M:%S`&#39;)

            payload = {&#34;Initial&#34;: &#34;Initial record, do not use.&#34;,
                            &#34;Default&#34; : &#39;None&#39;, &#34;header&#34;: header}

            #payload2 = {&#34;header&#34;: header, &#34;payload&#34; : payload}

            # Here we fake the initial backlink for the anchor record
            old_dicx = {}
            old_dicx[&#34;now&#34;] =  fdt
            old_dicx[&#34;hash256&#34;]  =  self._hash_any(payload).hexdigest()
            old_dicx[&#34;header&#34;]   =  header
            old_dicx[&#34;payload&#34;]  =  payload
            old_dicx[&#34;backlink&#34;] =  &#34;&#34;

            #print(&#34;old_dicx:&#34;, self.old_dicx)

            aaa = self._fill_record(header, payload, old_dicx)
            #print(&#34;aaa:&#34;, aaa)
            encoded = self.packer.encode_data(&#34;&#34;, [aaa])
            #print(&#34;encoded:&#34;, encoded)

            self.save_data(header, encoded)
        &#39;&#39;&#39;

        self.ulock.unlock() #self.ulockname)

    def _hashtohex(self, varx):

        if type(varx) == type(&#34;&#34;):
            varx = varx.encode()

        hh = hashlib.new(&#34;sha256&#34;);
        hh.update(varx)
        return hh.hexdigest()

    def _hash_any(self, any):

        hh = hashlib.new(&#34;sha256&#34;);
        if type(any) == type(&#34;&#34;):
            hh.update(any)
        if type(any) == type({}):
            sss = self._expand_dict(any)
            hh.update(sss.encode())
        return hh

    def _expand_dict(self, dicx):

        sstr = &#34;&#34;
        if type(dicx) == type({}):
            for aa in sorted(dicx.keys()):
                sstr += aa + &#34;:&#34; + dicx[aa]
        if type(dicx) == type([]):
            for aa in dicx:
                sstr += aa
        if type(dicx) == type(&#34;&#34;):
            sstr = dicx
        if type(dicx) == type(b&#34;&#34;):
            sstr = dicx

        #print(&#34;sstr&#34;, sstr)
        return sstr

    def _build_sumstr(self, aaa):

        sumstr  = aaa.get(&#39;now&#39;, &#34;&#34;)
        sumstr += aaa.get(&#39;header&#39;, &#34;&#34;)
        sumstr += self._expand_dict(aaa.get(&#39;payload&#39;, &#34;&#34;))
        #print(&#34;raw sumstr&#34;, sumstr)
        return sumstr

    def _build_backlink(self, dicold):

        backlink  =  dicold.get(&#34;now&#34;, &#34;&#34;)
        backlink +=  dicold.get(&#34;hash256&#34;, &#34;&#34;)
        backlink += dicold.get(&#34;header&#34;, &#34;&#34;)
        backlink += self._expand_dict(dicold.get(&#34;payload&#34;, &#34;&#34;))
        backlink += dicold.get(&#34;backlink&#34;, &#34;&#34;)
        #print(&#34;raw backlink&#34;, backlink)
        return backlink

    # --------------------------------------------------------------------

    def _fill_record(self, header, payload, old_dict):

        aaa = {}
        aaa[&#34;header&#34;] = header
        aaa[&#34;payload&#34;] = payload
        aaa[&#34;protocol&#34;] = ProtocolVersion

        dt = datetime.datetime.now()
        fdt = dt.strftime(&#39;%a, %d %b %Y %H:%M:%S&#39;)
        aaa[&#34;now&#34;] = fdt
        #self._key_n_data(aaa, &#34;hash32&#34;, str(self.hash32(payload)))

        sumstr = self._build_sumstr(aaa)
        aaa[&#34;hash256&#34;] = self._hashtohex(sumstr)

        backlink = self._build_backlink(old_dict)
        aaa[&#34;backlink&#34;] = self._hashtohex(backlink)

        return aaa

    def get_payload(self, recnum):

        &#39;&#39;&#39; Return the payload on record number &#39;&#39;&#39;

        arr = self.get_rec(recnum)
        if not arr:
            return []
        try:
            decoded = self.packer.decode_data(arr[1])
            #print(&#34;decoded&#34;, decoded)
        except:
            print(&#34;Cannot decode record at&#34;, recnum, recnum, sys.exc_info())
            raise
        dic = self._get_fields(decoded[0])

        if self.chain_verbose &gt; 2:
            print(dic)
        if self.chain_verbose &gt; 0:
            print(dic[&#39;header&#39;] + &#34; &#34; + dic[&#39;now&#39;], dic[&#39;payload&#39;])

        return arr[0].decode(), dic[&#39;payload&#39;]

    def get_payoffs_bykey(self, keyval, maxrec = 1):
        &#34; get payload offset by key&#34;
        arr = []
        rrr = self.getdbsize()
        for aa in range(rrr -1, -1, -1):
            head = self.get_header(aa)
            if head == keyval:
                arr.append(aa)
                if len(arr) &gt;= maxrec:
                    break
        return arr

    def get_data_bykey(self, keyval, maxrec = 1, check = True):

        &#39;&#39;&#39; Get data by key value. Searches the database from the back so lastly
            entered data is presented.

            Input:

                keyval    :    value to search for
                maxrec    :    maximum number of records
                check     :    check as found. Raises exception

            Returns:

                data array matching criteria.

        &#39;&#39;&#39;
        arr = []
        rrr = self.getdbsize()
        for aa in range(rrr -1, -1, -1):
            head = self.get_header(aa)
            if head == keyval:
                ch = self.checkdata(aa)
                li = self.linkintegrity(aa)

                if self.chain_verbose:
                    print(&#34;li&#34;, li, &#34;ch&#34;, ch)

                if not ch:
                    raise  DBCheckError(&#34;Check failed at rec %a&#34; % aa);
                if not li:
                    raise  DBLinkError(&#34;Link checl failed at rec %a&#34; % aa);

                pay = self.get_payload(aa)
                arr.append((head, pay))
                if len(arr) &gt;= maxrec:
                    break
        return arr

    def get_header(self, recnum):

        &#39;&#39;&#39; Get the header of record. &#39;&#39;&#39;

        if self.pgdebug &gt; 5:
            print(&#34;get_header()&#34;, recnum)
        arr = self.get_rec(recnum)
        if not arr:
            if self.pgdebug &gt; 5:
                print(&#34;get_header(): empty/deleted record&#34;, recnum)

            if self.chain_verbose &gt; 1:
                print(&#34;get_header(): empty/deleted record&#34;, recnum)
            return []

        if self.chain_verbose &gt; 1:
            print(&#34;arr&#34;, arr)
            uuu = uuid.UUID(arr[0].decode())
            ddd = str(uuid2date(uuu))
            print(&#34;header&#34;, arr[0])
        return arr[0].decode()

    def linkintegrity(self, recnum):

        &#39;&#39;&#39; Scan one record an its integrity based on the previous one &#39;&#39;&#39;

        if recnum &lt; 1:
            if self.chain_verbose:
                print(&#34;Cannot check initial record.&#34;)
            return True

        if self.chain_verbose &gt; 4:
            print(&#34;Checking link ...&#34;, recnum)

        arr = self.get_rec(recnum-1)
        try:
            decoded = self.packer.decode_data(arr[1])
        except:
            print(&#34;Cannot decode prev:&#34;, recnum, sys.exc_info())
            return
        dicold = self._get_fields(decoded[0])
        arr2 = self.get_rec(recnum)
        try:
            decoded2 = self.packer.decode_data(arr2[1])
        except:
            if self.chain_verbose &gt; 2:
                print(&#34;Cannot decode curr:&#34;, recnum, sys.exc_info())
            return
        dic = self._get_fields(decoded2[0])
        backlink = self._build_backlink(dicold)
        hhh = self._hashtohex(backlink)
        if self.chain_verbose &gt; 2:
            print(&#34;calc      &#34;, hhh)
            print(&#34;backlink  &#34;, dic[&#39;backlink&#39;])
        return hhh == dic[&#39;backlink&#39;]

    def checkdata(self, recnum):

        &#39;&#39;&#39; Integrity check of record. &#39;&#39;&#39;

        arr = self.get_rec(recnum)
        try:
            decoded = self.packer.decode_data(arr[1])
        except:
            if self.chain_verbose &gt; 2:
                print(&#34;Cannot decode:&#34;, recnum, sys.exc_info())
            return

        aaa = self._get_fields(decoded[0])
        sumstr = self._build_sumstr(aaa)
        hhh = self._hashtohex(sumstr)
        if self.chain_verbose &gt; 1:
            print(&#34;data&#34;, hhh)
        if self.chain_verbose &gt; 2:
            print(&#34;hash&#34;, aaa[&#39;hash256&#39;])
        return hhh == aaa[&#39;hash256&#39;]

    def appendwith(self, header, datax):

        &#39;&#39;&#39; Append data and header to the end of database &#39;&#39;&#39;

        #if type(header) != type(b&#34;&#34;):
        #    header = header.encode() #errors=&#39;strict&#39;)

        #if type(datax) != type(b&#34;&#34;):
        #    datax = datax.encode() #errors=&#39;strict&#39;)

        if self.chain_verbose &gt; 0:
            print(&#34;Appendwith&#34;, header, datax)

        self.ulock.waitlock()    #self.ulockname)

        try:
            uuu = uuid.UUID(header)
        except:
            if self.chain_verbose:
                print(&#34;Header override must be a valid UUID string.&#34;)

            self.ulock.unlock() #self.ulockname)
            raise ValueError(&#34;Header override must be a valid UUID string.&#34;)

        old_dicx = {}
        # Get last data from db
        sss = self.getdbsize()
        #print(&#34;sss&#34;, sss)

        # We fake an empty set ... checking against an empty set is a valid OP
        if not sss:
            #raise ValueError(&#34;Invalid database, must have at least one record.&#34;)
            ddd = self.packer.encode_data(&#34;&#34;, {&#34;blank&#34;: 0, })
            ooo = [0, ddd,]
        else:
            ooo = self.get_rec(sss-1)

        if self.pgdebug &gt; 5:
            print(&#34;decoding&#34;, ooo)

        decoded = self.packer.decode_data(ooo[1])
        old_dicx = self._get_fields(decoded[0])

        #print(&#34;old_fff&#34;, old_dicx[&#34;hash256&#34;])
        #print(&#34;old_time&#34;, old_dicx[&#34;now&#34;])

        aaa = self._fill_record(header, datax, old_dicx)
        encoded = self.packer.encode_data(&#34;&#34;, aaa)

        #print(&#34;save&#34;, header, &#34;-&#34;, encoded)
        #print(&#34;bbb&#34;, self.getdbsize())
        self.save_data(header, encoded)
        #print(&#34;eee&#34;, self.getdbsize())

        if self.chain_verbose &gt; 1:
            bbb = self.packer.decode_data(encoded)
            print(&#34;Rec&#34;, bbb[0])

        self.ulock.unlock() #self.ulockname)
        return True

    def append(self, datax):

        &#39;&#39;&#39; Append data to the end of database &#39;&#39;&#39;

        if self.chain_verbose &gt; 0:
            print(&#34;Append&#34;, datax)

        # Get last data from db
        #sss = self.getdbsize()
        #if not sss:
        #    #raise ValueError(&#34;Invalid database, must have at least one record.&#34;)
        #    pass

        # Produce header  structure
        uuu = uuid.uuid1()
        #print(&#34;uuid date&#34;,uuid2date(uuu))
        header = str(uuu)
        uuuu = uuid.UUID(header)
        #print(&#34;uuid date2&#34;, header, uuid2date(uuuu))
        ret = self.appendwith(header, datax)
        return ret

    def dump_rec(self, bbb):

        &#39;&#39;&#39; Dump one record to console &#39;&#39;&#39;

        for aa in range(len(bbb)//2):
            print(pad(bbb[2*aa]), &#34;=&#34;, bbb[2*aa+1])

    def _get_fields(self, bbb):
        if type(bbb) == type({}):
            dicx = bbb
        else:
            dicx = {}
            for aa in range(len(bbb)//2):
                dicx[bbb[2*aa]] = bbb[2*aa+1]
        return dicx

# EOF</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="twinchain.DBCheckError"><code class="flex name class">
<span>class <span class="ident">DBCheckError</span></span>
<span>(</span><span>message)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DBCheckError(Exception):

    def __init__(self, message):
         self.message = message</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="twinchain.DBLinkError"><code class="flex name class">
<span>class <span class="ident">DBLinkError</span></span>
<span>(</span><span>message)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DBLinkError(Exception):

    def __init__(self, message):
         self.message = message</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="twinchain.TwinChain"><code class="flex name class">
<span>class <span class="ident">TwinChain</span></span>
<span>(</span><span>fname='pydbchain.pydb', pgdebug=0, verbose=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Derive from database to accomodate block chain.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TwinChain(TwinCore):

    &#39;&#39;&#39;
        Derive from database to accomodate block chain.
    &#39;&#39;&#39;

    def __init__(self, fname = &#34;pydbchain.pydb&#34;, pgdebug = 0, verbose = 0):

        self.chain_verbose = verbose

        # Upper lock name
        ulockname = os.path.splitext(fname)[0] + &#34;.ulock&#34;
        self.ulock = FileLock(ulockname)
        self.ulock.waitlock()    #(self.ulockname)

        super(TwinChain, self).__init__(fname, pgdebug)

        self.packer = pyvpacker.packbin()

        sss = self.getdbsize()
        &#39;&#39;&#39;if sss == 0:
            # Produce initial data structure
            # This is the wron place to produce it, as the chain has no
            # knowledge of the actual structure ... we provide minimum here
            header = str(uuid.uuid1())
            dt = datetime.datetime.utcnow()
            fdt = dt.strftime(&#39;%a, %d %b %Y %H:%M:%S`&#39;)

            payload = {&#34;Initial&#34;: &#34;Initial record, do not use.&#34;,
                            &#34;Default&#34; : &#39;None&#39;, &#34;header&#34;: header}

            #payload2 = {&#34;header&#34;: header, &#34;payload&#34; : payload}

            # Here we fake the initial backlink for the anchor record
            old_dicx = {}
            old_dicx[&#34;now&#34;] =  fdt
            old_dicx[&#34;hash256&#34;]  =  self._hash_any(payload).hexdigest()
            old_dicx[&#34;header&#34;]   =  header
            old_dicx[&#34;payload&#34;]  =  payload
            old_dicx[&#34;backlink&#34;] =  &#34;&#34;

            #print(&#34;old_dicx:&#34;, self.old_dicx)

            aaa = self._fill_record(header, payload, old_dicx)
            #print(&#34;aaa:&#34;, aaa)
            encoded = self.packer.encode_data(&#34;&#34;, [aaa])
            #print(&#34;encoded:&#34;, encoded)

            self.save_data(header, encoded)
        &#39;&#39;&#39;

        self.ulock.unlock() #self.ulockname)

    def _hashtohex(self, varx):

        if type(varx) == type(&#34;&#34;):
            varx = varx.encode()

        hh = hashlib.new(&#34;sha256&#34;);
        hh.update(varx)
        return hh.hexdigest()

    def _hash_any(self, any):

        hh = hashlib.new(&#34;sha256&#34;);
        if type(any) == type(&#34;&#34;):
            hh.update(any)
        if type(any) == type({}):
            sss = self._expand_dict(any)
            hh.update(sss.encode())
        return hh

    def _expand_dict(self, dicx):

        sstr = &#34;&#34;
        if type(dicx) == type({}):
            for aa in sorted(dicx.keys()):
                sstr += aa + &#34;:&#34; + dicx[aa]
        if type(dicx) == type([]):
            for aa in dicx:
                sstr += aa
        if type(dicx) == type(&#34;&#34;):
            sstr = dicx
        if type(dicx) == type(b&#34;&#34;):
            sstr = dicx

        #print(&#34;sstr&#34;, sstr)
        return sstr

    def _build_sumstr(self, aaa):

        sumstr  = aaa.get(&#39;now&#39;, &#34;&#34;)
        sumstr += aaa.get(&#39;header&#39;, &#34;&#34;)
        sumstr += self._expand_dict(aaa.get(&#39;payload&#39;, &#34;&#34;))
        #print(&#34;raw sumstr&#34;, sumstr)
        return sumstr

    def _build_backlink(self, dicold):

        backlink  =  dicold.get(&#34;now&#34;, &#34;&#34;)
        backlink +=  dicold.get(&#34;hash256&#34;, &#34;&#34;)
        backlink += dicold.get(&#34;header&#34;, &#34;&#34;)
        backlink += self._expand_dict(dicold.get(&#34;payload&#34;, &#34;&#34;))
        backlink += dicold.get(&#34;backlink&#34;, &#34;&#34;)
        #print(&#34;raw backlink&#34;, backlink)
        return backlink

    # --------------------------------------------------------------------

    def _fill_record(self, header, payload, old_dict):

        aaa = {}
        aaa[&#34;header&#34;] = header
        aaa[&#34;payload&#34;] = payload
        aaa[&#34;protocol&#34;] = ProtocolVersion

        dt = datetime.datetime.now()
        fdt = dt.strftime(&#39;%a, %d %b %Y %H:%M:%S&#39;)
        aaa[&#34;now&#34;] = fdt
        #self._key_n_data(aaa, &#34;hash32&#34;, str(self.hash32(payload)))

        sumstr = self._build_sumstr(aaa)
        aaa[&#34;hash256&#34;] = self._hashtohex(sumstr)

        backlink = self._build_backlink(old_dict)
        aaa[&#34;backlink&#34;] = self._hashtohex(backlink)

        return aaa

    def get_payload(self, recnum):

        &#39;&#39;&#39; Return the payload on record number &#39;&#39;&#39;

        arr = self.get_rec(recnum)
        if not arr:
            return []
        try:
            decoded = self.packer.decode_data(arr[1])
            #print(&#34;decoded&#34;, decoded)
        except:
            print(&#34;Cannot decode record at&#34;, recnum, recnum, sys.exc_info())
            raise
        dic = self._get_fields(decoded[0])

        if self.chain_verbose &gt; 2:
            print(dic)
        if self.chain_verbose &gt; 0:
            print(dic[&#39;header&#39;] + &#34; &#34; + dic[&#39;now&#39;], dic[&#39;payload&#39;])

        return arr[0].decode(), dic[&#39;payload&#39;]

    def get_payoffs_bykey(self, keyval, maxrec = 1):
        &#34; get payload offset by key&#34;
        arr = []
        rrr = self.getdbsize()
        for aa in range(rrr -1, -1, -1):
            head = self.get_header(aa)
            if head == keyval:
                arr.append(aa)
                if len(arr) &gt;= maxrec:
                    break
        return arr

    def get_data_bykey(self, keyval, maxrec = 1, check = True):

        &#39;&#39;&#39; Get data by key value. Searches the database from the back so lastly
            entered data is presented.

            Input:

                keyval    :    value to search for
                maxrec    :    maximum number of records
                check     :    check as found. Raises exception

            Returns:

                data array matching criteria.

        &#39;&#39;&#39;
        arr = []
        rrr = self.getdbsize()
        for aa in range(rrr -1, -1, -1):
            head = self.get_header(aa)
            if head == keyval:
                ch = self.checkdata(aa)
                li = self.linkintegrity(aa)

                if self.chain_verbose:
                    print(&#34;li&#34;, li, &#34;ch&#34;, ch)

                if not ch:
                    raise  DBCheckError(&#34;Check failed at rec %a&#34; % aa);
                if not li:
                    raise  DBLinkError(&#34;Link checl failed at rec %a&#34; % aa);

                pay = self.get_payload(aa)
                arr.append((head, pay))
                if len(arr) &gt;= maxrec:
                    break
        return arr

    def get_header(self, recnum):

        &#39;&#39;&#39; Get the header of record. &#39;&#39;&#39;

        if self.pgdebug &gt; 5:
            print(&#34;get_header()&#34;, recnum)
        arr = self.get_rec(recnum)
        if not arr:
            if self.pgdebug &gt; 5:
                print(&#34;get_header(): empty/deleted record&#34;, recnum)

            if self.chain_verbose &gt; 1:
                print(&#34;get_header(): empty/deleted record&#34;, recnum)
            return []

        if self.chain_verbose &gt; 1:
            print(&#34;arr&#34;, arr)
            uuu = uuid.UUID(arr[0].decode())
            ddd = str(uuid2date(uuu))
            print(&#34;header&#34;, arr[0])
        return arr[0].decode()

    def linkintegrity(self, recnum):

        &#39;&#39;&#39; Scan one record an its integrity based on the previous one &#39;&#39;&#39;

        if recnum &lt; 1:
            if self.chain_verbose:
                print(&#34;Cannot check initial record.&#34;)
            return True

        if self.chain_verbose &gt; 4:
            print(&#34;Checking link ...&#34;, recnum)

        arr = self.get_rec(recnum-1)
        try:
            decoded = self.packer.decode_data(arr[1])
        except:
            print(&#34;Cannot decode prev:&#34;, recnum, sys.exc_info())
            return
        dicold = self._get_fields(decoded[0])
        arr2 = self.get_rec(recnum)
        try:
            decoded2 = self.packer.decode_data(arr2[1])
        except:
            if self.chain_verbose &gt; 2:
                print(&#34;Cannot decode curr:&#34;, recnum, sys.exc_info())
            return
        dic = self._get_fields(decoded2[0])
        backlink = self._build_backlink(dicold)
        hhh = self._hashtohex(backlink)
        if self.chain_verbose &gt; 2:
            print(&#34;calc      &#34;, hhh)
            print(&#34;backlink  &#34;, dic[&#39;backlink&#39;])
        return hhh == dic[&#39;backlink&#39;]

    def checkdata(self, recnum):

        &#39;&#39;&#39; Integrity check of record. &#39;&#39;&#39;

        arr = self.get_rec(recnum)
        try:
            decoded = self.packer.decode_data(arr[1])
        except:
            if self.chain_verbose &gt; 2:
                print(&#34;Cannot decode:&#34;, recnum, sys.exc_info())
            return

        aaa = self._get_fields(decoded[0])
        sumstr = self._build_sumstr(aaa)
        hhh = self._hashtohex(sumstr)
        if self.chain_verbose &gt; 1:
            print(&#34;data&#34;, hhh)
        if self.chain_verbose &gt; 2:
            print(&#34;hash&#34;, aaa[&#39;hash256&#39;])
        return hhh == aaa[&#39;hash256&#39;]

    def appendwith(self, header, datax):

        &#39;&#39;&#39; Append data and header to the end of database &#39;&#39;&#39;

        #if type(header) != type(b&#34;&#34;):
        #    header = header.encode() #errors=&#39;strict&#39;)

        #if type(datax) != type(b&#34;&#34;):
        #    datax = datax.encode() #errors=&#39;strict&#39;)

        if self.chain_verbose &gt; 0:
            print(&#34;Appendwith&#34;, header, datax)

        self.ulock.waitlock()    #self.ulockname)

        try:
            uuu = uuid.UUID(header)
        except:
            if self.chain_verbose:
                print(&#34;Header override must be a valid UUID string.&#34;)

            self.ulock.unlock() #self.ulockname)
            raise ValueError(&#34;Header override must be a valid UUID string.&#34;)

        old_dicx = {}
        # Get last data from db
        sss = self.getdbsize()
        #print(&#34;sss&#34;, sss)

        # We fake an empty set ... checking against an empty set is a valid OP
        if not sss:
            #raise ValueError(&#34;Invalid database, must have at least one record.&#34;)
            ddd = self.packer.encode_data(&#34;&#34;, {&#34;blank&#34;: 0, })
            ooo = [0, ddd,]
        else:
            ooo = self.get_rec(sss-1)

        if self.pgdebug &gt; 5:
            print(&#34;decoding&#34;, ooo)

        decoded = self.packer.decode_data(ooo[1])
        old_dicx = self._get_fields(decoded[0])

        #print(&#34;old_fff&#34;, old_dicx[&#34;hash256&#34;])
        #print(&#34;old_time&#34;, old_dicx[&#34;now&#34;])

        aaa = self._fill_record(header, datax, old_dicx)
        encoded = self.packer.encode_data(&#34;&#34;, aaa)

        #print(&#34;save&#34;, header, &#34;-&#34;, encoded)
        #print(&#34;bbb&#34;, self.getdbsize())
        self.save_data(header, encoded)
        #print(&#34;eee&#34;, self.getdbsize())

        if self.chain_verbose &gt; 1:
            bbb = self.packer.decode_data(encoded)
            print(&#34;Rec&#34;, bbb[0])

        self.ulock.unlock() #self.ulockname)
        return True

    def append(self, datax):

        &#39;&#39;&#39; Append data to the end of database &#39;&#39;&#39;

        if self.chain_verbose &gt; 0:
            print(&#34;Append&#34;, datax)

        # Get last data from db
        #sss = self.getdbsize()
        #if not sss:
        #    #raise ValueError(&#34;Invalid database, must have at least one record.&#34;)
        #    pass

        # Produce header  structure
        uuu = uuid.uuid1()
        #print(&#34;uuid date&#34;,uuid2date(uuu))
        header = str(uuu)
        uuuu = uuid.UUID(header)
        #print(&#34;uuid date2&#34;, header, uuid2date(uuuu))
        ret = self.appendwith(header, datax)
        return ret

    def dump_rec(self, bbb):

        &#39;&#39;&#39; Dump one record to console &#39;&#39;&#39;

        for aa in range(len(bbb)//2):
            print(pad(bbb[2*aa]), &#34;=&#34;, bbb[2*aa+1])

    def _get_fields(self, bbb):
        if type(bbb) == type({}):
            dicx = bbb
        else:
            dicx = {}
            for aa in range(len(bbb)//2):
                dicx[bbb[2*aa]] = bbb[2*aa+1]
        return dicx</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>twincore.TwinCore</li>
<li>twinbase.TwinCoreBase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="twinchain.TwinChain.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, datax)</span>
</code></dt>
<dd>
<div class="desc"><p>Append data to the end of database</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, datax):

    &#39;&#39;&#39; Append data to the end of database &#39;&#39;&#39;

    if self.chain_verbose &gt; 0:
        print(&#34;Append&#34;, datax)

    # Get last data from db
    #sss = self.getdbsize()
    #if not sss:
    #    #raise ValueError(&#34;Invalid database, must have at least one record.&#34;)
    #    pass

    # Produce header  structure
    uuu = uuid.uuid1()
    #print(&#34;uuid date&#34;,uuid2date(uuu))
    header = str(uuu)
    uuuu = uuid.UUID(header)
    #print(&#34;uuid date2&#34;, header, uuid2date(uuuu))
    ret = self.appendwith(header, datax)
    return ret</code></pre>
</details>
</dd>
<dt id="twinchain.TwinChain.appendwith"><code class="name flex">
<span>def <span class="ident">appendwith</span></span>(<span>self, header, datax)</span>
</code></dt>
<dd>
<div class="desc"><p>Append data and header to the end of database</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def appendwith(self, header, datax):

    &#39;&#39;&#39; Append data and header to the end of database &#39;&#39;&#39;

    #if type(header) != type(b&#34;&#34;):
    #    header = header.encode() #errors=&#39;strict&#39;)

    #if type(datax) != type(b&#34;&#34;):
    #    datax = datax.encode() #errors=&#39;strict&#39;)

    if self.chain_verbose &gt; 0:
        print(&#34;Appendwith&#34;, header, datax)

    self.ulock.waitlock()    #self.ulockname)

    try:
        uuu = uuid.UUID(header)
    except:
        if self.chain_verbose:
            print(&#34;Header override must be a valid UUID string.&#34;)

        self.ulock.unlock() #self.ulockname)
        raise ValueError(&#34;Header override must be a valid UUID string.&#34;)

    old_dicx = {}
    # Get last data from db
    sss = self.getdbsize()
    #print(&#34;sss&#34;, sss)

    # We fake an empty set ... checking against an empty set is a valid OP
    if not sss:
        #raise ValueError(&#34;Invalid database, must have at least one record.&#34;)
        ddd = self.packer.encode_data(&#34;&#34;, {&#34;blank&#34;: 0, })
        ooo = [0, ddd,]
    else:
        ooo = self.get_rec(sss-1)

    if self.pgdebug &gt; 5:
        print(&#34;decoding&#34;, ooo)

    decoded = self.packer.decode_data(ooo[1])
    old_dicx = self._get_fields(decoded[0])

    #print(&#34;old_fff&#34;, old_dicx[&#34;hash256&#34;])
    #print(&#34;old_time&#34;, old_dicx[&#34;now&#34;])

    aaa = self._fill_record(header, datax, old_dicx)
    encoded = self.packer.encode_data(&#34;&#34;, aaa)

    #print(&#34;save&#34;, header, &#34;-&#34;, encoded)
    #print(&#34;bbb&#34;, self.getdbsize())
    self.save_data(header, encoded)
    #print(&#34;eee&#34;, self.getdbsize())

    if self.chain_verbose &gt; 1:
        bbb = self.packer.decode_data(encoded)
        print(&#34;Rec&#34;, bbb[0])

    self.ulock.unlock() #self.ulockname)
    return True</code></pre>
</details>
</dd>
<dt id="twinchain.TwinChain.checkdata"><code class="name flex">
<span>def <span class="ident">checkdata</span></span>(<span>self, recnum)</span>
</code></dt>
<dd>
<div class="desc"><p>Integrity check of record.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkdata(self, recnum):

    &#39;&#39;&#39; Integrity check of record. &#39;&#39;&#39;

    arr = self.get_rec(recnum)
    try:
        decoded = self.packer.decode_data(arr[1])
    except:
        if self.chain_verbose &gt; 2:
            print(&#34;Cannot decode:&#34;, recnum, sys.exc_info())
        return

    aaa = self._get_fields(decoded[0])
    sumstr = self._build_sumstr(aaa)
    hhh = self._hashtohex(sumstr)
    if self.chain_verbose &gt; 1:
        print(&#34;data&#34;, hhh)
    if self.chain_verbose &gt; 2:
        print(&#34;hash&#34;, aaa[&#39;hash256&#39;])
    return hhh == aaa[&#39;hash256&#39;]</code></pre>
</details>
</dd>
<dt id="twinchain.TwinChain.dump_rec"><code class="name flex">
<span>def <span class="ident">dump_rec</span></span>(<span>self, bbb)</span>
</code></dt>
<dd>
<div class="desc"><p>Dump one record to console</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump_rec(self, bbb):

    &#39;&#39;&#39; Dump one record to console &#39;&#39;&#39;

    for aa in range(len(bbb)//2):
        print(pad(bbb[2*aa]), &#34;=&#34;, bbb[2*aa+1])</code></pre>
</details>
</dd>
<dt id="twinchain.TwinChain.get_data_bykey"><code class="name flex">
<span>def <span class="ident">get_data_bykey</span></span>(<span>self, keyval, maxrec=1, check=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Get data by key value. Searches the database from the back so lastly
entered data is presented.</p>
<h2 id="input">Input</h2>
<p>keyval
:
value to search for
maxrec
:
maximum number of records
check
:
check as found. Raises exception</p>
<h2 id="returns">Returns</h2>
<p>data array matching criteria.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data_bykey(self, keyval, maxrec = 1, check = True):

    &#39;&#39;&#39; Get data by key value. Searches the database from the back so lastly
        entered data is presented.

        Input:

            keyval    :    value to search for
            maxrec    :    maximum number of records
            check     :    check as found. Raises exception

        Returns:

            data array matching criteria.

    &#39;&#39;&#39;
    arr = []
    rrr = self.getdbsize()
    for aa in range(rrr -1, -1, -1):
        head = self.get_header(aa)
        if head == keyval:
            ch = self.checkdata(aa)
            li = self.linkintegrity(aa)

            if self.chain_verbose:
                print(&#34;li&#34;, li, &#34;ch&#34;, ch)

            if not ch:
                raise  DBCheckError(&#34;Check failed at rec %a&#34; % aa);
            if not li:
                raise  DBLinkError(&#34;Link checl failed at rec %a&#34; % aa);

            pay = self.get_payload(aa)
            arr.append((head, pay))
            if len(arr) &gt;= maxrec:
                break
    return arr</code></pre>
</details>
</dd>
<dt id="twinchain.TwinChain.get_header"><code class="name flex">
<span>def <span class="ident">get_header</span></span>(<span>self, recnum)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the header of record.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_header(self, recnum):

    &#39;&#39;&#39; Get the header of record. &#39;&#39;&#39;

    if self.pgdebug &gt; 5:
        print(&#34;get_header()&#34;, recnum)
    arr = self.get_rec(recnum)
    if not arr:
        if self.pgdebug &gt; 5:
            print(&#34;get_header(): empty/deleted record&#34;, recnum)

        if self.chain_verbose &gt; 1:
            print(&#34;get_header(): empty/deleted record&#34;, recnum)
        return []

    if self.chain_verbose &gt; 1:
        print(&#34;arr&#34;, arr)
        uuu = uuid.UUID(arr[0].decode())
        ddd = str(uuid2date(uuu))
        print(&#34;header&#34;, arr[0])
    return arr[0].decode()</code></pre>
</details>
</dd>
<dt id="twinchain.TwinChain.get_payload"><code class="name flex">
<span>def <span class="ident">get_payload</span></span>(<span>self, recnum)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the payload on record number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payload(self, recnum):

    &#39;&#39;&#39; Return the payload on record number &#39;&#39;&#39;

    arr = self.get_rec(recnum)
    if not arr:
        return []
    try:
        decoded = self.packer.decode_data(arr[1])
        #print(&#34;decoded&#34;, decoded)
    except:
        print(&#34;Cannot decode record at&#34;, recnum, recnum, sys.exc_info())
        raise
    dic = self._get_fields(decoded[0])

    if self.chain_verbose &gt; 2:
        print(dic)
    if self.chain_verbose &gt; 0:
        print(dic[&#39;header&#39;] + &#34; &#34; + dic[&#39;now&#39;], dic[&#39;payload&#39;])

    return arr[0].decode(), dic[&#39;payload&#39;]</code></pre>
</details>
</dd>
<dt id="twinchain.TwinChain.get_payoffs_bykey"><code class="name flex">
<span>def <span class="ident">get_payoffs_bykey</span></span>(<span>self, keyval, maxrec=1)</span>
</code></dt>
<dd>
<div class="desc"><p>get payload offset by key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payoffs_bykey(self, keyval, maxrec = 1):
    &#34; get payload offset by key&#34;
    arr = []
    rrr = self.getdbsize()
    for aa in range(rrr -1, -1, -1):
        head = self.get_header(aa)
        if head == keyval:
            arr.append(aa)
            if len(arr) &gt;= maxrec:
                break
    return arr</code></pre>
</details>
</dd>
<dt id="twinchain.TwinChain.linkintegrity"><code class="name flex">
<span>def <span class="ident">linkintegrity</span></span>(<span>self, recnum)</span>
</code></dt>
<dd>
<div class="desc"><p>Scan one record an its integrity based on the previous one</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def linkintegrity(self, recnum):

    &#39;&#39;&#39; Scan one record an its integrity based on the previous one &#39;&#39;&#39;

    if recnum &lt; 1:
        if self.chain_verbose:
            print(&#34;Cannot check initial record.&#34;)
        return True

    if self.chain_verbose &gt; 4:
        print(&#34;Checking link ...&#34;, recnum)

    arr = self.get_rec(recnum-1)
    try:
        decoded = self.packer.decode_data(arr[1])
    except:
        print(&#34;Cannot decode prev:&#34;, recnum, sys.exc_info())
        return
    dicold = self._get_fields(decoded[0])
    arr2 = self.get_rec(recnum)
    try:
        decoded2 = self.packer.decode_data(arr2[1])
    except:
        if self.chain_verbose &gt; 2:
            print(&#34;Cannot decode curr:&#34;, recnum, sys.exc_info())
        return
    dic = self._get_fields(decoded2[0])
    backlink = self._build_backlink(dicold)
    hhh = self._hashtohex(backlink)
    if self.chain_verbose &gt; 2:
        print(&#34;calc      &#34;, hhh)
        print(&#34;backlink  &#34;, dic[&#39;backlink&#39;])
    return hhh == dic[&#39;backlink&#39;]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="twinchain.DBCheckError" href="#twinchain.DBCheckError">DBCheckError</a></code></h4>
</li>
<li>
<h4><code><a title="twinchain.DBLinkError" href="#twinchain.DBLinkError">DBLinkError</a></code></h4>
</li>
<li>
<h4><code><a title="twinchain.TwinChain" href="#twinchain.TwinChain">TwinChain</a></code></h4>
<ul class="two-column">
<li><code><a title="twinchain.TwinChain.append" href="#twinchain.TwinChain.append">append</a></code></li>
<li><code><a title="twinchain.TwinChain.appendwith" href="#twinchain.TwinChain.appendwith">appendwith</a></code></li>
<li><code><a title="twinchain.TwinChain.checkdata" href="#twinchain.TwinChain.checkdata">checkdata</a></code></li>
<li><code><a title="twinchain.TwinChain.dump_rec" href="#twinchain.TwinChain.dump_rec">dump_rec</a></code></li>
<li><code><a title="twinchain.TwinChain.get_data_bykey" href="#twinchain.TwinChain.get_data_bykey">get_data_bykey</a></code></li>
<li><code><a title="twinchain.TwinChain.get_header" href="#twinchain.TwinChain.get_header">get_header</a></code></li>
<li><code><a title="twinchain.TwinChain.get_payload" href="#twinchain.TwinChain.get_payload">get_payload</a></code></li>
<li><code><a title="twinchain.TwinChain.get_payoffs_bykey" href="#twinchain.TwinChain.get_payoffs_bykey">get_payoffs_bykey</a></code></li>
<li><code><a title="twinchain.TwinChain.linkintegrity" href="#twinchain.TwinChain.linkintegrity">linkintegrity</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>