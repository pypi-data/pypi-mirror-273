/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */
// Shims originally adapted from https://github.com/nteract/nteract/blob/47f8b038ff129543e42c39395129efc433eb4e90/scripts/test-shim.js
/* global globalThis */
globalThis.DragEvent = class DragEvent {
};
if (typeof globalThis.TextDecoder === 'undefined' ||
    typeof globalThis.TextEncoder === 'undefined') {
    const util = require('util');
    globalThis.TextDecoder = util.TextDecoder;
    globalThis.TextEncoder = util.TextEncoder;
}
globalThis.Image = window.Image;
globalThis.Range = function Range() {
    /* no-op */
};
// HACK: Polyfill that allows CodeMirror to render in a JSDOM env.
const createContextualFragment = (html) => {
    const div = document.createElement('div');
    div.innerHTML = html;
    return div.children[0]; // so hokey it's not even funny
};
globalThis.Range.prototype.createContextualFragment = (html) => createContextualFragment(html);
window.document.createRange = function createRange() {
    return {
        setEnd: () => {
            /* no-op */
        },
        setStart: () => {
            /* no-op */
        },
        getBoundingClientRect: () => ({ right: 0 }),
        getClientRects: () => [],
        createContextualFragment
    };
};
// end CodeMirror HACK
window.focus = () => {
    /* JSDom throws "Not Implemented" */
};
/**
 * Shim scrollTo because jsdom still does not implement a shim for it, see:
 * https://github.com/jsdom/jsdom/issues/2751
 */
window.Element.prototype.scrollTo = (_optionsOrX) => {
    // no-op
};
// https://github.com/jsdom/jsdom/issues/3368
class ResizeObserverMock {
    constructor(_callback) {
        // no-op
    }
    observe(_target, _options) {
        // no-op
    }
    unobserve(_target) {
        // no-op
    }
    disconnect() {
        // no-op
    }
}
window.ResizeObserver = ResizeObserverMock;
// https://github.com/jsdom/jsdom/issues/2913
class DataTransferItemMock {
    constructor(format, value) {
        this.format = format;
        this.value = value;
        // no-op
    }
    get kind() {
        return 'string';
    }
    get type() {
        return this.format;
    }
    getAsString(callback) {
        callback(this.value);
    }
    getAsFile() {
        return null;
    }
    webkitGetAsEntry() {
        return null;
    }
}
// https://github.com/jsdom/jsdom/issues/2913
class DataTransferMock {
    constructor() {
        this.dropEffect = 'none';
        this.effectAllowed = 'none';
        this.types = [];
        this._data = {};
    }
    get items() {
        return [
            ...Object.entries(this._data).map(([k, v]) => new DataTransferItemMock(k, v))
        ];
    }
    getData(format) {
        return this._data[format];
    }
    setData(format, data) {
        this._data[format] = data;
    }
    clearData() {
        this._data = {};
    }
    setDragImage(imgElement, xOffset, yOffset) {
        // no-op
    }
}
window.DataTransfer = DataTransferMock;
// https://github.com/jsdom/jsdom/issues/1568
class ClipboardEventMock extends Event {
    constructor(type, options) {
        super(type);
        this.clipboardData = options.clipboardData;
    }
}
window.ClipboardEvent = ClipboardEventMock;
window.document.elementFromPoint = (left, top) => document.body;
if (!window.hasOwnProperty('getSelection')) {
    // Minimal getSelection() that supports a fake selection
    window.getSelection = function getSelection() {
        return {
            _selection: '',
            selectAllChildren: () => {
                this._selection = 'foo';
            },
            toString: () => {
                const val = this._selection;
                this._selection = '';
                return val;
            }
        };
    };
}
// Used by xterm.js
window.matchMedia = function (media) {
    return {
        matches: false,
        media,
        onchange: () => {
            /* empty */
        },
        addEventListener: () => {
            /* empty */
        },
        removeEventListener: () => {
            /* empty */
        },
        dispatchEvent: () => {
            return true;
        },
        addListener: () => {
            /* empty */
        },
        removeListener: () => {
            /* empty */
        }
    };
};
process.on('unhandledRejection', (error, promise) => {
    console.error('Unhandled promise rejection somewhere in tests');
    if (error) {
        console.error(error);
        const stack = error.stack;
        if (stack) {
            console.error(stack);
        }
    }
    promise.catch(err => console.error('promise rejected', err));
});
if (window.requestIdleCallback === undefined) {
    // On Safari, requestIdleCallback is not available, so we use replacement functions for `idleCallbacks`
    // See: https://developer.mozilla.org/en-US/docs/Web/API/Background_Tasks_API#falling_back_to_settimeout
    // eslint-disable-next-line @typescript-eslint/ban-types
    window.requestIdleCallback = function (handler) {
        let startTime = Date.now();
        return setTimeout(function () {
            handler({
                didTimeout: false,
                timeRemaining: function () {
                    return Math.max(0, 50.0 - (Date.now() - startTime));
                }
            });
        }, 1);
    };
    window.cancelIdleCallback = function (id) {
        clearTimeout(id);
    };
}
//# sourceMappingURL=jest-shim.js.map