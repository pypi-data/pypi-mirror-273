import json
import subprocess
import re
import sys
import shutil
import os
from typing import List, Optional
import typing as t
from click.core import Context, Command


class ColdBoreCapitalDBT:

    def __init__(self, test_mode: bool = False):
        self.test_mode = test_mode
        self.dbt_ls_test_mode_output = None
        self.dbt_test_mode_command_check_value = None
        self.exclude_seed_snapshot = 'resource_type:snapshot resource_type:seed'

    def build(self, ctx: Context, full_refresh, select, fail_fast, threads):
        args = self._create_common_args(ctx, threads)

        if select:
            args.append('--select')
            args.append(select)
        if fail_fast:
            args.append('--fail-fast')
        if full_refresh:
            args.append('--full-refresh')
        try:
            run_result = self.execute_dbt_command('build', args)
        except subprocess.CalledProcessError as e:
            print(e)
            sys.exit(1)

        if not run_result:
            raise DbtError('DBT build failed with errors.')

    def trun(self, ctx: Context, full_refresh, select, fail_fast, threads):
        args = self._create_common_args(ctx, threads)
        args = args + ['--exclude', self.exclude_seed_snapshot]
        if select:
            args.append('--select')
            args.append(select)
        if fail_fast:
            args.append('--fail-fast')

        if full_refresh:
            args.append('--full-refresh')

        try:
            run_result = self.execute_dbt_command('build', args)
        except subprocess.CalledProcessError as e:
            print(e)
            print('dbt build ' + ' '.join(args))
            sys.exit(1)

        if not run_result:
            raise DbtError('DBT build failed with errors.')

    def run(self, ctx: Context, full_refresh, select, fail_fast, threads):
        args = self._create_common_args(ctx, threads)
        if select:
            args.append('--select')
            args.append(select)
        if fail_fast:
            args.append('--fail-fast')

        run_args = args
        if full_refresh:
            run_args.append('--full-refresh')
        try:
            run_result = self.execute_dbt_command('run', run_args)
        except subprocess.CalledProcessError as e:
            print(e)
            print('dbt run ' + ' '.join(args))
            sys.exit(1)

        if not run_result:
            raise DbtError('DBT build failed with errors.')

    def test(self, ctx: Context, select, fail_fast, threads):
        args = self._create_common_args(ctx, threads)
        if select:
            args.append('--select')
            args.append(select)
        if fail_fast:
            args.append('--fail-fast')
        run_args = args
        try:
            run_result = self.execute_dbt_command('test', run_args)
        except subprocess.CalledProcessError as e:
            print(e)
            print('dbt test ' + ' '.join(args))
            sys.exit(1)

        if not run_result:
            raise DbtError('DBT build failed with errors.')

    def compile(self, ctx: Context, threads):
        # We ignore the ctx object as compile has no threads.
        try:
            self.execute_dbt_command('compile', [])
        except subprocess.CalledProcessError as e:
            print(e)
            print('dbt compile')
            sys.exit(1)

    def sbuild(self, ctx: Context, full_refresh, threads):
        print('Starting a state build based on local manifest.json')
        artifact_dir = '_artifacts'
        target_dir = 'target'
        # Path to the artifacts file that will be generated by the dbt compile command representing the current state.
        manifest_path = os.path.join('./', target_dir, 'manifest.json')
        # Path to the artifact file that represents the prior build state.
        manifest_artifact_path = os.path.join('./', artifact_dir, 'manifest.json')

        self.execute_state_based_build(ctx, artifact_dir, manifest_artifact_path, manifest_path, full_refresh, threads,
                                       roll_back_manifest_flag=True)

    def pbuild(self, ctx: Context, full_refresh, threads):
        print('Starting a state build based on production manifest.json')
        artifact_dir = 'logs'
        target_dir = 'target'
        # Pull artifacts from Snowflake. These are the latest production artifacts.
        try:
            if not self.test_mode:
                subprocess.run(['dbt', 'run-operation', 'get_last_artifacts'], check=True)
        except subprocess.CalledProcessError as e:
            print(e)
            print('dbt run-operation get_last_artifacts')
            sys.exit(1)

        manifest_path = os.path.join('.', target_dir, 'manifest.json')
        manifest_artifact_path = os.path.join('.', artifact_dir, 'manifest.json')

        self.execute_state_based_build(ctx, artifact_dir, manifest_artifact_path, manifest_path, full_refresh, threads,
                                       roll_back_manifest_flag=False)

    def execute_state_based_build(self, ctx: Context, artifact_dir: str, manifest_artifact_path: str,
                                  manifest_path: str, full_refresh: bool, threads: int, roll_back_manifest_flag: bool):
        if roll_back_manifest_flag and not self.test_mode:
            print(f'Making a backup of the current manifest.json at {manifest_path} to {manifest_artifact_path}')
            # Move the manifest from ./target to ./_artifacts. This becomes the prior state. Only used for local state
            # build. Not used for pdbuild (production build).
            shutil.move(manifest_path, manifest_artifact_path)
        # Execute dbt compile
        try:
            if not self.test_mode:
                subprocess.run(['dbt', 'compile'], check=True)
        except subprocess.CalledProcessError:
            sys.exit(1)
        # Construct state commands
        build_children = ctx.obj.get('build_children', False)
        build_children_count = ctx.obj.get('build_children_count', None)
        build_parents = ctx.obj.get('build_parents', False)
        build_parent_count = ctx.obj.get('build_parents_count', None)
        state_modified_str = 'state:modified'
        if build_children:
            state_modified_str = f'{state_modified_str}+'
            if build_children_count:
                state_modified_str = f'{state_modified_str}{build_children_count}'
        if build_parents:
            state_modified_str = f'+{state_modified_str}'
            if build_parent_count:
                state_modified_str = f'{build_parent_count}{state_modified_str}'

        state_flags = [
            '--select', state_modified_str,
            '--state', os.path.join('.', artifact_dir) + '/'
        ]
        exclude_flags = ['--exclude', self.exclude_seed_snapshot]
        # Get a list of models and their config

        args = state_flags + exclude_flags
        args = args + ['--output-keys', 'name resource_type config', '--output', 'json']
        cmd = ['dbt', 'ls']
        cmd = cmd + args
        try:
            if self.test_mode:
                output = self.dbt_ls_test_mode_output
            else:
                output = subprocess.run(cmd, check=True, text=True, capture_output=True).stdout
        except subprocess.CalledProcessError as e:
            print(e)
            print(' '.join(cmd))
            sys.exit(1)

        # The results come back with a few header lines that need to be removed, then a series of JSON string with a format
        # like: {"name": "active_patient_metrics", "resource_type": "model", "config": {"materialized": "incremental"}}
        # RE removes the header stuff and finds the json lines.
        json_lines = re.findall(r'^{.*$', output, re.MULTILINE)

        # Split lines and filter to get only JSON strings
        models_json = [json.loads(line) for line in json_lines]

        if not full_refresh:
            full_refresh = self.test_full_refresh(models_json)

        run_result = None
        # Execute dbt build excluding snapshots and seeds
        # Rest the args.
        args = self._create_common_args(ctx, threads)
        args = args + state_flags + exclude_flags
        if full_refresh:
            args = args + ['--full-refresh']

        try:
            run_result = self.execute_dbt_command('build', args)
        except subprocess.CalledProcessError as e:
            print(e)
            if roll_back_manifest_flag and not self.test_mode:
                self.roll_back_manifest(e, manifest_artifact_path, manifest_path)
            else:
                print('dbt build ' + ' '.join(args))
                sys.exit(1)

        if not run_result:
            e = 'DBT build failed with errors.'
            self.roll_back_manifest(e, manifest_artifact_path, manifest_path)
            raise DbtError('DBT build failed with errors.')

    @staticmethod
    def _create_common_args(ctx: Context, threads: int = None) -> List[str]:
        args = []
        if threads:
            args.append('--threads')
            args.append(str(threads))
        return args

    @staticmethod
    def roll_back_manifest(e, manifest_artifact_path, manifest_path):
        print(f"DBT build failed. Rolling back manifest state with error\n {e}")
        # Move the manifest.json from _artifacts back to target dir. If the build failed, we want to rebuild against this
        # state, not the one generated by the compile command.
        shutil.move(manifest_artifact_path, manifest_path)
        sys.exit(1)

    @staticmethod
    def test_full_refresh(models_json):
        includes_incremental_build = False
        for model in models_json:
            if model['config']['materialized'] == 'incremental':
                includes_incremental_build = True
                print(f'Found incremental build model: {model["name"]}. Initiating full refresh.')
                break

        return includes_incremental_build

    def execute_dbt_command(self, command: str, args: List[str]):

        dbt_command = ['dbt', command] + args
        print(f'Running command: {" ".join(dbt_command)}')
        if self.test_mode:
            self.dbt_test_mode_command_check_value = dbt_command
            return True
        else:
            process = subprocess.Popen(
                dbt_command,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True  # Ensure outputs are in text mode rather than bytes
            )

            # Real-time output streaming
            while True:
                output = process.stdout.readline()
                if output == '' and process.poll() is not None:
                    break
                if output:
                    print(output.strip())  # Print each line of the output

            # Capture and print any remaining output after the loop
            stdout, stderr = process.communicate()
            if stdout:
                print(stdout.strip())

            # Check exit code
            if process.returncode != 0:
                print(f"Command resulted in an error: {stderr}")
                raise subprocess.CalledProcessError(returncode=process.returncode, cmd=dbt_command, output=stderr)

            # Check for errors using a regex method if necessary
            if self.contains_errors(stdout + stderr):
                return False
            return True

    @staticmethod
    def contains_errors(text):
        pattern = r"([2-9]|\d{2,})\s+errors?"
        error_flag = bool(re.search(pattern, text))
        return error_flag


class DbtError(Exception):
    def __init__(self, message):
        self.message = 'DBT build failed with errors.'

    def __str__(self):
        return self.message


class MockCtx(Context):
    def __init__(self,
                 command: t.Optional["Command"] = None,
                 ) -> None:
        self.obj = {
            'build_children': False,
            'build_children_count': None,
            'parents_children': False,
            'build_parent_count': None
        }


if __name__ == '__main__':
    cdbt = ColdBoreCapitalDBT()
    # cdbt.build(full_refresh=False, select=None, fail_fast=False)
    # cdbt.trun(full_refresh=False, select=None, fail_fast=False)
    # cdbt.run(full_refresh=False, select=None, fail_fast=False)
    # cdbt.test(select=None, fail_fast=False)
    # cdbt.compile()
    # cdbt.sbuild(ctx=None, full_refresh=False)
    cdbt.pbuild(ctx=MockCtx(Command('Duck')), full_refresh=False)
    sys.exit(0)
