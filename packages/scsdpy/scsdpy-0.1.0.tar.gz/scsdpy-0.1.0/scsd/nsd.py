#Porphyrin tools - the set of functions which allow for generation of the Normal-coordinate Structural Decomposition matrix and
#associated bond distances, angles, etc, an indispensible tool for the structural analysis of porphyrin materials.
#written by Dr. Christopher J. Kingsbury, Trinity College Dublin
#ckingsbu@tcd.ie
#
# This work is licensed under THE ANTI-CAPITALIST SOFTWARE LICENSE (v 1.4) 
# To view a copy of this license, visit https://directory.fsf.org/wiki/License:ANTI-1.4

import base64
import os.path
# imports - matplotlib for plotting the skeletal images
# numpy for general number handling
# os reads files from disk
# from os import getcwd
import random
from math import  floor, exp, ceil #log10,

from io import BytesIO
import base64
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
from matplotlib.patches import ArrowStyle
from matplotlib.colors import ListedColormap

from numpy import array, matrix, hstack, vstack, dot, zeros, sort, meshgrid, mean, argmin, log10, unique, shape
from numpy import sum as npsum, abs as npabs, round as npround, mean, min as npmin, max as npmax, float32 as npfloat
from numpy import sin, cos, arccos, arctan, arctan2, prod, product,multiply, sign, subtract,square, sqrt,degrees,std
from numpy.linalg import norm, lstsq

from scipy.optimize import minimize, leastsq, linear_sum_assignment
from scipy.spatial.transform import Rotation as R
from scipy.stats import pearsonr, spearmanr, kendalltau

import pandas as pd

from flask import Flask,render_template, request, url_for

dirpath = os.path.abspath(os.path.dirname(__file__))

#This is the replica of NSDGUI - or at least the matrix stuff behind it. basis sets were obtained from Jentzen's paper
# as were the multiplicative matrices.
# linalg.lstsq runs on only the first column of each matrix - this is the minimum basis set
# can be modified to run on the extended data set
# This is V2, which works in a much more sensible way. Values are essentially immutable,
# but can be regenerated by other code, available on request
#the x,y,z coordinates for generation of databases were obtained from Mercury (CCDC) and the
# CSDmaterials - similarity search algorithm (chemical) and from the export function of the Protein Data Bank (PDB)
#Plan to replicate in CSD Python API.

nb_b2u = matrix([[0.13997, 0.320469, 0.320469, 0.13997, 0.0, -0.13997, -0.320469, -0.320469, -0.13997, 0.0, 0.13997, 0.320469, 0.320469, 0.13997, 0.0, -0.13997, -0.320469, -0.320469, -0.13997, 0.0, 0.073594,  -0.073594, 0.073594, -0.073594],
	[0.176231, -0.12957, -0.12957, 0.176231, 0.0, -0.176231, 0.12957, 0.12957, -0.176231, 0.0,  0.176231, -0.12957, -0.12957, 0.176231, 0.0, -0.176231, 0.12957, 0.12957, -0.176231, 0.0,  0.392821, -0.392821, 0.392821, -0.392821],
	[-0.284657, 0.088308, 0.088308, -0.284657, 0.0, 0.284657, -0.088308, -0.088308, 0.284657, 0.0, -0.284657, 0.088308, 0.088308, -0.284657, 0.0, 0.284657, -0.088308, -0.088308, 0.284657, 0.0,  0.268968, -0.268968, 0.268968, -0.268968]]).transpose()
nb_b1u = matrix([[-0.208239, -0.138509, 0.138509, 0.208239, 0.353418, 0.208239, 0.138509, -0.138509, -0.208239, -0.353418, -0.208239, -0.138509, 0.138509, 0.208239, 0.353418, 0.208239, 0.138509, -0.138509, -0.208239, -0.353418, 0.0, 0.0, 0.0, 0.0],
	[0.05526, 0.283868, -0.283868, -0.05526, 0.287628, -0.05526, -0.283868, 0.283868, 0.05526, -0.287628, 0.05526, 0.283868, -0.283868, -0.05526, 0.287628, -0.05526, -0.283868, 0.283868, 0.05526, -0.287628, 0.0, 0.0, 0.0, 0.0],
	[0.280329, -0.158849, 0.158849, -0.280329, 0.205829, -0.280329, 0.158849, -0.158849, 0.280329, -0.205829, 0.280329, -0.158849, 0.158849, -0.280329, 0.205829, -0.280329, 0.158849, -0.158849, 0.280329, -0.205829, 0.0, 0.0, 0.0, 0.0]]).transpose()
nb_a2u = matrix([[0.089421, -0.256764, -0.256764, 0.089421, 0.015446, 0.089421, -0.256764, -0.256764, 0.089421, 0.015446, 0.089421, -0.256764, -0.256764, 0.089421, 0.015446, 0.089421, -0.256764, -0.256764, 0.089421, 0.015446, 0.31924, 0.31924, 0.31924, 0.31924],
	[-0.026474, 0.129163, 0.129163, -0.026474, -0.414251, -0.026474, 0.129163, 0.129163, -0.026474, -0.414251, -0.026474, 0.129163, 0.129163, -0.026474, -0.414251, -0.026474, 0.129163, 0.129163, -0.026474, -0.414251, 0.208873, 0.208873, 0.208873, 0.208873],
	[-0.276428, 0.066317, 0.066317, -0.276428, 0.203582, -0.276428, 0.066317, 0.066317, -0.276428, 0.203582, -0.276428, 0.066317, 0.066317, -0.276428, 0.203582, -0.276428, 0.066317, 0.066317, -0.276428, 0.203582, 0.216642, 0.216642, 0.216642, 0.216642]]).transpose()
nb_egx = matrix([[0.091793, -0.321091, -0.321091, 0.091793, 0.222472, 0.200466, 0.142778, -0.142778, -0.200466, -0.222472, -0.091793, 0.321091, 0.321091, -0.091793, -0.222472, -0.200466, -0.142778, 0.142778, 0.200466, 0.222472, 0.238363, 0.0, -0.238363, 0.0],
	[0.188697, -0.059908, -0.059908, 0.188697, -0.17926, -0.194656, -0.166003, 0.166003, 0.194656, 0.17926, -0.188697, 0.059908, 0.059908, -0.188697, 0.17926, 0.194656, 0.166003, -0.166003, -0.194656, -0.17926, 0.475862, -0.0, -0.475862, -0.0],
	[-0.0646, 0.085263, 0.085263, -0.0646, -0.303576, 0.149899, 0.330986, -0.330986, -0.149899, 0.303576, 0.0646, -0.085263, -0.085263, 0.0646, 0.303576, -0.149899, -0.330986, 0.330986, 0.149899, -0.303576, 0.169573, -0.0, -0.169573, -0.0],
	[-0.153961, 0.061081, 0.061081, -0.153961, -0.058147, 0.345711, -0.298751, 0.298751, -0.345711, 0.058147, 0.153961, -0.061081, -0.061081, 0.153961, 0.058147, -0.345711, 0.298751, -0.298751, 0.345711, -0.058147, 0.144332, -0.0, -0.144332, -0.0],
	[-0.357004, 0.089594, 0.089594, -0.357004, 0.190206, -0.163121, 0.063411, -0.063411, 0.163121, -0.190206, 0.357004, -0.089594, -0.089594, 0.357004, -0.190206, 0.163121, -0.063411, 0.063411, -0.163121, 0.190206, 0.308912, -0.0, -0.308912, -0.0]]).transpose()
nb_egy = matrix([[-0.200466, -0.142778, 0.142778, 0.200466, 0.222472, 0.091793, -0.321091, -0.321091, 0.091793, 0.222472, 0.200466, 0.142778, -0.142778, -0.200466, -0.222472, -0.091793, 0.321091, 0.321091, -0.091793, -0.222472, 0.0, 0.238363, 0.0, -0.238363],
	[0.194656, 0.166003, -0.166003, -0.194656, -0.17926, 0.188697, -0.059908, -0.059908, 0.188697, -0.17926, -0.194656, -0.166003, 0.166003, 0.194656, 0.17926, -0.188697, 0.059908, 0.059908, -0.188697, 0.17926, -0.0, 0.475862, -0.0, -0.475862],
	[-0.149899, -0.330986, 0.330986, 0.149899, -0.303576, -0.0646, 0.085263, 0.085263, -0.0646, -0.303576, 0.149899, 0.330986, -0.330986, -0.149899, 0.303576, 0.0646, -0.085263, -0.085263, 0.0646, 0.303576, -0.0, 0.169573, -0.0, -0.169573],
	[-0.345711, 0.298751, -0.298751, 0.345711, -0.058147, -0.153961, 0.061081, 0.061081, -0.153961, -0.058147, 0.345711, -0.298751, 0.298751, -0.345711, 0.058147, 0.153961, -0.061081, -0.061081, 0.153961, 0.058147, -0.0, 0.144332, -0.0, -0.144332],
	[0.163121, -0.063411, 0.063411, -0.163121, 0.190206, -0.357004, 0.089594, 0.089594, -0.357004, 0.190206, -0.163121, 0.063411, -0.063411, 0.163121, -0.190206, 0.357004, -0.089594, -0.089594, 0.357004, -0.190206, -0.0, 0.308912, -0.0, -0.308912]]).transpose()
nb_a1u = matrix([[0.244613, 0.255273, -0.255273, -0.244613, 0.0, 0.244613, 0.255273, -0.255273, -0.244613, 0.0, 0.244613, 0.255273, -0.255273, -0.244613, 0.0, 0.244613, 0.255273, -0.255273, -0.244613, 0.0, 0.0, 0.0, 0.0, 0.0],
	[0.255273, -0.244613, 0.244613, -0.255273, 0.0, 0.255273, -0.244613, 0.244613, -0.255273, 0.0, 0.255273, -0.244613, 0.244613, -0.255273, 0.0, 0.255273, -0.244613, 0.244613, -0.255273, 0.0, 0.0, 0.0, 0.0, 0.0]]).transpose()
oopbases = [nb_b2u, nb_b1u, nb_a2u, nb_egx, nb_egy, nb_a1u]
oop_comp_base_num = [[0,3],[3,6],[6,9],[9,14],[14,19],[19,21]]

nb_b2g = [[0.180958, -0.114829, 0.062829, -0.073186, 0.062829, 0.073186, 0.180958, 0.114829, 0.201078, 0.201078, 0.114829, 0.180958, 0.073186, 0.062829, -0.073186, 0.062829, -0.114829, 0.180958, -0.201078, 0.201078, -0.180958, 0.114829, -0.062829, 0.073186, -0.062829, -0.073186, -0.180958, -0.114829, -0.201078, -0.201078, -0.114829, -0.180958, -0.073186, -0.062829, 0.073186, -0.062829, 0.114829, -0.180958, 0.201078, -0.201078, 0.242208, -0.0, -0.0, 0.242208, -0.242208, -0.0, -0.0, -0.242208],
	[-0.035761, -0.091143, -0.328661, -0.076605, -0.328661, 0.076605, -0.035761, 0.091143, 0.025615, 0.025615, 0.091143, -0.035761, 0.076605, -0.328661, -0.076605, -0.328661, -0.091143, -0.035761, -0.025615, 0.025615, 0.035761, 0.091143, 0.328661, 0.076605, 0.328661, -0.076605, 0.035761, -0.091143, -0.025615, -0.025615, -0.091143, 0.035761, -0.076605, 0.328661, 0.076605, 0.328661, 0.091143, 0.035761, 0.025615, -0.025615, 0.041751, -0.0, -0.0, 0.041751, -0.041751, -0.0, -0.0, -0.041751],
	[0.055255, 0.167267, -0.096708, 0.247136, -0.096708, -0.247136, 0.055255, -0.167267, 0.152858, 0.152858, -0.167267, 0.055255, -0.247136, -0.096708, 0.247136, -0.096708, 0.167267, 0.055255, -0.152858, 0.152858, -0.055255, -0.167267, 0.096708, -0.247136, 0.096708, 0.247136, -0.055255, 0.167267, -0.152858, -0.152858, 0.167267, -0.055255, 0.247136, 0.096708, -0.247136, 0.096708, -0.167267, -0.055255, 0.152858, -0.152858, 0.018671, -0.0, -0.0, 0.018671, -0.018671, -0.0, -0.0, -0.018671],
	[0.037155, 0.028774, -0.02385, 0.087645, -0.02385, -0.087645, 0.037155, -0.028774, -0.226991, -0.226991, -0.028774, 0.037155, -0.087645, -0.02385, 0.087645, -0.02385, 0.028774, 0.037155, 0.226991, -0.226991, -0.037155, -0.028774, 0.02385, -0.087645, 0.02385, 0.087645, -0.037155, 0.028774, 0.226991, 0.226991, 0.028774, -0.037155, 0.087645, 0.02385, -0.087645, 0.02385, -0.028774, -0.037155, -0.226991, 0.226991, 0.355011, -0.0, -0.0, 0.355011, -0.355011, -0.0, -0.0, -0.355011],
	[-0.12849, -0.25599, 0.04045, 0.20159, 0.04045, -0.20159, -0.12849, 0.25599, 0.0258, 0.0258, 0.25599, -0.12849, -0.20159, 0.04045, 0.20159, 0.04045, -0.25599, -0.12849, -0.0258, 0.0258, 0.12849, 0.25599, -0.04045, -0.20159, -0.04045, 0.20159, 0.12849, -0.25599, -0.0258, -0.0258, -0.25599, 0.12849, 0.20159, -0.04045, -0.20159, -0.04045, 0.25599, 0.12849, 0.0258, -0.0258, 0.006241, -0.0, -0.0, 0.006241, -0.006241, -0.0, -0.0, -0.006241],
	[-0.27073, 0.10004, 0.042958, -0.073036, 0.042958, 0.073036, -0.27073, -0.10004, 0.11931, 0.11931, -0.10004, -0.27073, 0.073036, 0.042958, -0.073036, 0.042958, 0.10004, -0.27073, -0.11931, 0.11931, 0.27073, -0.10004, -0.042958, 0.073036, -0.042958, -0.073036, 0.27073, 0.10004, -0.11931, -0.11931, 0.10004, 0.27073, -0.073036, -0.042958, 0.073036, -0.042958, -0.10004, 0.27073, 0.11931, -0.11931, 0.20141, -0.0, -0.0, 0.20141, -0.20141, -0.0, -0.0, -0.20141]]
nb_b1g = [[-0.023567, -0.208329, 0.001194, -0.237409, -0.001194, -0.237409, 0.023567, -0.208329, 0.077676, -0.077676, 0.208329, -0.023567, 0.237409, 0.001194, 0.237409, -0.001194, 0.208329, 0.023567, 0.077676, 0.077676, 0.023567, 0.208329, -0.001194, 0.237409, 0.001194, 0.237409, -0.023567, 0.208329, -0.077676, 0.077676, -0.208329, 0.023567, -0.237409, -0.001194, -0.237409, 0.001194, -0.208329, -0.023567, -0.077676, -0.077676, 0.0, -0.193109, 0.193109, 0.0, 0.0, 0.193109, -0.193109, 0.0],
	[0.224002, -0.019963, 0.057892, -0.014825, -0.057892, -0.014825, -0.224002, -0.019963, -0.245022, 0.245022, 0.019963, 0.224002, 0.014825, 0.057892, 0.014825, -0.057892, 0.019963, -0.224002, -0.245022, -0.245022, -0.224002, 0.019963, -0.057892, 0.014825, 0.057892, 0.014825, 0.224002, 0.019963, 0.245022, -0.245022, -0.019963, -0.224002, -0.014825, -0.057892, -0.014825, 0.057892, -0.019963, 0.224002, 0.245022, 0.245022, 0.0, -0.147091, 0.147091, 0.0, 0.0, 0.147091, -0.147091, 0.0],
	[-0.017364, -0.078018, -0.023778, 0.247151, 0.023778, 0.247151, 0.017364, -0.078018, 0.081045, -0.081045, 0.078018, -0.017364, -0.247151, -0.023778, -0.247151, 0.023778, 0.078018, 0.017364, 0.081045, 0.081045, 0.017364, 0.078018, 0.023778, -0.247151, -0.023778, -0.247151, -0.017364, 0.078018, -0.081045, 0.081045, -0.078018, 0.017364, 0.247151, 0.023778, 0.247151, -0.023778, -0.078018, -0.017364, -0.081045, -0.081045, -0.0, -0.317472, 0.317472, -0.0, -0.0, 0.317472, -0.317472, -0.0],
	[-0.09148, 0.21262, 0.21367, -0.074807, -0.21367, -0.074807, 0.09148, 0.21262, 0.023399, -0.023399, -0.21262, -0.09148, 0.074807, 0.21367, 0.074807, -0.21367, -0.21262, 0.09148, 0.023399, 0.023399, 0.09148, -0.21262, -0.21367, 0.074807, 0.21367, 0.074807, -0.09148, -0.21262, -0.023399, 0.023399, 0.21262, 0.09148, -0.074807, -0.21367, -0.074807, 0.21367, 0.21262, -0.09148, -0.023399, -0.023399, -0.0, -0.19812, 0.19812, -0.0, -0.0, 0.19812, -0.19812, -0.0],
	[-0.124551, 0.115461, -0.254912, -0.063452, 0.254912, -0.063452, 0.124551, 0.115461, -0.128791, 0.128791, -0.115461, -0.124551, 0.063452, -0.254912, 0.063452, 0.254912, -0.115461, 0.124551, -0.128791, -0.128791, 0.124551, -0.115461, 0.254912, 0.063452, -0.254912, 0.063452, -0.124551, -0.115461, 0.128791, -0.128791, 0.115461, 0.124551, -0.063452, 0.254912, -0.063452, -0.254912, 0.115461, -0.124551, 0.128791, 0.128791, 0.0, -0.145341, 0.145341, 0.0, 0.0, 0.145341, -0.145341, 0.0],
	[0.226637, 0.139228, -0.112329, -0.055827, 0.112329, -0.055827, -0.226637, 0.139228, 0.192238, -0.192238, -0.139228, 0.226637, 0.055827, -0.112329, 0.055827, 0.112329, -0.139228, -0.226637, 0.192238, 0.192238, -0.226637, -0.139228, 0.112329, 0.055827, -0.112329, 0.055827, 0.226637, -0.139228, -0.192238, 0.192238, 0.139228, -0.226637, -0.055827, 0.112329, -0.055827, -0.112329, 0.139228, 0.226637, -0.192238, -0.192238, -0.0, -0.055878, 0.055878, -0.0, -0.0, 0.055878, -0.055878, -0.0]]
nb_eux = [[0.10224, 0.077914, 0.344167, 0.060891, 0.344167, -0.060891, 0.10224, -0.077914, 0.035076, -0.081925, -0.172156, -0.068549, -0.206736, -0.019998, -0.206736, 0.019998, -0.172156, 0.068549, 0.035076, 0.081925, 0.10224, 0.077914, 0.344167, 0.060891, 0.344167, -0.060891, 0.10224, -0.077914, 0.035076, -0.081925, -0.172156, -0.068549, -0.206736, -0.019998, -0.206736, 0.019998, -0.172156, 0.068549, 0.035076, 0.081925, 0.021404, -0.0, -0.226586, 0.0, 0.021404, -0.0, -0.226586, 0.0],
	[0.155696, -0.216515, -0.128747, -0.159216, -0.128747, 0.159216, 0.155696, 0.216515, 0.135877, 0.170816, -0.100897, 0.060248, -0.154426, -0.001075, -0.154426, 0.001075, -0.100897, -0.060248, 0.135877, -0.170816, 0.155696, -0.216515, -0.128747, -0.159216, -0.128747, 0.159216, 0.155696, 0.216515, 0.135877, 0.170816, -0.100897, 0.060248, -0.154426, -0.001075, -0.154426, 0.001075, -0.100897, -0.060248, 0.135877, -0.170816, 0.300102, -0.0, -0.115107, 0.0, 0.300102, -0.0, -0.115107, 0.0],
	[0.103108, 0.0506, -0.214721, 0.022606, -0.214721, -0.022606, 0.103108, -0.0506, 0.065171, -0.317741, -0.014581, -0.243211, 0.046099, -0.049714, 0.046099, 0.049714, -0.014581, 0.243211, 0.065171, 0.317741, 0.103108, 0.0506, -0.214721, 0.022606, -0.214721, -0.022606, 0.103108, -0.0506, 0.065171, -0.317741, -0.014581, -0.243211, 0.046099, -0.049714, 0.046099, 0.049714, -0.014581, 0.243211, 0.065171, 0.317741, 0.159148, -0.0, -0.12931, -0.0, 0.159148, -0.0, -0.12931, -0.0],
	[-0.05213, -0.231435, 0.154068, -0.286694, 0.154068, 0.286694, -0.05211, 0.231435, -0.220664, -0.132272, -0.014687, -0.080668, 0.119329, 0.001925, 0.119329, -0.001925, -0.014687, 0.080668, -0.220664, 0.132272, -0.05213, -0.231435, 0.154068, -0.286694, 0.154068, 0.286694, -0.05211, 0.231435, -0.220664, -0.132272, -0.014687, -0.080668, 0.119329, 0.001925, 0.119329, -0.001925, -0.014687, 0.080668, -0.220664, 0.132272, 0.035011, -0.0, -0.006862, -0.0, 0.035011, -0.0, -0.006862, -0.0],
	[-0.01668, -0.001281, -0.001075, 0.000885, -0.001075, -0.000885, -0.01668, 0.001281, 0.087306, 0.130415, -0.0586, 0.005566, 0.303269, 0.006311, 0.303269, -0.006311, -0.0586, -0.005566, 0.087306, -0.130415, -0.01668, -0.001281, -0.001075, 0.000885, -0.001075, -0.000885, -0.01668, 0.001281, 0.087306, 0.130415, -0.0586, 0.005566, 0.303269, 0.006311, 0.303269, -0.006311, -0.0586, -0.005566, 0.087306, -0.130415, -0.1385, -0.0, -0.489939, 0.0, -0.1385, -0.0, -0.489939, 0.0],
	[-0.001547, 0.032033, 0.014547, 0.225569, 0.014569, -0.225573, -0.001547, -0.032037, -0.264113, 0.039913, -0.059876, 0.088136, 0.114619, 0.058148, 0.114619, -0.058153, -0.059876, -0.088141, -0.264113, -0.039913, -0.001547, 0.032033, 0.014547, 0.225569, 0.014569, -0.225573, -0.001547, -0.032037, -0.264113, 0.039913, -0.059876, 0.088136, 0.114619, 0.058148, 0.114619, -0.058153, -0.059876, -0.088141, -0.264113, -0.039913, 0.441511, -2e-06, -0.048796, 2.6e-05, 0.441511, -2e-06, -0.048796, 2.6e-05],
	[-0.116438, -0.171449, 0.040009, 0.161019, 0.040019, -0.161019, -0.116438, 0.171449, 0.000331, 0.121429, 0.092511, -0.188548, -0.029835, -0.345137, -0.029835, 0.345137, 0.092511, 0.188548, 0.000331, -0.121429, -0.116438, -0.171449, 0.040009, 0.161019, 0.040019, -0.161019, -0.116438, 0.171449, 0.000331, 0.121429, 0.092511, -0.188548, -0.029835, -0.345137, -0.029835, 0.345137, 0.092511, 0.188548, 0.000331, -0.121429, 0.035224, -0.0, -0.008391, -0.0, 0.035224, -0.0, -0.008391, -0.0],
	[-0.040885, 0.206352, -0.003009, -0.179491, -0.003009, 0.179491, -0.040885, -0.206352, -0.07098, -0.026929, 0.264392, 0.150091, -0.099428, -0.173811, -0.099428, 0.173811, 0.264392, -0.150091, -0.07098, 0.026929, -0.040885, 0.206352, -0.003009, -0.179491, -0.003009, 0.179491, -0.040885, -0.206352, -0.07098, -0.026929, 0.264392, 0.150091, -0.099428, -0.173811, -0.099428, 0.173811, 0.264392, -0.150091, -0.07098, 0.026929, 0.130801, -0.0, -0.230982, 0.0, 0.130801, -0.0, -0.230982, 0.0],
	[-0.007504, -0.255098, 0.005248, 0.176989, 0.005248, -0.176989, -0.007504, 0.255098, 0.013901, -0.149019, 0.235688, 0.114329, -0.10799, 0.167939, -0.10799, -0.167939, 0.235688, -0.114329, 0.013901, 0.149019, -0.007504, -0.255098, 0.005248, 0.176989, 0.005248, -0.176989, -0.007504, 0.255098, 0.013901, -0.149019, 0.235688, 0.114329, -0.10799, 0.167939, -0.10799, -0.167939, 0.235688, -0.114329, 0.013901, 0.149019, -0.082644, -0.0, -0.19604, 0.0, -0.082644, -0.0, -0.19604, 0.0],
	[-0.301162, 0.062022, 0.051915, -0.055319, 0.051925, 0.055321, -0.301162, -0.06202, 0.130869, 0.079644, 0.079464, -0.20377, -0.05016, 0.229262, -0.05016, -0.22926, 0.079464, 0.203762, 0.130869, -0.079644, -0.301162, 0.062022, 0.051915, -0.055319, 0.051925, 0.055321, -0.301162, -0.06202, 0.130869, 0.079644, 0.079464, -0.20377, -0.05016, 0.229262, -0.05016, -0.22926, 0.079464, 0.203762, 0.130869, -0.079644, 0.2131, 1e-06, -0.034962, 1e-06, 0.2131, 1e-06, -0.034962, 1e-06],
	[0.236456, 0.052684, -0.034134, -0.01094, -0.034134, 0.01094, 0.236456, -0.052684, -0.202828, 0.193867, 0.153987, -0.242306, -0.065412, 0.126068, -0.065412, -0.126068, 0.153987, 0.242306, -0.202828, -0.193867, 0.236456, 0.052684, -0.034134, -0.01094, -0.034134, 0.01094, 0.236456, -0.052684, -0.202828, 0.193867, 0.153987, -0.242306, -0.065412, 0.126068, -0.065412, -0.126068, 0.153987, 0.242306, -0.202828, -0.193867, -0.118929, -0.0, -0.05721, -0.0, -0.118929, -0.0, -0.05721, -0.0]]
nb_euy = [[-0.068549, 0.172156, -0.019998, 0.206736, 0.019998, 0.206736, 0.068549, 0.172156, 0.081925, -0.035076, 0.077914, -0.10224, 0.060891, -0.344167, -0.060891, -0.344167, -0.077914, -0.10224, -0.081925, -0.035076, -0.068549, 0.172156, -0.019998, 0.206736, 0.019998, 0.206736, 0.068549, 0.172156, 0.081925, -0.035076, 0.077914, -0.10224, 0.060891, -0.344167, -0.060891, -0.344167, -0.077914, -0.10224, -0.081925, -0.035076, 0.0, 0.226586, -0.0, -0.021404, 0.0, 0.226586, -0.0, -0.021404],
	[0.060248, 0.100897, -0.001075, 0.154426, 0.001075, 0.154426, -0.060248, 0.100897, -0.170816, -0.135877, -0.216515, -0.155696, -0.159216, 0.128747, 0.159216, 0.128747, 0.216515, -0.155696, 0.170816, -0.135877, 0.060248, 0.100897, -0.001075, 0.154426, 0.001075, 0.154426, -0.060248, 0.100897, -0.170816, -0.135877, -0.216515, -0.155696, -0.159216, 0.128747, 0.159216, 0.128747, 0.216515, -0.155696, 0.170816, -0.135877, 0.0, 0.115107, -0.0, -0.300102, 0.0, 0.115107, -0.0, -0.300102],
	[-0.243211, 0.014581, -0.049714, -0.046099, 0.049714, -0.046099, 0.243211, 0.014581, 0.31774, -0.065179, 0.0506, -0.103108, 0.022606, 0.214721, -0.022606, 0.214721, -0.0506, -0.103108, -0.31774, -0.065179, -0.243211, 0.014581, -0.049714, -0.046099, 0.049714, -0.046099, 0.243211, 0.014581, 0.31774, -0.065179, 0.0506, -0.103108, 0.022606, 0.214721, -0.022606, 0.214721, -0.0506, -0.103108, -0.31774, -0.065179, -0.0, 0.12931, -0.0, -0.159148, -0.0, 0.12931, -0.0, -0.159148],
	[-0.080668, 0.014687, 0.001925, -0.119329, -0.001925, -0.119329, 0.080668, 0.014687, 0.132272, 0.220664, -0.231435, 0.05213, -0.286694, -0.154068, 0.286694, -0.154068, 0.231435, 0.05211, -0.132272, 0.220664, -0.080668, 0.014687, 0.001925, -0.119329, -0.001925, -0.119329, 0.080668, 0.014687, 0.132272, 0.220664, -0.231435, 0.05213, -0.286694, -0.154068, 0.286694, -0.154068, 0.231435, 0.05211, -0.132272, 0.220664, -0.0, 0.006862, -0.0, -0.035011, -0.0, 0.006862, -0.0, -0.035011],
	[0.005566, 0.0586, 0.006311, -0.303269, -0.006311, -0.303269, -0.005566, 0.0586, -0.130415, -0.087306, -0.001281, 0.01668, 0.000885, 0.001075, -0.000885, 0.001075, 0.001281, 0.01668, 0.130415, -0.087306, 0.005566, 0.0586, 0.006311, -0.303269, -0.006311, -0.303269, -0.005566, 0.0586, -0.130415, -0.087306, -0.001281, 0.01668, 0.000885, 0.001075, -0.000885, 0.001075, 0.001281, 0.01668, 0.130415, -0.087306, 0.0, 0.489939, -0.0, 0.1385, 0.0, 0.489939, -0.0, 0.1385],
	[0.088136, 0.059876, 0.058148, -0.114619, -0.058153, -0.114619, -0.088141, 0.059876, -0.039908, 0.264113, 0.032033, 0.001547, 0.225569, -0.014547, -0.225573, -0.014569, -0.032037, 0.001547, 0.039908, 0.264113, 0.088136, 0.059876, 0.058148, -0.114619, -0.058153, -0.114619, -0.088141, 0.059876, -0.039908, 0.264113, 0.032033, 0.001547, 0.225569, -0.014547, -0.225573, -0.014569, -0.032037, 0.001547, 0.039908, 0.264113, 2.6e-05, 0.048796, -2e-06, -0.441511, 2.6e-05, 0.048796, -2e-06, -0.441511],
	[-0.188548, -0.092511, -0.345137, 0.029835, 0.345137, 0.029835, 0.188548, -0.092511, -0.121429, -0.000331, -0.171449, 0.116438, 0.161019, -0.040009, -0.161019, -0.040019, 0.171449, 0.116438, 0.121429, -0.000331, -0.188548, -0.092511, -0.345137, 0.029835, 0.345137, 0.029835, 0.188548, -0.092511, -0.121429, -0.000331, -0.171449, 0.116438, 0.161019, -0.040009, -0.161019, -0.040019, 0.171449, 0.116438, 0.121429, -0.000331, -0.0, 0.008391, -0.0, -0.035224, -0.0, 0.008391, -0.0, -0.035224],
	[0.150091, -0.264392, -0.173811, 0.099428, 0.173811, 0.099428, -0.150091, -0.264392, 0.026929, 0.07098, 0.206352, 0.040885, -0.179491, 0.003009, 0.179491, 0.003009, -0.206352, 0.040885, -0.026929, 0.07098, 0.150091, -0.264392, -0.173811, 0.099428, 0.173811, 0.099428, -0.150091, -0.264392, 0.026929, 0.07098, 0.206352, 0.040885, -0.179491, 0.003009, 0.179491, 0.003009, -0.206352, 0.040885, -0.026929, 0.07098, 0.0, 0.230982, -0.0, -0.130801, 0.0, 0.230982, -0.0, -0.130801],
	[0.114329, -0.235688, 0.167939, 0.10799, -0.167939, 0.10799, -0.114329, -0.235688, 0.149019, -0.013901, -0.255098, 0.007504, 0.176989, -0.005248, -0.176989, -0.005248, 0.255098, 0.007504, -0.149019, -0.013901, 0.114329, -0.235688, 0.167939, 0.10799, -0.167939, 0.10799, -0.114329, -0.235688, 0.149019, -0.013901, -0.255098, 0.007504, 0.176989, -0.005248, -0.176989, -0.005248, 0.255098, 0.007504, -0.149019, -0.013901, 0.0, 0.19604, -0.0, 0.082644, 0.0, 0.19604, -0.0, 0.082644],
	[-0.20377, -0.079464, 0.229262, 0.05016, -0.22926, 0.05016, 0.203762, -0.079464, -0.079646, -0.130869, 0.062022, 0.301162, -0.055319, -0.051915, 0.055321, -0.051925, -0.06202, 0.301162, 0.079646, -0.130869, -0.20377, -0.079464, 0.229262, 0.05016, -0.22926, 0.05016, 0.203762, -0.079464, -0.079646, -0.130869, 0.062022, 0.301162, -0.055319, -0.051915, 0.055321, -0.051925, -0.06202, 0.301162, 0.079646, -0.130869, 1e-06, 0.034962, 1e-06, -0.2131, 1e-06, 0.034962, 1e-06, -0.2131],
	[-0.242306, -0.153987, 0.126068, 0.065412, -0.126068, 0.065412, 0.242306, -0.153987, -0.193867, 0.202828, 0.052684, -0.236456, -0.01094, 0.034134, 0.01094, 0.034134, -0.052684, -0.236456, 0.193867, 0.202828, -0.242306, -0.153987, 0.126068, 0.065412, -0.126068, 0.065412, 0.242306, -0.153987, -0.193867, 0.202828, 0.052684, -0.236456, -0.01094, 0.034134, 0.01094, 0.034134, -0.052684, -0.236456, 0.193867, 0.202828, -0.0, 0.05721, -0.0, 0.118929, -0.0, 0.05721, -0.0, 0.118929]]
nb_a1g = [[-0.058063, 0.195301, -0.014001, 0.233131, 0.014001, 0.233131, 0.058063, 0.195301, 0.094992, 0.094992, 0.195301, 0.058063, 0.233131, 0.014001, 0.233131, -0.014001, 0.195301, -0.058063, 0.094992, -0.094992, 0.058063, -0.195301, 0.014001, -0.233131, -0.014001, -0.233131, -0.058063, -0.195301, -0.094992, -0.094992, -0.195301, -0.058063, -0.233131, -0.014001, -0.233131, 0.014001, -0.195301, 0.058063, -0.094992, 0.094992, 0.0, 0.199581, 0.199581, 0.0, 0.0, -0.199581, -0.199581, 0.0],
	[0.152211, 0.011962, 0.009042, 0.134261, -0.009042, 0.134261, -0.152211, 0.011962, -0.288622, -0.288622, 0.011962, -0.152211, 0.134261, -0.009042, 0.134261, 0.009042, 0.011962, 0.152211, -0.288622, 0.288622, -0.152211, -0.011962, -0.009042, -0.134261, 0.009042, -0.134261, 0.152211, -0.011962, 0.288622, 0.288622, -0.011962, 0.152211, -0.134261, 0.009042, -0.134261, -0.009042, -0.011962, -0.152211, 0.288622, -0.288622, -0.0, 0.023581, 0.023581, -0.0, -0.0, -0.023581, -0.023581, -0.0],
	[-0.015246, 0.062216, -0.001077, -0.20855, 0.001077, -0.20855, 0.015246, 0.062216, -0.084666, -0.084666, 0.062216, 0.015246, -0.20855, 0.001077, -0.20855, -0.001077, 0.062216, -0.015246, -0.084666, 0.084666, 0.015246, -0.062216, 0.001077, 0.20855, -0.001077, 0.20855, -0.015246, -0.062216, 0.084666, 0.084666, -0.062216, -0.015246, 0.20855, -0.001077, 0.20855, 0.001077, -0.062216, 0.015246, 0.084666, -0.084666, -0.0, 0.374791, 0.374791, -0.0, -0.0, -0.374791, -0.374791, -0.0],
	[-0.179499, -0.106499, -0.267749, 0.047804, 0.267749, 0.047804, 0.179499, -0.106499, -0.083814, -0.083814, -0.106499, 0.179499, 0.047804, 0.267749, 0.047804, -0.267749, -0.106499, -0.179499, -0.083814, 0.083814, 0.179499, 0.106499, 0.267749, -0.047804, -0.267749, -0.047804, -0.179499, 0.106499, 0.083814, 0.083814, 0.106499, -0.179499, -0.047804, -0.267749, -0.047804, 0.267749, 0.106499, 0.179499, 0.083814, -0.083814, 0.0, 0.029623, 0.029623, 0.0, 0.0, -0.029623, -0.029623, 0.0],
	[0.163571, -0.233512, -0.027656, 0.082319, 0.027656, 0.082319, -0.163571, -0.233512, 0.123751, 0.123751, -0.233512, -0.163571, 0.082319, 0.027656, 0.082319, -0.027656, -0.233512, 0.163571, 0.123751, -0.123751, -0.163571, 0.233512, 0.027656, -0.082319, -0.027656, -0.082319, 0.163571, 0.233512, -0.123751, -0.123751, 0.233512, 0.163571, -0.082319, -0.027656, -0.082319, 0.027656, 0.233512, -0.163571, -0.123751, 0.123751, 0.0, 0.204261, 0.204261, 0.0, 0.0, -0.204261, -0.204261, 0.0],
	[-0.200601, -0.14083, 0.229161, 0.073415, -0.229161, 0.073415, 0.200601, -0.14083, -0.066894, -0.066894, -0.14083, 0.200601, 0.073415, -0.229161, 0.073415, 0.229161, -0.14083, -0.200601, -0.066894, 0.066894, 0.200601, 0.14083, -0.229161, -0.073415, 0.229161, -0.073415, -0.200601, 0.14083, 0.066894, 0.066894, 0.14083, -0.200601, -0.073415, 0.229161, -0.073415, -0.229161, 0.14083, 0.200601, 0.066894, -0.066894, 0.0, 0.07137, 0.07137, 0.0, 0.0, -0.07137, -0.07137, 0.0]]
nb_a2g = [[0.137494, -0.166707, -0.122566, -0.142476, -0.122568, 0.142474, 0.137492, 0.166709, 0.049842, -0.049842, -0.166707, -0.137494, -0.142476, 0.122566, 0.142474, 0.122568, 0.166709, -0.137492, -0.049842, -0.049842, -0.137494, 0.166707, 0.122566, 0.142476, 0.122568, -0.142474, -0.137492, -0.166709, -0.049842, 0.049842, 0.166707, 0.137494, 0.142476, -0.122566, -0.142474, -0.122568, -0.166709, 0.137492, 0.049842, 0.049842, 0.284599, 2e-06, 2e-06, -0.284599, -0.284599, 2e-06, 2e-06, 0.284599],
	[0.068245, 0.167927, -0.210506, 0.159376, -0.210533, -0.159339, 0.068217, -0.167939, 0.145569, -0.145544, 0.167927, -0.068245, 0.159376, 0.210506, -0.159339, 0.210533, -0.167939, -0.068217, -0.145569, -0.145544, -0.068245, -0.167927, 0.210506, -0.159376, 0.210533, 0.159339, -0.068217, 0.167939, -0.145569, 0.145544, -0.167927, 0.068245, -0.159376, -0.210506, 0.159339, -0.210533, 0.167939, 0.068217, 0.145569, 0.145544, 0.049863, -4e-06, -4e-06, -0.049863, -0.049863, -4e-06, -4e-06, 0.049863],
	[-0.049814, -0.001008, 0.041208, 0.198017, 0.04124, -0.19801, -0.049814, 0.001, -0.192227, 0.192258, -0.001008, 0.049814, 0.198017, -0.041208, -0.19801, -0.04124, 0.001, 0.049814, 0.192227, 0.192258, 0.049814, 0.001008, -0.041208, -0.198017, -0.04124, 0.19801, 0.049814, -0.001, 0.192227, -0.192258, 0.001008, -0.049814, -0.198017, 0.041208, 0.19801, 0.04124, -0.001, -0.049814, -0.192227, -0.192258, 0.298837, 2.4e-05, 2.4e-05, -0.298837, -0.298837, 2.4e-05, 2.4e-05, 0.298837],
	[-0.070651, 0.251006, 0.007917, -0.205232, 0.007934, 0.205231, -0.070672, -0.251, -0.051452, 0.051448, 0.251006, 0.070651, -0.205232, -0.007917, 0.205231, -0.007934, -0.251, 0.070672, 0.051452, 0.051448, 0.070651, -0.251006, -0.007917, 0.205232, -0.007934, -0.205231, 0.070672, 0.251, 0.051452, -0.051448, -0.251006, -0.070651, 0.205232, 0.007917, -0.205231, 0.007934, 0.251, -0.070672, -0.051452, -0.051448, 0.156041, -6e-06, -6e-06, -0.156041, -0.156041, -6e-06, -6e-06, 0.156041],
	[-0.259227, -0.06502, 0.038215, 0.015906, 0.038215, -0.015907, -0.259226, 0.065026, 0.208719, -0.208714, -0.06502, 0.259227, 0.015906, -0.038215, -0.015907, -0.038215, 0.065026, 0.259226, -0.208719, -0.208714, 0.259227, 0.06502, -0.038215, -0.015906, -0.038215, 0.015907, 0.259226, -0.065026, -0.208719, 0.208714, 0.06502, -0.259227, -0.015906, 0.038215, 0.015907, 0.038215, -0.065026, -0.259226, 0.208719, 0.208714, 0.128822, -1e-06, -1e-06, -0.128822, -0.128822, -1e-06, -1e-06, 0.128822]]
ipbases  = [nb_b2g, nb_b1g, nb_eux, nb_euy, nb_a1g, nb_a2g]
ip_comp_base_num = [[0,6],[6,12],[12,23],[23,34],[34,40],[40,45]]

# These are the functions which generate the NSD matrices from numpy.linalg.lstsq on the selected matrix elements,
# the subsets of the total NSD normal coordinate vectors described above. These are either the first element (min),
# elements 1 and 2 of each (Ext.) or the total matrix set (total) - Comp is the sum of squares of the total elements.
# both in plane and out-of-plane (ip and oop) work in the same fashion, though the 24*2 matrix of the in plane elements
# were refashioned as 48-arrays to avoid multidimensional matrix confusion. I'm sure the answers are mathematically identical.

def gen_oop(zdata, output_type = 'min'):
	if output_type == 'min':
		bigmat = hstack(([x[:,0] for x in oopbases]))
	elif output_type == 'ext':
		bigmat = hstack(([x[:,0:2] for x in oopbases]))
	elif output_type in ['comp', 'total']:
		bigmat = hstack((oopbases))

	linalgdata = lstsq(bigmat, array(zdata).reshape(24),rcond = None)
	linalg_doop = sqrt(npsum(square(linalgdata[0])))

	if output_type == 'comp':
		linalgsum = []
		for i in oop_comp_base_num:
			linalgsum.append(sqrt(npsum(square(linalgdata[0][i[0]:i[1]]))))
		return hstack((linalgsum,linalg_doop,linalgdata[1]/4)).flatten()
	else:
		return hstack((linalgdata[0],linalg_doop,linalgdata[1]/4)).flatten()

#the in plane equivalent functions, which are explained above

def gen_ip(xymat, output_type = 'min'):
	if output_type == 'min':
		bigmat = vstack(([x[0] for x in ipbases])).transpose()
	elif output_type == 'ext':
		bigmat = vstack(([x[0:2] for x in ipbases])).transpose()
	elif output_type in ['comp', 'total']:
		bigmat = vstack((ipbases)).transpose()

	xy_diff_mat = matrix(subtract(xymat, ref_str_mat[:,0:2]).flatten()).transpose()
	linalgdata = lstsq(bigmat, xy_diff_mat,rcond = None)
	linalg_dip = sqrt(npsum(square(linalgdata[0])))

	if output_type == 'comp':
		linalgsum = []
		for i in ip_comp_base_num:
			linalgsum.append(sqrt(npsum(square(linalgdata[0][i[0]:i[1]]))))
		return array(hstack(([linalgsum],[[linalg_dip]],linalgdata[1]/4))).flatten()
	else:
		return array(hstack((linalgdata[0].transpose()[0],[[linalg_dip]],linalgdata[1]/4))).flatten()

# A method of rounding numbers in an uneven matrix, and replacing -0 with 0, for purely aesthetic reasons

trim_list = lambda x :  [z if z!='-0.00' else '0.00' for z in ['{:.2f}'.format(round(y, 2)) for y in x]]
trim_list_3 = lambda x :  [z if z!='-0.000' else '0.000' for z in ['{:.3f}'.format(round(y, 3)) for y in x]]
trim_list_5 = lambda x :  [z for z in [round(y, 5) for y in x]]

# takes an x,y,z- matrix (xyzmat.shape = 24*3), and returns the NSD result, which is a list of ordered, variable length lists
#which represent the total NSD matrix. This is the input for the HTML output and for each of the tests in porphyrin_tests

def gen_nsd_from_atoms_w_tot(xyzmat, trim_func = trim_list):
	#runs the nsd stuff on a properly ordered and fitted matrix
	ip = [gen_ip(xyzmat[:,0:2], typo).tolist() for typo in ['min', 'ext','comp','total']]
	oop = [gen_oop(xyzmat[:,2], typo).tolist() for typo in ['min', 'ext','comp','total']]
	nsd_matrix = [trim_func(x) for x in ip + oop]
	return nsd_matrix

ref_str_mat	= matrix(array([ -1.09, 2.827, 0.0, -0.6767, 4.203, 0.0,  0.6767, 4.203, 0.0, 1.09, 2.827, 0.0, 2.413,2.413,0.0,2.827, 1.09, 0.0, 4.203, 0.6767, 0.0,4.203, -0.6767, 0.0,2.827, -1.09, 0.0, 2.413,-2.413,0.0, 1.09, -2.827, 0.0, 0.6767, -4.203, 0.0,  -0.6767, -4.203, 0.0, -1.09, -2.827, 0.0, -2.413,-2.413,0.0, -2.827,-1.09,0.0,  -4.203, -0.6767, 0.0,  -4.203, 0.6767, 0.0,  -2.827, 1.09, 0.0, -2.413,2.413,0.0, 0.0,1.998,0.0, 1.998,0.0,0.0, 0.0,-1.998,0.0, -1.998,0.0,0.0]).reshape(24,3))
#the CuTPP structure used for the basis of NSD. CUTPOR02 in the CCDC. as a 24*3 matrix, used throughout

#this entire section is for making atom position lists with specific distortion profiles for external analysis
# shared with Lukas Urmstul at Talinn - 202005

ng = lambda x,n: [x+str(i+1) for i in range(n)]
ip_names = ng('b2g',6)+ng('b1g',6)+ng('eux',11)+ng('euy',11)+ng('a1g',6)+ng('a2g',5)
op_names = ng('b2u',3)+ng('b1u',3)+ng('a2u',3)+ng('egx',5)+ng('egy',5)+ng('a1u',2)

oop_matrify = lambda mat1d : vstack((zeros(24), zeros(24), array(mat1d).flatten())).T
ip_matrify = lambda mat2d : vstack((array(mat2d[::2]).flatten(),array(mat2d[1::2]).flatten(),zeros(24))).T

opbs = array([oop_matrify(x) for x in hstack([nb_b2u, nb_b1u, nb_a2u, nb_egx, nb_egy, nb_a1u]).T])
ipbs = array([ip_matrify(x) for x in vstack([nb_b2g, nb_b1g, nb_eux, nb_euy, nb_a1g, nb_a2g])])

base_names = ip_names + op_names
base_mats  = vstack((ipbs,opbs))
uvec = lambda vec: vec/norm(vec)
ext_bisec = lambda v1,v2,v3,d: v2+(float(d)*uvec(uvec(v2-v1)+uvec(v2-v3)))

def add_h(mat, dist = 0.83): # adds hydrogen to a porphyrin, at the external bisector, with d = 0.83 A
	hpos = []
	for i in [2,3,5,7,8,10,12,13,15,17,18,20]:
		a,b,c = mat[i-2],mat[i-1],mat[i%20]
		hpos.append(ext_bisec(a,b,c,dist))
	return vstack([mat, vstack(hpos)])

def add_m(mat, dist = 2.0): # adds metal to a porphyrin, at the mean of the nitrogen external bisectors, with d = 2.0 A
	n_bisec = []
	for i in [[1,21,4],[6,22,9],[11,23,14],[16,24,19]]:
		a,b,c = mat[i[0]-1],mat[i[1]-1],mat[i[2]-1]
		n_bisec.append(ext_bisec(a,b,c,dist))
	metal_pos = mean(vstack(n_bisec),axis = 0)
	return vstack([mat, metal_pos])

def print_gaussian_input(mat, metal_name = 'M'):
	asyms =  ['C']*20+['N']*4+['H']*12+[metal_name]
	if mat.shape[0] == 25:
		asyms = ['C']*20+['N']*4+[metal_name]
	glis = [n + '  ' + '  '.join([str(x) for x in array(a).flatten()]) for a,n in zip(mat, asyms)]
	return('\n'.join(glis))

nsd_dict_gen   = lambda: {name:0 for name in base_names}

#e.g. s = ref_str_mat + npsum([mat * nsd_dict[nm] for mat,nm in zip(base_mats, base_names)], axis = 0)
# generates a matrix which represents the porphyrin structure

# connectivity lists, which descrive an ordered porphyrin matrix as a series of bonds, for plotting purposes.
#1 is for a x,y- style porphyrin plot and 2 is for z-theta style after the cylindrical coordinate transfer.
#The h- included ones are those generated above by add_h command.

porp_c1  = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 0, 20, 3, 4, 5, 21, 8, 9, 10, 22, 13, 14, 15, 23, 18]
porp_c2  = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 22, 10, 9, 8, 21, 5, 4, 3, 20, 0, 19, 18, 23, 15, 14, 15, 16, 17, 18, 19, 0]
porp_c1h = [0, 1, 24, 1, 2, 25, 2, 3, 4,26,4, 5, 6, 27, 6, 7, 28, 7, 8, 9,29,9, 10, 11, 30, 11, 12, 31, 12, 13, 14, 32, 14, 15, 16, 33, 16, 17, 34, 17, 18, 19, 35, 19, 0, 20, 3, 4, 5, 21, 8, 9, 10, 22, 13, 14, 15, 23, 18]
porp_c2h = [0, 1, 24, 1, 2, 25, 2, 3, 4,26,4, 5, 6, 27, 6, 7, 28, 7, 8, 9,29,9, 10, 11, 30, 11, 12, 31, 12, 13, 22, 10, 9, 8, 21, 5, 4, 3, 20, 0, 19, 18, 23, 15, 14, 15, 16, 33, 16, 17, 34, 17, 18, 19, 35, 19, 0]

#cylindrical coordinate transform, which is necessary for the skeletal plot, and for making rational skeletal plots,
#rather than those which relied on precomputed values (not that there's anything wrong with that.)
#they're used in the plots and in the interactive figures which have been sent around.

cc_transform_thetaonly = lambda mat: array((arctan2(mat[:,1],mat[:,0])+2.2)%6.283-2.98)
cc_transform_thetaonly_deg = lambda mat: degrees(array((arctan2(mat[:,1],mat[:,0])+2.2)%6.28318-2.98539))
cc_transform_ronly = lambda mat: matrix(norm(mat[:,0:2], axis = 1)).T


#little lambdas which take a matrix and decompose into one-dimensional arrays - just a little cleaner than
# putting multi-line plotting commands and stuff, and they're used frequently. +h are for the H-atoms commands
# described above

gen_x = lambda mat: array([mat[x,0] for x in porp_c1])
gen_y = lambda mat: array([mat[x,1] for x in porp_c1])
gen_z = lambda mat: array([mat[x,2] for x in porp_c2])
gen_t = lambda mat: [cc_transform_thetaonly(mat)[i] for i in porp_c2]
gen_t_deg = lambda mat: [cc_transform_thetaonly_deg(mat)[i] for i in porp_c2]

gen_xh = lambda mat: array([mat[x,0] for x in porp_c1h])
gen_yh = lambda mat: array([mat[x,1] for x in porp_c1h])
gen_zh = lambda mat: array([mat[x,2] for x in porp_c2h])
gen_th = lambda mat: [cc_transform_thetaonly(mat)[i] for i in porp_c2h]

#import file functions

#imports a pdb. Vulnerable to moving decimal places, needs a rewrite.
# should be the fixed version, from the file definitions. Had issues with importing 'ANISOU'
#ignores everything more than x angstroms from a nitrogen atom, and non- C,N atoms.
# can be removed, but tends to mess with stuff and increase computation time and, as is, is
# compatible with chlorins, bacteriochlorins, phthalocyanines and etc.

def import_pdb(filelist, magic_n_radius = 2.75):
	co_list, at_list = [], []

	for l in filelist:
		if len(l)>55 and l.split()[-1] in ['C','N','C0','N0'] and l.startswith(('HETATM','ATOM')):
			x,y,z = l[31:39],l[39:47],l[47:55]
			at_list.append(l.split()[-1])
			co_list.append([float(v) for v in [x,y,z]])
	n_coords = [coords for at,coords in zip(at_list,co_list) if at in ['N', 'N0']]
	co_list_2 = [coords for at,coords in zip(at_list,co_list) if min([atomdist_2(coords,n) for n in n_coords])<magic_n_radius]
	return array(co_list_2)
# now only imports coords within magic distance of a nitrogen
import_pdb_f   = lambda filenm : import_pdb(open(filenm,'r'))
# runs the above on a file. will need another version for non-filename versions (text field, online w.direct (not saving))
#online works without modification. PythonAnywhere standard install. Plan to upgrade for access to PDF printing.
# 202008 - upgraded. The PDF printing is still a little off and ignoring instructions, but it works. Cairo is pretty bad to work with, apparently.

#Transforms used
# SUPER IMPORTANT Quaternions here are not the normal [w,xi,yj,zk] that you know and love, but instead weird
# [x,y,z,w] quaternions which such and are terrible and wasted like three days of mine but are also awesome. s.o. Hamilton.
# This only works okay because we don't write the Quaternions directly and instead get them from the same runtime we give them to,
# so that saves things. See Mondrian - Headless for the actual waste of my time

def trans_atoms(xyzmat, vector): return matrix([array((vector + x)).flatten() for x in xyzmat])
#translates an atom matrix (n*3) by a vector (len 3)
def rot_atoms(xyzmat, quater): return matrix([R.from_quat(quater).apply(x).flatten() for x in xyzmat])
#rotates an atom matrix by a quaternion (in [xyzw] notation!)
def inv_rot_atoms(xyzmat, quater): return matrix([R.from_quat(quater).inv().apply(x).flatten() for x in xyzmat])
#rotates an atom matrix by the inverse of a quaternion i.e. rotates back, so [x,y,z, -w]
def rt_atoms(params, xyzmat): return trans_atoms(rot_atoms(xyzmat, params[3:7]),params[0:3])
#combines rotation and translation. This is the minimization function basis set before (See Acta Cryst A )
def inv_rt_atoms(params, xyzmat): return inv_rot_atoms(trans_atoms(xyzmat,[-x for x in params[0:3]]), params[3:7])
#inverts a rotation and translation. Should work, has been tested
#order of operations turned out to be very important, and screwed everything up. In my defense, I failed second year methematics.

#sum square functions used for minimize fits
def mpln_fit(quater, xyzmat): return npsum(square(rot_atoms(xyzmat,quater))[:,2])
def plane_rot_fit(theta, xyzmat): return mat_dist_4(rot_atoms(xyzmat,[cos(theta/2),sin(theta/2),0,0])[:,0:2],ref_str_mat[:,0:2])**2
def normalise_atoms(xyzmat): return xyzmat-mean(xyzmat, axis = 0)
#moves atoms to the centre of 'mass' with all atoms equally weighted
def atomdist_2(a1,a2): return sqrt(npsum(square(array(a1) - array(a2))))
#gives the distance in real space between two vectors. object/non-object versions.

def mat_dist_4(m1,m2):
	a = array([array(meshgrid(c1,c2)) for c1,c2 in zip(array(m1.T),array(m2.T))])
	return npsum(npmin(npsum(square(a[:,1]-a[:,0]),axis = 0),axis = 0))

#gives the sum of square difference for the closes two atoms which reside in two matrices.
#this is the critical component of the least squares fit to an arbitrary structure
# _4 is a significant speed improvement, able to run in a fraction of the time (2s - 0.1 s)

def rotfunc_4(params, mats): return mat_dist_4(rt_atoms(params, mats[0]),mats[1])
#implements the above for fitting to a porphyrin(3) or an arbitrary distorted porphyrin(4)

class nsd_obj:
	def __init__(self, input_ats = '', filenm = '', refcode = '', calctype = 'pdb'):
		self.filenm = filenm
		self.refcode = refcode
		self.calctype = calctype
		if len(refcode) > 5:
			pass
		elif type(input_ats) == str:
			self.ats_3 = import_pdb_f(filenm)
		else:
			self.ats_3 = input_ats[:,:3].astype(float)
		self.nsd_matrix = []

	def calc_nsd(self):
		if self.calctype == 'pdb':
			self.nsd_matrix, self.coords, self.ass_mat = nsd_fit_out_v5(self.filenm)

		elif self.calctype == 'ccdc':
		#	nsd_comp_path = getcwd() + '/data/nsd_merged_20200420.pkl'
			nsd_comp_path = dirpath + '/data/nsd_202203.pkl'
			nsd_df_comp = pd.read_pickle(nsd_comp_path)
			dfline = nsd_df_comp[nsd_df_comp['NAME']==self.refcode]
			self.nsd_matrix, self.coords = dfline['NSD_matrix'].values[0], array(dfline['coords_matrix'].values[0])
			return self.nsd_matrix, self.coords

		elif self.calctype == 'correct_numbering':
			self.nsd_matrix, self.coords = nsd_fit_out_correct_numbering(self.filenm, ref_str_mat)

		elif self.calctype == 'errorbars':
			self.nsd_matrix, self.coords, self.ass_mat, self.deltas = nsd_fit_out_v4(self.filenm, ref_str_mat)
			proper_assignment = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]
			if self.ass_mat != proper_assignment:
				sad_ref = hstack((ref_str_mat[:,0:2], -1.76 * nb_b2u[:,0]))
				self.nsd_matrix, self.coords, self.ass_mat, self.deltas = nsd_fit_out_v4(self.filenm, sad_ref)
			if self.ass_mat != proper_assignment:
				sad_ref_2 = hstack((ref_str_mat[:,0:2], 4 * nb_b2u[:,0]))
				self.nsd_matrix, self.coords, self.ass_mat, self.deltas = nsd_fit_out_v4(self.filenm, sad_ref_2)
			if self.ass_mat != proper_assignment:
				dom_ref = hstack((ref_str_mat[:,0:2], 2 * nb_a2u[:,0]))
				self.nsd_matrix, self.coords, self.ass_mat, self.deltas = nsd_fit_out_v4(self.filenm, dom_ref)
			#stuff to get 867177.pdb CCDC Dep No. to work. can't figure out why it isnt - worked okay in the other instance
			if self.ass_mat != proper_assignment:
				mst_ref = hstack((ref_str_mat[:,0:2] + (0.38 * array(nb_b2g[0]).reshape(24,2)), 0.16 * nb_b2u[:,0] +  0.25 * nb_b1u[:,0]))
				self.nsd_matrix, self.coords, self.ass_mat, self.deltas = nsd_fit_out_v4(self.filenm, mst_ref)
			if self.ass_mat != proper_assignment:
				mst_ref_2 = hstack((ref_str_mat[:,0:2] + (-0.38 * array(nb_b2g[0]).reshape(24,2)), 0.16 * nb_b2u[:,0] +  0.25 * nb_b1u[:,0]))
				self.nsd_matrix, self.coords, self.ass_mat, self.deltas = nsd_fit_out_v4(self.filenm, mst_ref_2)
			#return self.nsd_matrix,  self.coords, self.ass_mat,  self.deltas
			#?

	def nsd_accurate(self):
		return array([array(x).astype(float) for x in gen_nsd_from_atoms_w_tot(self.coords, trim_list_5)], dtype=object)

	def nsd_fig(self, as_type = 'buffer', imagepath = ''):
		fig, (ax1, ax2) = plt.subplots(1,2, figsize=(10.5,5))
		plot_xy_wlines_ax(ref_str_mat, ax1, marker = 'o',linestyle = 'dotted', color = 'red')
		plot_xy_wlines_ax(self.coords, ax1, marker = 'o',color = 'black')
		ax1.plot(self.coords[20:,0],self.coords[20:,1], linestyle = 'none', marker = 'o',color = 'blue')
		ax1.set_title('In-plane distortion')
		ax1.set_xlabel(r'x position ($\AA$)')
		ax1.set_ylabel(r'y position ($\AA$)')

		ax2.plot([-180,180],[0,0], linestyle = 'dotted', color = 'red')
		skel_dev_plot_2_ax(self.coords, ax2, marker = 'o', color = 'black')
		skel_dev_plot_2N_ax(self.coords, ax2, marker = 'o', color = 'blue')

		maxz = npmax(npabs(self.coords[:,2]))
		ax2.set_xlim(-190,190)
		ax2.set_xticks([-180,-90,0,90,180])
		if maxz <1 :
			ax2.set_ylim(-1,1)
			ax2.set_yticks([-1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 1])
		else: ax2.set_ylim(-maxz-0.5,maxz+0.5)
		ax2.set_title('Out-of-plane distortion')
		ax2.set_xlabel(r'Angle in Cylindrical coordinates ($\degree$)')
		ax2.set_ylabel(r'z position ($\AA$)')
		ax2.yaxis.set_label_position("right")
		ax2.yaxis.tick_right()
		plt.subplots_adjust(left = 0.07, right = 0.93, wspace = 0.1, top = 0.95)

		if self.calctype == 'errorbars':
			thermal_sfac = 0.5
			plot_xy_erbars_angle_ax(self.coords, self.deltas, ax1, thermal_sfac)
			skel_dev_plot_2_ax_erbars(self.coords, self.deltas, ax2, thermal_sfac, color = 'black')

		if as_type == 'buffer':
			buf = BytesIO()
			fig.savefig(buf, format = 'png', dpi = 300)
			image_base64 = base64.b64encode(buf.getvalue()).decode('utf-8').replace('\n', '')
			buf.close()
			return image_base64
		else:
			fig.savefig(imagepath, dpi = 300)
			plt.clf()


#these are the plots which appear at the base of the NSD profile - each lambda is run in the gen_nsd_fig function, and
#next plan is to incorporate handling of ellipsoid data in to there. Not sure exactly whether there's an easier way to pass a bunch
#of specs to a plot.

	def mondrian(self, imagepath = '', cmap = '',linewidth = 3,bleed = 0.0001,
			random_order = False, regular_axes = True, hatchwork = False, as_type = 'buffer'):

		nms = 'B$_{2g}$,B$_{1g}$,E$_{u}$x,E$_{u}$y,A$_{1g}$,A$_{2g}$,B$_{2u}$,B$_{1u}$,A$_{2u}$,E$_{g}$x,E$_{g}$y,A$_{1u}$'.split(',')
		symm_typog_lookup = {'D4h':'D$_{4h}$','D4 ':'D$_{4 }$','D2 ':'D$_{2 }$','D2d':'D$_{2d}$','D2h':'D$_{2h}$','S4 ':'S$_{4 }$','C4 ':'C$_{4 }$','C4h':'C$_{4h}$','C1 ':'C$_{1 }$','Ci ':'C$_{i }$','C2h':'C$_{2h}$','Cs ':'C$_{s }$','C2 ':'C$_{2 }$','C2v':'C$_{2v}$','C4v':'C$_{4v}$'}
		good_cmaps_with_sns = 'Spectral,RdYlBu,RdYlBu_r,rainbow,Blues,Greys,sns_RdBu_r,sns_colorblind,sns_Set2,sns_Set3'.split(',') + ['sns_ch:-1.5,-1,light=0.98,dark=.3','sns_ch:0.3,-0.5,light=0.98,dark=.3']
		good_cmaps = 'Spectral,RdYlBu,RdYlBu_r,rainbow,Blues,Greys,RdBu_r,Set2,Set3'.split(',')
		hatch_picks = ['.', '..','/','//', '\\', '\\\\', '*','**','-','--', '+', '++', '|', '||', 'x', 'xx','o','oo','O', None]

		if cmap in ['random', '']:
			random.shuffle(good_cmaps)
			cmap = random.choice(good_cmaps)

		if cmap.lower().startswith('hatch') : hatchwork, cmap = True, 'white'
		if cmap.lower() == 'white': cmap = 'sns_ch:-1.5,-1,light=0.98,dark=.98'

		nsd = self.nsd_accurate()

		#takes the total distortion as the starting point, ignores zeros
		opc = array(nsd[6][:6]).astype(float)
		ipc = array(nsd[2][:6]).astype(float)
		if ((npabs(opc[3]-opc[4])<opc[3]) and (npabs(opc[3]-opc[4])<opc[4])):
			opc[3],opc[4] = opc[3]+opc[4],npabs(opc[3]-opc[4])
			nms[9],nms[10] = 'E$_{g}$x+y','E$_{g}$x-y'
		if ((npabs(ipc[2]-ipc[3])<ipc[2]) and (npabs(ipc[2]-ipc[3])<ipc[3])):
			ipc[2],ipc[3] = ipc[2]+ipc[3],npabs(ipc[2]-ipc[3])
			nms[2],nms[3] = 'E$_{u}$x+y','E$_{u}$x-y'

		ops = sort(array([x for x in opc if x >= 0.01]))
		ips = sort(array([x for x in ipc if x >= 0.01]))

		#Sets the borders of the plot
		if regular_axes: xmin,xmax,ymin,ymax = -2.2, 0.8, -2.2, 0.8
		else:
			if ops.size > 0: xmin, xmax = log10(npmin(ops))-0.5,log10(npmax(ops))+0.5
			else: xmin,xmax = 0.01, 1.0
			if ips.size > 0: ymin, ymax = log10(npmin(ips))-0.5,log10(npmax(ips))+0.5
			else: ymin, ymax = 0.01, 1.0

		#defines the 'flat' panes of the plot, by making points at corners of a rectangle.
		#This is more efficient than making a grid of the entire area, as symmetry doesn't change within panels.
		x_op = sort(hstack([10**xmin, ops - bleed, ops + bleed, 10**xmax]))
		y_ip = sort(hstack([10**ymin, ips - bleed, ips + bleed, 10**ymax]))

		#generates an ordered list of symmetry operations
		sym1 = [find_symmetry(nsd,(y,x)) for x,y in zip(*[z.flatten() for z in meshgrid(x_op,y_ip)])]
		sym2,sym3 = unique(sym1,return_index=True)
		sym3.sort()
		syms = [sym1[x] for x in sym3]
		if random_order: random.shuffle(syms)

		ludict = {y:x+0.5 for x,y in enumerate(syms)}

		if str(cmap).startswith('sns_'):
			import seaborn as sns
			cmap_o = ListedColormap(sns.color_palette(cmap[4:], len(syms)))
		else:
			cmap_o = cmap
		cmap_o = cmap
		if hatchwork == True:
			hats = hatch_picks.copy()
			random.shuffle(hats)
		elif hatchwork == False: hats = [None]
		else: hats = hatchwork

		nx, ny = meshgrid(x_op, y_ip)
		nz = array([ludict.get(x) for x in sym1]).reshape(len(y_ip),len(x_op))

		#plot setup
		fig,ax = plt.subplots(figsize = (9,7))

		#The primary plot
		im = ax.contourf(nx, ny, nz, cmap = cmap_o, corner_mask = False, levels = npabs(len(syms)-2), hatches = hats)
		ax.set_yscale('log'), ax.set_xscale('log')

		#The colourbar
		cbar = fig.colorbar(im, drawedges = True)
		for index, value in enumerate(syms): cbar.ax.text(1.66, (index+0.5)/(len(syms)), symm_typog_lookup.get(value), ha='center', va='center', transform=cbar.ax.transAxes)
		cbar.ax.get_yaxis().set_ticks([])
		cbar.outline.set_linewidth(linewidth)
		cbar.dividers.set_linewidth(linewidth)

		#plots horizonatal and vertical lines, indicating symmetry operations above threshold
		[ax.plot([x,x],[npmin(ny),npmax(ny)], 'black', lw = linewidth) for x in ops if x >= 0.01]
		[ax.plot([npmin(nx),npmax(nx)],[y,y], 'black', lw = linewidth) for y in ips if y >= 0.01]

		#Labels on horizontal/vertical lines.
		[ax.text(1.045 , 1-(ymax-log10(value))/(ymax-ymin) - 0.025*ipc[:index].tolist().count(value), nms[index], ha='right',  va='center', transform=ax.transAxes) for index, value in enumerate(ipc) if value > 0.001]
		[ax.text(1-(xmax-log10(value))/(xmax-xmin) + 0.035*opc[:index].tolist().count(value), 1.01, nms[index+6], ha='center',  va='bottom', rotation = 45, transform=ax.transAxes) for index, value in enumerate(opc) if value > 0.001]

		ax.set_ylabel('in-plane NSD value ($\\AA$)')
		ax.set_xlabel('out-of-plane NSD value ($\\AA$)')
		[i.set_linewidth(linewidth) for i in ax.spines.values()]
		[i.set_linewidth(linewidth) for i in cbar.ax.spines.values()]
		if as_type == 'buffer':
			buf = BytesIO()
			fig.savefig(buf, format = 'png', dpi = 300)
			image_base64 = base64.b64encode(buf.getvalue()).decode('utf-8').replace('\n', '')
			buf.close()
			return image_base64
		else:
			fig.savefig(imagepath, dpi = 300)
			return cmap

	def alert_section(self):
		nsd = self.nsd_matrix
		return render_template('/nsd/nsd_alert_section.html',
									 a1 = check_NSDt_residuals(nsd),
									 a2 = symm_typog_html.get(find_symmetry(nsd,(0.2,0.5))),
									 a3 = symm_typog_html.get(find_symmetry(nsd,(0.03,0.1))),
									 a4 = check_cent(nsd,0.01),
									 a5 = check_cent(nsd,0.1),
									 b2u = check_b2u(nsd),
									 b2g = check_b2g(nsd),
									 b1g = check_b1g(nsd),
									 a2u = check_a2u(nsd),
									 b1u = check_b1u(nsd),
									 a1g = check_a1g(nsd),
									 a2g = check_a2g(nsd),
									 comp1 = find_comparison_in_database(nsd),
									 comp2 = find_comparison_in_database(nsd,minabs),
									 comp3 = find_comparison_in_database(nsd, nsd_df = nsd_df_pdb),
									 comp4 = find_comparison_in_database(nsd,minabs, nsd_df = nsd_df_pdb),
									 sum_energy = mode_energy_calc(nsd))

	def bdba_extract_array(self, errors = True, keith = False):
		nca	   = array([x-1 for x in [21,1,21,4,22,6,22,9,23,11,23,14,24,16,24,19]]).reshape(8,2)
		cacb   = array([x-1 for x in [1,2,3,4,6,7,8,9,11,12,13,14,16,17,18,19]]).reshape(8,2)
		cacm   = array([x-1 for x in [4,5,5,6,9,10,10,11,14,15,15,16,19,20,20,1]]).reshape(8,2)
		cbcb   = array([x-1 for x in [2,3,7,8,12,13,17,18]]).reshape(4,2)

		canca  = array([x-1 for x in [1,21,4,6,22,9,11,23,14,16,24,19]]).reshape(4,3)
		ncacb  = array([x-1 for x in [21,1,2,21,4,3,22,6,7,22,9,8,23,11,12,23,14,13,24,16,17,24,19,18]]).reshape(8,3)
		ncacm  = array([x-1 for x in [21,1,20,21,4,5,22,6,5,22,9,10,23,11,10,23,14,15,24,16,15,24,19,20]]).reshape(8,3)
		cacbcb = array([x-1 for x in [1,2,3,2,3,4,6,7,8,7,8,9,11,12,13,12,13,14,16,17,18,17,18,19]]).reshape(8,3)
		cbcacm = array([x-1 for x in [20,1,2,3,4,5,5,6,7,8,9,10,10,11,12,13,14,15,15,16,17,18,19,20]]).reshape(8,3)
		cacmca = array([x-1 for x in [19,20,1,4,5,6,9,10,11,14,15,16]]).reshape(4,3)

		nnadj  = array([x-1 for x in [21,22,22,23,23,24,24,21]]).reshape(4,2)
		nnopp  = array([x-1 for x in [21,23,22,24]]).reshape(2,2)

		pyrrs  = array([x-1 for x in [1,2,3,4,21,6,7,8,9,22,11,12,13,14,23,16,17,18,19,24]]).reshape(4,5)

		delns  = array([21,22,23,24])-1
		delcas = array([1,4,6,9,11,14,16,19])-1
		delcbs = array([2,3,7,8,12,13,17,18])-1
		delcms = array([5,10,15,20])-1
		del24  = array(range(24))

		bdlist  = [nca,cacb,cacm,cbcb,nnadj,nnopp]
		balist  = [canca,ncacb,ncacm,cacbcb,cbcacm,cacmca]
		dellist = [delns,delcas,delcbs,delcms,del24]
		bdnames = 'nca,cacb,cacm,cbcb,nnadj,nnopp'.split(',')
		banames = 'canca,ncacb,ncacm,cacbcb,cbcacm,cacmca'.split(',')
		delnames= 'delns,delcas,delcbs,delcms,del24'.split(',')

		dist_from_pts  = lambda v1,v2:    sqrt(npsum(square(v2-v1)))
		ang_from_pts   = lambda v1,v2,v3: degrees(arccos(npfloat(dot((v1-v2), (v3-v2).T))/product([dist_from_pts(x,y) for x,y in [(v2,v1),(v2,v3)]])))
		ang_from_vec   = lambda v1,v2:    degrees(arccos(npfloat(dot((v1), (v2).T))/product([sqrt(npsum(square(x))) for x in [v1,v2]])))
		normalise_atoms= lambda xyzmat:   matrix([array(x-mean(x)).flatten() for x in xyzmat.T]).T

		round_to_2 = lambda x: round(x, 1-int(floor(log10(abs(x)))))
		round_to_4 = lambda x: str(round(x, 3-int(floor(log10(abs(x))))))

		idents = 'nca,cacb,cacm,cbcb,cacbcb,ncacb,ncacm,canca,cbcacm,cacmca,del24,delns,delcas,delcbs,delcms,pyr_ang,nnadj,nnopp'.split(',')

		outdict = {}

		for name,idxs in zip(bdnames,bdlist):
			pars = [dist_from_pts(self.coords[a],self.coords[b]) for a,b in idxs]
			[outdict.update({x:y}) for x,y in [[name, pars],[name +'_mean', mean(pars)],[name +'_std', std(pars)],[name +'_format', esd_gen(mean(pars),std(pars))]]]
		for name,idxs in zip(banames,balist):
			pars = [ang_from_pts(self.coords[a],self.coords[b],self.coords[c]) for a,b,c in idxs]
			[outdict.update({x:y}) for x,y in [[name, pars],[name +'_mean', mean(pars)],[name +'_std', std(pars)],[name +'_format', esd_gen(mean(pars),std(pars))]]]

		mpln_quat = minimize(mpln_fit, [1,0,0,0], self.coords).x
		mpln_vec  = rot_atoms([[0,0,1]],mpln_quat)
		coords_mpln = rot_atoms(self.coords,mpln_quat)

		pyr_angles = []
		for idxs in pyrrs:
			py_coords = array([self.coords[x] for x in idxs])
			norm_py_c = normalise_atoms(py_coords)
			pypl_quat = minimize(mpln_fit, [1,0,0,0], norm_py_c).x
			py_vec	= rot_atoms([[0,0,1]],pypl_quat)
			pang	  = ang_from_vec(mpln_vec, py_vec)

			pyr_angles.append(min([pang, 180 - pang]))

		[outdict.update({x:y}) for x,y in [['pyr_ang', pyr_angles],
										   ['pyr_ang_mean', mean(pyr_angles)],
										   ['pyr_ang_std', std(pyr_angles)],
										   ['pyr_ang_format', esd_gen(mean(pyr_angles),std(pyr_angles))]]]

		for name,idxs in zip(delnames,dellist):
			pars = [npabs(coords_mpln[a,2]) for a in idxs]
			[outdict.update({x:y}) for x,y in [[name, pars],[name +'_mean', mean(pars)],[name +'_std', std(pars)],[name +'_format', esd_gen(mean(pars),std(pars))]]]
			if name == 'del24':
				[outdict.update({x:y}) for x,y in [[name, pars],[name +'_mean', mean(pars)],[name +'_std', std(pars)],[name +'_format', esd_gen(mean(pars),0.00001)]]]

		if keith:
			return ['\n'.join([str(round_to_4(x)) for x in outdict.get(name)]) for name in idents]
		elif errors:
			return [outdict.get(name+'_format') for name in idents]
		else:
			return [round_to_4(outdict.get(name+'_mean')) for name in idents]

	def verbose_output(self):
		#print(verbose_output(ref_str_mat)) to print the comparison reference structure table
		m3 = npround(self.coords,3)
		m4 = npround(hstack((cc_transform_ronly(matrix(self.coords)),cc_transform_thetaonly_deg(matrix(self.coords)))),3)
		return hstack((m3,m4)).T

	def extras(self, validtype = 'large', errors = True, keith = False, cmap = 'random'):
		if validtype == 'small':
			return ''
		else:
			return '\n'.join([self.alert_section(),
            render_template('/nsd/nsd_bdba_table_section.html', vals = self.bdba_extract_array(errors, keith)),
            render_template('/nsd/nsd_verbose_table_section.html', t = self.verbose_output()),
            render_template('/nsd/nsd_mondrian_section.html', mondrian_fig = self.mondrian())
            ])

#plotting functions for easy generation of matplotlib indicators
plot_atoms_xy  = lambda xyzmat,**args: plt.plot(xyzmat[:,0],xyzmat[:,1],'o',linestyle = 'none',**args)
#generates an xy pyplot

porp_connect   = lambda xyzmat: vstack([xyzmat[i] for i in porp_c1])
#turns a porphyrin C1-C20-N21-N24 grid to an ordered list so that the skeletal plot can be plotted.
plot_xy_wlines = lambda xyzmat, **args: plt.plot(porp_connect(xyzmat)[:,0],porp_connect(xyzmat)[:,1],**args)
plot_xy_wlines_ax = lambda xyzmat, ax, **args: ax.plot(porp_connect(xyzmat)[:,0],porp_connect(xyzmat)[:,1],**args)
#plots the 'xy' skeletal plot. plt/ax versions for notebook work

skel_dev_plot_2  = lambda xyzmat,**args: plt.plot(gen_t(xyzmat), gen_z(xyzmat), **args)
skel_dev_plot_2_ax  = lambda xyzmat, ax, **args: ax.plot(gen_t_deg(xyzmat), gen_z(xyzmat), **args)
#plots the 'z-theta' skeletal plot. plt/ax versions for notebook work

skel_dev_plot_2N = lambda xyzmat,**args: plt.plot(cc_transform_thetaonly(xyzmat)[20:], xyzmat[20:,2], linestyle = 'none',**args)
skel_dev_plot_2N_ax = lambda xyzmat, ax, **args: ax.plot(cc_transform_thetaonly_deg(xyzmat)[20:], xyzmat[20:,2], linestyle = 'none',**args)
#plots the N atoms of the 'z-theta' skeletal plot. plt/ax versions for notebook work



def fit_atoms_rt(xyzmat, refmat = ref_str_mat, cycles = 5):
	porpfit = [0,0,0,0.1,0,0,0]
	#this is x,y,z and a rotational quaternion - fitting rotation and translation concurrently, as the
	#centre of mass of the structure is not necessarily the centre of the porphyrin.
	for i in range(cycles):
		porpfit = minimize(rotfunc_4, porpfit, [refmat, xyzmat]).x
	return inv_rt_atoms(porpfit, xyzmat)

# _old may be useful for more distorted structures, just have to write an effective testing regime


#gen_fixed_xyz take a matrix representing atom positions and put them in the stated porphyrin structure order

#version 202007 (v6) - uses the Hungarian method for assigning atoms to the fixed structure, prevents the 'atom-doubling effect of the previous
#method (smallest distance). no real way to check that it's right - seems to give a characteristic atom number matrix that isn't just 1-24
#next step - implement some kind of check method.
#This algoritm is On^3 so pretty much immediate.

def gen_fixed_xyz_v6(xyzmat, refmat = ref_str_mat):
	costmat = zeros((len(refmat[:,0]),len(xyzmat[:,0])))
	for idx_r,val_r in enumerate(refmat[:,0:2]):
		for idx_m,val_m in enumerate(xyzmat[:,0:2]):
			costmat[idx_r,idx_m] = atomdist_2(val_r,val_m)
	assignmat = linear_sum_assignment(costmat)[1].tolist()
	return (vstack([xyzmat[i] for i in assignmat]), assignmat)

def nsd_fit_out_v5(filenm, reference_matrix = ref_str_mat):
	raw_atoms = import_pdb_f(filenm)
	nor_atoms = normalise_atoms(raw_atoms)
	fit_atoms = fit_atoms_rt(nor_atoms, reference_matrix,1)
	num_porp  = gen_fixed_xyz_v6(fit_atoms, reference_matrix)[0]
	nor_porp  = normalise_atoms(num_porp)
	fit_porp  = fit_atoms_rt(nor_porp,reference_matrix,1)
	mpln	  = minimize(mpln_fit, [1,0,0,0], fit_porp).x
	mpln_porp = rot_atoms(fit_porp, mpln)
	theta	  = minimize(plane_rot_fit, 0, fit_porp).x
	rot_porp  = inv_rot_atoms(fit_porp,[cos(theta/2),sin(theta/2),0,0])
	xyz_final, ass_mat = gen_fixed_xyz_v6(rot_porp, reference_matrix)
	nsd	   = gen_nsd_from_atoms_w_tot(xyz_final, trim_list)
	return nsd, xyz_final, ass_mat

# def save_figs_and_NSD(filepath, imagepath = ''):
# 	nsd_mat, coords, ass_mat = nsd_fit_out_v5(filepath, ref_str_mat)
# 	buffer_fig = gen_nsd_fig(coords, as_type = 'buffer')
# 	return (nsd_mat, coords, buffer_fig)

#extra little names for things - helps with the generation of NSD dataframes (i.e. NSD_x.pkl)
tg = lambda x,n: [x+str(i+1) for i in range(n)]
tf = lambda x,n: [x+'f'+str(i+1) for i in range(n)]

ip1_names = ['mstr', 'nstr', 'trnx', 'trny', 'bre', 'rot', 'dip', 'dip_err']
ip2_names = ['b2g_ext1', 'b2g_ext2', 'b1g_ext1', 'b1g_ext2', 'eux_ext1', 'eux_ext2', 'euy_ext1', 'euy_ext2', 'a1g_ext1', 'a1g_ext2', 'a2g_ext1', 'a2g_ext2', 'dip_ext', 'dip_ext_err']
ip3_names = ['b2g_comp', 'b1g_comp', 'eux_comp', 'euy_comp', 'a1g_comp', 'a2g_comp', 'dip_comp', 'dip_comp_err']
ip4_names = tg('b2gt',6)+tg('b1gt',6)+tg('euxt',11)+tg('euyt',11)+tg('a1gt',6)+tg('a2gt',5)+['dipt','dipt_err']
ip4f_names = tf('b2gt',6)+tf('b1gt',6)+tf('euxt',11)+tf('euyt',11)+tf('a1gt',6)+tf('a2gt',5)+['diptf','diptf_err']
ip4_firsts = [0]*6 + [6]*6 + [12]*11 + [23]*11 + [45]*6 + [40]*5 + [45,46]

op1_names = ['sad', 'ruf', 'dom', 'wavx', 'wavy', 'pro', 'doop', 'doop_err']
op2_names = ['b2u_ext1', 'b2u_ext2', 'b1u_ext1', 'b1u_ext2', 'a2u_ext1', 'a2u_ext2', 'egx_ext1', 'egx_ext2', 'egy_ext1', 'egy_ext2', 'a1u_ext1', 'a1u_ext2', 'doop_ext', 'doop_ext_err']
op3_names = ['b2u_comp', 'b1u_comp', 'a2u_comp', 'egx_comp', 'egy_comp', 'a1u_comp', 'doop_comp', 'doop_comp_err']
op4_names = tg('b2ut',3)+tg('b1ut',3)+tg('a2ut',3)+tg('egxt',5)+tg('egyt',5)+tg('a1ut',2)+['dopt','dopt_err']
op4f_names = tf('b2ut',3)+tf('b1ut',3)+tf('a2ut',3)+tf('egxt',5)+tf('egyt',5)+tf('a1ut',2)+['doptf','doptf_err']
op4_firsts = [0]*3 + [3]*3 + [6]*3 + [9]*5 + [14]*5 + [19]*2 + [21,22]

nsd_names = [ip1_names,ip2_names ,ip3_names ,ip4_names ,op1_names ,op2_names ,op3_names ,op4_names,ip4f_names,op4f_names]
all_modes_names = [x for y in nsd_names for x in y]

#from here on, this is the code which imports and plots the ANISOU card data for
#each of the atoms in the core. Basically the same as the above, and I'll
#combine them at some point. Desire is to put error margins on the NSD numbers
#based on thermal activation.
#Handles thermal data, not certain that it has the right implementation of
#matrix multiplication for tensors (ellipsoids) yet. That will be the next issue

def gen_fixed_xyz_v4(xyzmat, refmat = ref_str_mat):
	assignmat = [0]*len(refmat[:,0])
	for idx_r,val_r in enumerate(refmat[:,0:2]):
		assignmat[idx_r] = argmin([atomdist_2(val_r,val_m) for val_m in xyzmat[:,0:2]])
	return (vstack([xyzmat[i] for i in assignmat]), assignmat)

def import_pdb_waniso(filelist, magic_n_radius = 3):
	co_list, at_list,aniso_list, ser_list = [], [], [], []

	for index, l in enumerate(filelist): #l is line
		if len(l)>55 and l.split()[-1] in ['C','N'] and l.startswith(('HETATM','ATOM')):
			serial,x,y,z = l[6:11],l[31:39],l[39:47],l[47:55]
			at_list.append(l.split()[-1])
			co_list.append([float(v) for v in [x,y,z]])
			ser_list.append(serial)
			if str(filelist[index+1]).startswith('ANISOU'):
				l2 = filelist[index+1]
				u11,u22,u33,u12,u13,u23 = l2[29:36],l2[36:43],l2[43:50],l2[50:57],l2[57:64],l2[64:71]
				aniso_list.append(array([u11,u22,u33,u12,u13,u23]).astype(float))
	n_coords = [coords for at,coords in zip(at_list,co_list) if at == 'N']
	co_list_2    = [coords for coords in co_list if min([atomdist_2(coords,n) for n in n_coords])<magic_n_radius]
	ser_list_2   = [serials for coords,serials in zip(co_list,ser_list) if min([atomdist_2(coords,n) for n in n_coords])<magic_n_radius]
	if len(aniso_list) > 0:
		aniso_list_2 = [anisos for coords,anisos in zip(co_list,aniso_list) if min([atomdist_2(coords,n) for n in n_coords])<magic_n_radius]
	else:
		aniso_list_2 = []
	print(array(co_list_2))
	return array(co_list_2), array(aniso_list_2), ser_list_2

# now only imports coords within magic distance of a nitrogen
#incl anisotropic parameters too
import_pdb_waniso_f   = lambda filenm : import_pdb_waniso(open(filenm,'r').readlines())
# runs the above on a file. will need another version for non-filename versions (text field, online)

aniso_to_matrix = lambda ans : matrix([[ans[0],ans[3],ans[4]],[ans[3],ans[1],ans[5]],[ans[4],ans[5],ans[2]]])
rotate_tensor = lambda ansmat,quater : dot(dot(R.from_quat(quater).as_matrix(),ansmat), R.from_quat(quater).as_matrix().T)

def fit_atoms_rt_v2(xyzmat, refmat = ref_str_mat, cycles = 1):
	porpfit = [0,0,0,0.1,0,0,0]
	for i in range(cycles):
		porpfit = minimize(rotfunc_4, porpfit, [refmat, xyzmat]).x
	return inv_rt_atoms(porpfit, xyzmat),porpfit

def gen_fixed_xyz_v5(xyzmat, refmat = ref_str_mat):
	assignmat = [0]*len(refmat[:,0])
	for idx_r,val_r in enumerate(refmat[:,0:2]):
		assignmat[idx_r] = argmin([atomdist_2(val_r,val_m) for val_m in xyzmat[:,0:2]])
	return (vstack([xyzmat[i] for i in assignmat]), assignmat)

def nsd_fit_out_v4(filenm, reference_matrix = ref_str_mat, aniso_gen = True):
	if aniso_gen:
		raw_atoms, raw_anisos, serials = import_pdb_waniso_f(filenm)
	else:
		raw_atoms = import_pdb_f(filenm)
	nor_atoms = normalise_atoms(raw_atoms)
	fit_atoms, reorient_mat1 = fit_atoms_rt_v2(nor_atoms, reference_matrix,2)
	num_porp, assignmat1 = gen_fixed_xyz_v4(fit_atoms, reference_matrix)
	nor_porp  = normalise_atoms(num_porp)
	fit_porp, reorient_mat2 = fit_atoms_rt_v2(nor_porp,reference_matrix,2)
	mpln	  = minimize(mpln_fit, [1,0,0,0], fit_porp).x #reorient_mat3
	mpln_porp = rot_atoms(fit_porp, mpln)
	theta	  = minimize(plane_rot_fit, 0, fit_porp).x #reorient_mat4
	rot_porp  = inv_rot_atoms(fit_porp,[cos(theta/2),sin(theta/2),0,0])
	xyz_final, assignmat2 = gen_fixed_xyz_v4(rot_porp, reference_matrix)
	nsd	   = gen_nsd_from_atoms_w_tot(xyz_final, trim_list)

	if aniso_gen:
		sers_2 = [serials[i] for i in assignmat1]
		sers_3 = [sers_2[i] for i in assignmat2]
		anis_2 = [raw_anisos[i] for i in assignmat1]
		anis_3 = vstack([anis_2[i] for i in assignmat2])/1000
		deltas = vstack([rotate_tensor(rotate_tensor(rotate_tensor(rotate_tensor(aniso_to_matrix(x),reorient_mat1[3:7]),
			reorient_mat2[3:7]),mpln),[cos(theta/2),sin(theta/2),0,0]).flatten()[:,[0,4,8,1,2,5]] for x in anis_3])
	else:
		deltas = []
	print(assignmat2)
	return nsd, xyz_final, assignmat2, deltas

skel_dev_plot_2_ax_erbars = lambda xyzmat, dels, ax, thermal_sfac = 1.0,**args: ax.errorbar(gen_t_deg(xyzmat), gen_z(xyzmat), yerr= [thermal_sfac*dels[i,2] for i in porp_c2],linestyle = 'none',capsize = 4,**args)
plot_xy_erbars_ax = lambda xyzmat, dels, ax, **args: ax.errorbar(xyzmat[:,0],xyzmat[:,1],xerr = dels[:,0], yerr = dels[:,1],linestyle = 'none',capsize = 4, **args)

	# equation for an ellipse is cotangent(2*theta) = (A-C)/B for Ax^2 + Bxy + Cy^2 (A=u11, B=u12, C=u22)
	# with major/ minor axes denoted by A' = A(cos θ)^2 + B(cos θ sin θ) + C(sin θ)^2
	#                                   B' = 0
	#                                   C' = A(sin θ)^2 − B(sin θ cos θ) + C(cos θ)^2

	#ellip_z_eq = lambda z, u33: abs(erf(2*pi*z/u33))
	#print(mean([ellip_z_eq(z,e) for z,e in zip(coords[:,2],deltas[:,2]/2)]))
	#print(coords[:,2],deltas[:,2]/2)

def draw_angle_errorbars(xpos,ypos, u11, u12, u22, ax,thermal_sfac=1.0, **args): #assumes z=0 plane for every individual atom (slice through atom centroid parallel to the mean plane)
	theta  = (1/2)*(arctan(u12/(u11-u22)))
	Aprime = u11*(cos(theta))**2 + u12*(cos(theta)*sin(theta)) + u22*(sin(theta))**2
	Bprime = -2*u11*(cos(theta)*sin(theta)) + u12*(cos(theta)**2-sin(theta)**2) + 2*u22*(cos(theta)*sin(theta))
	#Sanity check. Bprime should be zero
	Cprime = u11*(sin(theta))**2 - u12*(cos(theta)*sin(theta)) + u22*(cos(theta))**2
	v1x, v1y = thermal_sfac*Aprime*cos(-theta),  thermal_sfac*Aprime*sin(-theta)
	v2x, v2y = thermal_sfac*Cprime*sin(-theta),  thermal_sfac*(-Cprime)*cos(-theta)
	ax.annotate("", xytext=(xpos-v1x,ypos-v1y), xy=(xpos+v1x, ypos+v1y),
								 arrowprops=dict(arrowstyle=ArrowStyle.BarAB(widthA = 0.2, widthB = 0.2),
								fc="k", ec="k"), **args)
	ax.annotate("", xytext=(xpos-v2x,ypos-v2y), xy=(xpos+v2x, ypos+v2y),
								 arrowprops=dict(arrowstyle=ArrowStyle.BarAB(widthA = 0.2, widthB = 0.2),
								fc="k", ec="k"), **args)

plot_xy_erbars_angle_ax = lambda coords, deltas, ax1, thermal_sfac=1.0, **args: [draw_angle_errorbars(coords[i,0], coords[i,1],deltas[i,0],deltas[i,3],deltas[i,1],ax1,thermal_sfac,**args) for i in range(24)]

def save_figs_and_NSD_v2(filepath, imagepath1 = '', as_type = False):
	nsd_mat, coords, ass_mat, deltas = nsd_fit_out_v4(filepath, ref_str_mat)
	proper_assignment = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
	15, 16, 17, 18, 19, 20, 21, 22, 23]
	if ass_mat != proper_assignment:
		sad_ref = hstack((ref_str_mat[:,0:2], -1.76 * nb_b2u[:,0]))
		nsd_mat, coords, ass_mat, deltas = nsd_fit_out_v4(filepath, sad_ref)
	if ass_mat != proper_assignment:
		sad_ref_2 = hstack((ref_str_mat[:,0:2], 4 * nb_b2u[:,0]))
		nsd_mat, coords, ass_mat, deltas = nsd_fit_out_v4(filepath, sad_ref_2)
	if ass_mat != proper_assignment:
		dom_ref = hstack((ref_str_mat[:,0:2], 2 * nb_a2u[:,0]))
		nsd_mat, coords, ass_mat, deltas = nsd_fit_out_v4(filepath, dom_ref)
	#stuff to get 867177.pdb CCDC Dep No. to work. can't figure out why it isnt - worked okay in the other instance
	if ass_mat != proper_assignment:
		mst_ref = hstack((ref_str_mat[:,0:2] + (0.38 * array(nb_b2g[0]).reshape(24,2)), 0.16 * nb_b2u[:,0] +  0.25 * nb_b1u[:,0]))
		nsd_mat, coords, ass_mat, deltas = nsd_fit_out_v4(filepath, mst_ref)
	if ass_mat != proper_assignment:
		mst_ref_2 = hstack((ref_str_mat[:,0:2] + (-0.38 * array(nb_b2g[0]).reshape(24,2)), 0.16 * nb_b2u[:,0] +  0.25 * nb_b1u[:,0]))
		nsd_mat, coords, ass_mat, deltas = nsd_fit_out_v4(filepath, mst_ref_2)

	fig, (ax1, ax2) = plt.subplots(1,2, figsize=(10.5,5))
	plot_xy_wlines_ax(ref_str_mat, ax1, marker = 'o',linestyle = 'dotted', color = 'red')
	plot_xy_wlines_ax(coords, ax1, marker = 'o',color = 'black')
	thermal_sfac = 0.5
	plot_xy_erbars_angle_ax(coords, deltas, ax1, thermal_sfac)

	ax1.plot(coords[20:,0],coords[20:,1], linestyle = 'none', marker = 'o',color = 'blue')
	ax1.set_title('In-plane distortion')
	ax1.set_xlabel(r'x position ($\AA$)')
	ax1.set_ylabel(r'y position ($\AA$)')

	ax2.plot([-180,180],[0,0], linestyle = 'dotted', color = 'red')
	skel_dev_plot_2_ax(coords, ax2, marker = 'o', color = 'black')
	skel_dev_plot_2_ax_erbars(coords, deltas, ax2, thermal_sfac, color = 'black')
	skel_dev_plot_2N_ax(coords, ax2, marker = 'o', color = 'blue')
	maxz = npmax(npabs(coords[:,2]))
	ax2.set_xlim(-190,190)
	ax2.set_xticks([-180,-90,0,90,180])
	if maxz <1 :
		ax2.set_ylim(-1,1)
		ax2.set_yticks([-1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 1])
	else: ax2.set_ylim(-maxz-0.5,maxz+0.5)
	ax2.set_title('Out-of-plane distortion')
	ax2.set_xlabel(r'Angle in Cylindical coordinates ($\degree$)')
	ax2.set_ylabel(r'z position ($\AA$)')
	ax2.yaxis.set_label_position("right")
	ax2.yaxis.tick_right()
	plt.subplots_adjust(left = 0.07, right = 0.93, wspace = 0.1, top = 0.95)
	if as_type == 'buffer':
		buf = BytesIO()
		fig.savefig(buf, format = 'png', dpi = 300)
		image_base64 = base64.b64encode(buf.getvalue()).decode('utf-8').replace('\n', '')
		buf.close()
		return (nsd_mat, coords, deltas, image_base64)
	else:
		fig.savefig(imagepath1, dpi = 300)
		plt.clf()
		return (nsd_mat, coords, deltas)

# this is the subroutine for looking up an NSD profile from the full database
#which is generated by Gen_NSD_db. expected that this'll be the same for a PDB
#lookup, whenever I get around to that.

# def save_figs_and_NSD_from_CCDC(NAME, imagepath1 = ''):
# 	nsd_comp_path = dirpath + '/data/nsd_merged_20200420.pkl'
# 	nsd_df_comp = pd.read_pickle(nsd_comp_path)
# 	dfline = nsd_df_comp[nsd_df_comp['NAME']==NAME]
# 	nsd_mat, coords = dfline['NSD_matrix'].values[0], array(dfline['coords_matrix'].values[0])
# 	buffer_fig = gen_nsd_fig(coords, as_type = 'buffer')
# 	return (nsd_mat, coords, buffer_fig)

# from here, it's replicas of Save_NSD_from etc. with things filtered out to
# account for atoms having correct names. (Correct_numbering subroutine)
#includes redefinitions of several of the functions, to import only those atoms,
#and removes the requirement of reordering the atoms.
#could potentially get stuck in a false minimum, but haven't observed it yet.

def import_pdb_correct_numbering(filelist, magic_n_radius = 3):
	co_list  = zeros((24,3))
	proper_names = ['C1' ,'C2' ,'C3' ,'C4' ,'C5' ,'C6' ,'C7' ,'C8' ,'C9' ,'C10','C11','C12','C13','C14','C15','C16','C17','C18','C19','C20','N21','N22','N23','N24']
	for index, l in enumerate(filelist): #l is line
		if len(l)>55 and l.split()[-1] in ['C','N'] and l.startswith(('HETATM','ATOM')):
			atname,x,y,z = l[12:16].strip(' '),l[31:39],l[39:47],l[47:55]
			if atname in proper_names:
				co_list[proper_names.index(atname),:] = [float(v) for v in [x,y,z]]
	return array(co_list) #shouldn't need reordering

def import_pdb_correct_numbering_f  (filenm): return import_pdb_correct_numbering(open(filenm,'r').readlines())
def mat_dist_correct_numbering (m1,m2): return npsum(square(m2-m1))
def rotfunc_correct_numbering (params, mats): return mat_dist_correct_numbering(rt_atoms(params, mats[0]),mats[1])

def fit_atoms_correct_numbering(xyzmat, refmat = ref_str_mat, cycles = 1):
	porpfit = [0,0,0,0.1,0,0,0]
	for i in range(cycles):
		porpfit = minimize(rotfunc_correct_numbering, porpfit, [refmat, xyzmat]).x
	return inv_rt_atoms(porpfit, xyzmat)

def nsd_fit_out_correct_numbering(filenm, reference_matrix = ref_str_mat):
	raw_atoms =  import_pdb_correct_numbering_f(filenm)
	nor_atoms = normalise_atoms(raw_atoms)
	xyz_final = fit_atoms_correct_numbering(nor_atoms, reference_matrix,1)
	nsd	   = gen_nsd_from_atoms_w_tot(xyz_final, trim_list)
	return nsd, xyz_final

# def save_figs_and_NSD_correct_numbering(filepath, imagepath1 = ''):
# 	nsd_mat, coords = nsd_fit_out_correct_numbering(filepath, ref_str_mat)
# 	buffer_fig = gen_nsd_fig(coords, as_type = 'buffer')
# 	return (nsd_mat, coords, buffer_fig)

##needs fixing! find a way to distribute together

#These are the precalculated NSD databases of porphyrin compounds, which are formed by an adaptation of the method
#presented in porphyrin_tools.py, using data from the porphyrin subset of the CCDC CSD. A .sd file was extracted
#using Mercury, with the CSD_Materials subset - Search, using the similarity fragemnt of the CuTPP core (CUTPOR02)
#and exporting only the hit fragment. PDB was considerably easier - using the list of porphyrin containing ligand
#names, the .sd file could be exported automatically. This interface is at
#"https://www.rcsb.org/pages/download_features#Ligands"
#The relevant CCDC refcodes can be investgated at https://www.kingsbury.id.au/nsd_ccdc

# nsdpath = '/Users/kingsbury/work/NSD/data/nsd_min_for_web_20200511.pkl'
# nsdpath_pdb = '/Users/kingsbury/work/NSD/data/nsd_pdb_min_20200522.pkl'
# nsdpath = getcwd() + '/data/nsd_min_for_web_20200511.pkl'
nsdpath = os.path.join(dirpath, 'data', 'nsd_202203.pkl')
nsdpath_pdb = os.path.join(dirpath, 'data', 'nsd_pdb_min_20200522.pkl')
nsd_df = pd.read_pickle(nsdpath)
# nsd_df_pdb = pd.read_pickle(nsdpath_pdb)
nsd_df_pdb = None

#Clusters were identified using the CCDC Conquest interface, and exporting lists of refcodes (6-letter structure identifiers)
#to compare with the refcode identifiers embedded in the above database. The data-merging of the original NSD database (v201911)
#left some Null values, left over from the need to include several extraneous parameters - so the refcode list was a better choice
#for unambiguous indetification. There are some structures with two different porphyrins which might hit the outliers e.g.
# https://doi.org/10.1002/asia.201600241 but these have been ignored.
#Clusters were defined by the Pearson covariance of the two parameters, which gives a symmetric tensor [[C11,C12],[C12,C22]]
#and the values ('pars') below are in the form [x0,y0,c11,c22,scale,c12] with scale defined as 1.

### Cluster testing related values

b2u_check_vals = {'pars' : {'H4 acid cluster': [3.0773, 0.94645, -0.29823, 0.07049, 1, -0.12770]},
		'nov' : [7,0,2],
		'lim'  : [0.02,0.005]}

b2u2_check_vals = {'names' : ['Likely Dodeca (|B<sub>2u</sub>(1)| > 2)'],
		'nov' : [7,0],
		'lim'  : [2.]}

b2g_check_vals = {'pars' : {#'5,15, metal, beta = H':[0.08418010651018837, -0.026778411744277097, 0.04149381712364415, -0.01507673359458361, 1, -0.19287286637293546, 0.09057271167701475, 0.02458884078254685],
							'5,15, metal, beta = non-H':[0.21075549108551414, 0.023933920141517188, 0.10221841949829814, 0.013438533128731273, 1, 0.10392525232738446, 0.19901442413636633, 0.12353032539865172],
							'5,15, freebase, beta = H':[0.2796331868763387, 0.05379403638432011, 0.0005922128644580995, 0.010423122676713428, 1, 0.1820619695556503, 0.2749043100550682, 0.051212207839939246],
							'5,15, freebase, beta = non-H':[0.6071911088525302, 0.02897561012344148, 0.1780476825308557, -0.012238095404704023, 1, -0.0688729413590178, 0.6180045532297789, 0.13583958227054066]
				},
		'nov' : [3,0,2],
		'lim'  : [0.02,0.005]}

a2u_check_vals = {'pars' : {'P-Ln-coligand':[0.48569094812634045, 0.1175628286028602, -0.04537143613278038, -0.019756017665943107, 1, 0.04890733363253202, 0.48732830664240334, -0.021572803565188082],
							'TPP-Ln-Pc/P':[0.7885884401688048, 0.04124693320814232, 0.13004548415201533, 0.016810668229109454, 1, -0.09496770869596864, 0.7973665914167872, 0.054681576500455464],
							'OEP-Ln-Pc/P':[0.929994688788826, -0.055799729255368954, 0.33165100527161445, -0.016624880107176058, 1, -0.3959453122199556, 0.9859545583692699, -0.05268889165617063],
							'5,15- di(exo-enyl)chlorins':[0.7140828701984177, 0.22835801682901558, -0.17752495570704085, 0.04153543623170062, 1, -0.19278591061420222, 0.6668412668454056, -0.31105012496639756]},
		'nov' : [3,6,8],
		'lim'  : [0.02, 0.005]}

b1g_check_vals = {'names': ['likely freebase'],
		'nov':[3,7],
		'lim'  : [0.04]}

b1u_check_vals = {'names': ['Ruffled compound'],
		'nov':[7,3],
		'lim'  : [0.8]}

#Points check_ellipsoid() at the right values
mode_dict = {'a2u': a2u_check_vals,
'b2u': b2u_check_vals,
'b2u2': b2u2_check_vals,
'b2g': b2g_check_vals,
'b1g': b1g_check_vals,
'b1u': b1u_check_vals
}

### Symmetry-related data tables
#these are expanded versions of the point group table and symmetry operations retained in the lower symmetry elements,
# represented as a binary string so that they may be multiplied together. As is, the product of rows of the pgt represents
# the symmetry element dictated by the unique string in teh lookup table when these symmetry deviations are taken into
# account. The "Mondrian" method of visualising these symmetry-decompositional thresholds is expected to be published shortly,
# and is available at https://www.kingsbury.id.au/mondrian

### Expanded symmetry-related data tables
#E	2C4 (z)	C2	C'2x C'2y	C''2x+y C''2x-y	i	2S4	h	v1 v2	d1 d2
#             E  C4 C2 Cx Cy Cp Cm i  S4 h  v1 v2 d1 d2
d4h_pgt   = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],#'A1g'
			 [1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0],#'A2g'
			 [1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0],#'B1g'
			 [1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1],#'B2g'
			 [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],#'A1u'
			 [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],#'A2u'
			 [1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1],#'B1u'
			 [1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0],#'B2u'
			 [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0],#'Egx'
			 [1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0],#'Egy'
			 [1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0],#'Egx+y'
			 [1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1],#'Egx-y'
			 [1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0],#'Eux'
			 [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0],#'Euy'
			 [1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],#'Eux+y'
			 [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]]#'Eux-y'

#                E C4C2CxCyCpCmi S4h v1v2d1d2
d4h_lookup = { '[1 1 1 1 1 1 1 1 1 1 1 1 1 1]':'D4h',#a1g
			   '[1 1 1 0 0 0 0 1 1 1 0 0 0 0]':'C4h',#a2g
			   '[1 0 1 1 1 0 0 1 0 1 1 1 0 0]':'D2h',#b1g
			   '[1 0 1 0 0 1 1 1 0 1 0 0 1 1]':'D2h',#b2g
			   '[1 1 1 1 1 1 1 0 0 0 0 0 0 0]':'D4 ',#a1u
			   '[1 1 1 0 0 0 0 0 0 0 1 1 1 1]':'C4v',#a2u
			   '[1 0 1 0 0 1 1 0 1 0 1 1 0 0]':'D2d',#b1u
			   '[1 0 1 1 1 0 0 0 1 0 0 0 1 1]':'D2d',#b2u
			   '[1 0 1 0 0 0 0 1 0 1 0 0 0 0]':'C2h',
			   '[1 0 0 1 0 0 0 1 0 0 1 0 0 0]':'C2h',#egx
			   '[1 0 0 0 1 0 0 1 0 0 0 1 0 0]':'C2h',#egy
			   '[1 0 0 0 0 1 0 1 0 0 0 0 1 0]':'C2h',#egx+y
			   '[1 0 0 0 0 0 1 1 0 0 0 0 0 1]':'C2h',#egx-y
			   '[1 0 1 0 0 0 0 0 0 0 1 1 0 0]':'C2v',
			   '[1 0 1 0 0 0 0 0 0 0 0 0 1 1]':'C2v',
			   '[1 0 0 1 0 0 0 0 0 1 0 1 0 0]':'C2v',#eux
			   '[1 0 0 0 1 0 0 0 0 1 1 0 0 0]':'C2v',#euy
			   '[1 0 0 0 0 1 0 0 0 1 0 0 0 1]':'C2v',#eux+y
			   '[1 0 0 0 0 0 1 0 0 1 0 0 1 0]':'C2v',#eux-y
			   '[1 0 1 0 0 1 1 0 0 0 0 0 0 0]':'D2 ',
			   '[1 0 1 1 1 0 0 0 0 0 0 0 0 0]':'D2 ',
			   '[1 0 1 0 0 0 0 0 1 0 0 0 0 0]':'S4 ',
			   '[1 1 1 0 0 0 0 0 0 0 0 0 0 0]':'C4 ',
			   '[1 0 1 0 0 0 0 0 0 0 0 0 0 0]':'C2 ',
			   '[1 0 0 1 0 0 0 0 0 0 0 0 0 0]':'C2 ',
			   '[1 0 0 0 1 0 0 0 0 0 0 0 0 0]':'C2 ',
			   '[1 0 0 0 0 1 0 0 0 0 0 0 0 0]':'C2 ',
			   '[1 0 0 0 0 0 1 0 0 0 0 0 0 0]':'C2 ',
			   '[1 0 0 0 0 0 0 1 0 0 0 0 0 0]':'Ci ',
			   '[1 0 0 0 0 0 0 0 0 1 0 0 0 0]':'Cs ',
			   '[1 0 0 0 0 0 0 0 0 0 1 0 0 0]':'Cs ',
			   '[1 0 0 0 0 0 0 0 0 0 0 1 0 0]':'Cs ',
			   '[1 0 0 0 0 0 0 0 0 0 0 0 1 0]':'Cs ',
			   '[1 0 0 0 0 0 0 0 0 0 0 0 0 1]':'Cs ',
			   '[1 0 0 0 0 0 0 0 0 0 0 0 0 0]':'C1 ',}

# This symmetry finder operates by the principle outlined above, multiplication of symmetry-access vectors (rows
# of the point-group table) for deviations above a certain threshold (e.g. 0.2 for in-plane and 0.5 for out-of-plane)
# These thresholds are arbitrary, but seem to correlate with symmetry obtained via NMR.
# more info is available in https://dx.doi.org/10.1021/acs.inorgchem.9b01963

def find_symmetry(nsd, thr = (0.2,0.5)): # thr : thresholds
	ipc, opc = nsd[2][:6],nsd[6][:6]
	ipc, opc = [float(x) for x in ipc], [float(x) for x in opc]
	symms = [1 if float(x)>thr[0] else 0 for x in ipc]+[1 if float(x)>thr[1] else 0 for x in opc]
	ab_syms = [symms[x] for x in [4,5,1,0,11,8,7,6]]

	e_syms_o  = [1 if float(x)>thr[1] else 0 for x in [opc[3],opc[4],0,0]]#opc[3]+opc[4],npabs(opc[3]-opc[4])]]
	e_syms_i  = [1 if float(x)>thr[0] else 0 for x in [ipc[2],ipc[3],0,0]]#ipc[2]+ipc[3],npabs(ipc[2]-ipc[3])]]
	if ((npabs(opc[3]-opc[4])<opc[3]) and (npabs(opc[3]-opc[4])<opc[4])):
		e_syms_o  = [1 if float(x)>thr[1] else 0 for x in [0,0,opc[3]+opc[4],npabs(opc[3]-opc[4])]]
	if ((npabs(ipc[2]-ipc[3])<ipc[2]) and (npabs(ipc[2]-ipc[3])<ipc[3])):
		e_syms_i  = [1 if float(x)>thr[0] else 0 for x in [0,0,ipc[2]+ipc[3],npabs(ipc[2]-ipc[3])]]

	all_syms = ab_syms + e_syms_o + e_syms_i
	all_syms[0] = 1
	pgt_rows = [d4h_pgt[i] for i,x in enumerate(all_syms) if x==1]
	lookup_row = str(prod(pgt_rows,axis = 0))
	symm_guess = str(d4h_lookup.get(str(lookup_row)))

	return symm_guess

#generates a simple html table
tablegen = lambda matrix: '<table>'+'\n'.join(['<tr>'+' '.join(['<td>'+str(x)+'</td>' for x in y])+'</tr>' for y in npround(matrix,4).tolist()])+'</table>'

#lambdas for the closest match below - these are a little slow, but it's a 66*7000 array, I guess I can't optimise more
minssq = lambda a1,a2: npsum(square(a1-a2))
minabs = lambda a1,a2: npsum(npabs(a1-a2))

#these were from Jentzen's paper, basically the elastic strain on a distorted prophyrin from the simple harmonic oscillator
#model. Not supposed to be used for calculation, but might be of interest to strapping types, or could correlate with something
mode_energy_list = [9.1,16.5,41.4,67.3,67.3,238.4,0,0,100.1,147.8,280.5,280.5,293.8,652.9,0,0]
mode_energy_calc = lambda nsd: str(npround(npsum(multiply(square(array(nsd[4]+nsd[0]).astype(float)), mode_energy_list)),1))+ ' kJ/mol'
check_NSDt_residuals = lambda nsd: sum([float(nsd[2][7]),float(nsd[6][7])]) < 0.001

#second and third mode frequencies. Currently ignored
Mode_freq_2= [[256, 516, 359, 238, 238, 680],[721, 727, 781, 468, 468], #oop2, oop3
				[428, 757, 413, 413, 701, 769],[893, 989, 739, 739, 994, 1113]]#cm-1 ip2 ip3

#Checks if all ungerade modes are zero i.e. a centrosymmetric porphyrin
def check_cent(nsd, tval = 0.00):
	uimodes,uomodes = [i for i in range(12,34)],[0,1,2,3,4,5,6,7,8,19,20]
	ipt,opt = nsd[3],nsd[7]
	umod = [float(ipt[i]) for i in uimodes]+[float(opt[i]) for i in uomodes]
	return str(sum([1 for x in umod if npabs(x) <= tval]) == 33)

#compares the nsd parameters (i.e. molecular conformation) against a precomputed
#database of NSD parameters. This provides links too! Neat!
#essentially, the min_sum and min_ssq (sum of squares) of the differential NSD
#matrices often give a good fit to the dominant mode of distortion, either in or
#out of plane, though A1g has out-of-plane artifacts that are often overfitted
#not planning to go abck and correct for it though
def find_comparison_in_database(nsd, corr_func = minssq, nsd_df = nsd_df):
	tf = lambda x,n: [x+'f'+str(i+1) for i in range(n)]

	op4f_names = tf('b2ut',3)+tf('b1ut',3)+tf('a2ut',3)+tf('egxt',5)+tf('egyt',5)+tf('a1ut',2)+['doptf','doptf_err']
	ip4f_names = tf('b2gt',6)+tf('b1gt',6)+tf('euxt',11)+tf('euyt',11)+tf('a1gt',6)+tf('a2gt',5)+['diptf','diptf_err']

	ip4_firsts = [0]*6 + [6]*6 + [12]*11 + [23]*11 + [45]*6 + [40]*5 + [45,46]
	op4_firsts = [0]*3 + [3]*3 + [6]*3 + [9]*5 + [14]*5 + [19]*2 + [21,22]
	#references to the individual symmetry operations

	ip4 = array(nsd[3]).astype(float)
	op4 = array(nsd[7]).astype(float)
	ip4f = array([x * sign(y) for x,y in zip(ip4, [ip4[z] for z in ip4_firsts])])
	op4f = array([x * sign(y) for x,y in zip(op4, [op4[z] for z in op4_firsts])])

	#aligns symmetric distortion modes (ignores chirality)
	if corr_func is minssq:
		correlidx_op = nsd_df['opc'].apply(lambda row: npsum(square(row[:-2]-op4f[:-2]))).idxmin()
		correlidx_ip = nsd_df['ipc'].apply(lambda row: npsum(square(row[:-2]-ip4f[:-2]))).idxmin()
	if corr_func is minabs:
		correlidx_op = nsd_df['opc'].apply(lambda row: npsum(npabs(row[:-2]-op4f[:-2]))).idxmin()
		correlidx_ip = nsd_df['ipc'].apply(lambda row: npsum(npabs(row[:-2]-ip4f[:-2]))).idxmin()
	if corr_func in [pearsonr,spearmanr,kendalltau]:
		correlidx_op = nsd_df['opc'].apply(lambda row: corr_func(row[:-2],op4f[:-2])[0]).idxmax()
		correlidx_ip = nsd_df['ipc'].apply(lambda row: corr_func(row[:-2],ip4f[:-2])[0]).idxmax()

	oop_best_corr = nsd_df.iloc[correlidx_op]['NAME']
	ip_best_corr = nsd_df.iloc[correlidx_ip]['NAME']

	#for flipping Eg/u x/y when necessary (threshold is 0.1 difference)
	ipc = array(nsd[2]).astype(float)[2:4] #these are the Eu values
	opc = array(nsd[6]).astype(float)[3:5] #these are the Eg values
	if (((npabs(ipc[0]-ipc[1])>0.1)>0.1)|(npabs(opc[0]-opc[1])>0.1)):
		#compares the two Eg and Eu values to find a significant difference if (flipped) will be different
		ip4f = hstack((ip4f[0:12],ip4f[23:34],ip4f[12:23],ip4f[34:]))
		op4f = hstack((op4f[0:9],op4f[14:19],op4f[9:14],op4f[19:]))
		if corr_func is minssq:
			correlidx_op = nsd_df['opc'].apply(lambda row: npsum(square(row[:-2]-op4f[:-2]))).idxmin()
			correlidx_ip = nsd_df['ipc'].apply(lambda row: npsum(square(row[:-2]-ip4f[:-2]))).idxmin()
		if corr_func is minabs:
			correlidx_op = nsd_df['opc'].apply(lambda row: npsum(npabs(row[:-2]-op4f[:-2]))).idxmin()
			correlidx_ip = nsd_df['ipc'].apply(lambda row: npsum(npabs(row[:-2]-ip4f[:-2]))).idxmin()
		if corr_func in [pearsonr,spearmanr,kendalltau]:
			correlidx_op = nsd_df['opc'].apply(lambda row: corr_func(row[:-2],op4f[:-2])[0]).idxmax()
			correlidx_ip = nsd_df['ipc'].apply(lambda row: corr_func(row[:-2],ip4f[:-2])[0]).idxmax()

		oop_best_corr = oop_best_corr + ' / ' + nsd_df.iloc[correlidx_op]['NAME'] + ' (flipped)'
		ip_best_corr  = ip_best_corr + ' / ' + nsd_df.iloc[correlidx_ip]['NAME'] + ' (flipped)'

	return [oop_best_corr, ip_best_corr]

#could figure to report the contributing modes of symmetry, but this is easier to see from the Mondrian diagram
def find_symmetry_contributing_modes(nsd, thr = (0.2,0.5)): # thr : thresholds
	ipc,opc = nsd[2][:6],nsd[6][:6]
	op_names = ['b2u','b1u','a2u','egx','egy','a1u']
	ip_names = ['b2g','b1g','eux','euy','a1g','a2g']
	symm_names = [y for x,y in zip(ipc,ip_names) if float(x)>thr[0]]+[y for x,y in zip(opc,op_names) if float(x)>thr[1]]
	return symm_names

#Checks if the porphyrin is chiral at the designated threshold. Useful for saddled 5,15s and the like
find_is_chiral = lambda nsd, thr = (0.2,0.5): find_symmetry(nsd, thr) in ['D4 ','D2 ','C4 ','C2 ','C1 ']

#compares the precomputed cluster analysis for porphyrinoid distortion to a two-parameter model, based on a
#pearson-covariance derived lorentzian ellipsoid. The threshold values are usually 2 sigma.
def check_ellipsoid(nsd, mode):
	lorentzian = lambda xv: 1/(1+xv**2)
	l_func_2d =lambda p,xv,yv: p[4]*(lorentzian(sqrt( (((cos(p[5])*xv + sin(p[5])*yv)-p[0])/p[1])**2 + (((cos(p[5])*yv - sin(p[5])*xv)-p[2])/p[3])**2 )))
	output = []

	vals = mode_dict.get(mode)
	pars,nov,lim = [vals.get(x) for x in 'pars,nov,lim'.split(',')]
	opt = [float(x) for x in nsd[nov[0]][nov[1]:nov[2]]]
	xval,yval = multiply(opt, sign(opt[0]))
	for cname,cpars in pars.items():
		cval = l_func_2d(cpars, xval,yval)**2
		for index,limit in enumerate(lim):
			if cval > limit: #arbitrary values
				output.append(cname + ' limit ' + str(index+1))
				break
	return output

def check_linear(nsd, mode): #checks whether a value is above a threshold (see b1g_check_vals)
	vals = mode_dict.get(mode)
	names,nov,lim = [vals.get(x) for x in 'names,nov,lim'.split(',')]
	output = []
	opt = npabs(float(nsd[nov[0]][nov[1]]))
	for cname,clim in zip(names, lim):
		if opt >= lim:
			output.append(cname)
	return output

#writes html output
check_a2u = lambda nsd: '\n'.join(check_ellipsoid(nsd, 'a2u'))
check_b2u = lambda nsd: '\n'.join(check_ellipsoid(nsd, 'b2u') + check_linear(nsd,'b2u2'))
check_b2g = lambda nsd: '\n'.join(check_ellipsoid(nsd, 'b2g'))
check_b1g = lambda nsd: '\n'.join(check_linear(nsd, 'b1g'))
check_b1u = lambda nsd: '\n'.join(check_linear(nsd, 'b1u'))

def check_a1g(nsd):
	a1g1 = float(nsd[3][34])
	if a1g1 > 0.1:
		return 'Expanded porphyrin core (Zn-like)'
	elif a1g1 > -0.05:
		return 'Median porphyrin core (Cu-like)'
	else:
		return 'Contracted porphyrin core (Ni-like)'

def check_a2g(nsd):
	a2g2 = float(nsd[3][41])
	b1u1 = float(nsd[7][4])
	b2u1 = float(nsd[7][1])
	if (abs(a2g2) - abs(b1u1 * b2u1 *  0.0851)) > 0.03:
		return "A<sub>2g</sub>2 inconsistent with out-of-plane structure"
	else:
		return ''

def write_logfile(pdbname, nsd, logname):
	log = open(logname, 'a')
	log.write(str(pdbname) + '\n')
	log.write(str(nsd) + '\n')
	#log.write(str(generate_alert_section(nsd)) + '\n')
	log.close()
	log2 = open(logname[:-4]+'.csv', 'a')
	vlist = [pdbname] + nsd[0] +nsd[4]
	log2.write(','.join([str(x) for x in vlist]) + '\n')
	log2.close()

def esd_gen(num, err):
	# puts two floats (e.g. 2.1022, 0.02) into standard notation (e.g. "2.10(2)")
	if (err < 0.0001) and (num < 2):
		return str(round(num,4))
	if (err < 0.0001) and (num >= 2):
		return str(round(num,2))
	if err > 1.95:
		num = int(num)
	if err*10**(-int(floor(log10(abs(err))))) < 1.95:
		return str(round(num, 1-int(floor(log10(abs(err)))))) + '(' + str(ceil(err*10**(1-int(floor(log10(abs(err))))))) + ')'
	else:
		return str(round(num, -int(floor(log10(abs(err)))))) + '(' + str(int(round(err*10**(-int(floor(log10(abs(err)))))))) + ')'

#charts predefined bond distances, angles, plane deviations, rotation angles, etc. Useful for padding a report.
#errors reports the mean values and the standard deviation of these values - can be much more or less than
#the error on the individual bond distances. Keith mode just reports all the values without averaging.


symm_typog_html  = {'D4h':'D<sub>4h</sub>','D4 ':'D<sub>4 </sub>','D2 ':'D<sub>2 </sub>','D2d':'D<sub>2d</sub>','D2h':'D<sub>2h</sub>','S4 ':'S<sub>4 </sub>','C4 ':'C<sub>4 </sub>','C4h':'C<sub>4h</sub>','C1 ':'C<sub>1 </sub>','Ci ':'C<sub>i </sub>','C2h':'C<sub>2h</sub>','Cs ':'C<sub>s </sub>','C2 ':'C<sub>2 </sub>','C2v':'C<sub>2v</sub>','C4v':'C<sub>4v</sub>',
                    'D4':'D<sub>4 </sub>','D2':'D<sub>2 </sub>','S4':'S<sub>4 </sub>','C4':'C<sub>4 </sub>','C1':'C<sub>1 </sub>','Ci':'C<sub>i </sub>','Cs':'C<sub>s </sub>','C2':'C<sub>2 </sub>'}
