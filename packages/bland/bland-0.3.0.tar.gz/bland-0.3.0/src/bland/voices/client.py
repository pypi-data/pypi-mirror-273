# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ..commons.errors.server_error import ServerError
from ..commons.errors.unauthorized_error import UnauthorizedError
from ..commons.types.error_body import ErrorBody
from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import pydantic_v1
from ..core.remove_none_from_dict import remove_none_from_dict
from ..core.request_options import RequestOptions
from .types.create_voice_preset_response import CreateVoicePresetResponse
from .types.delete_voice_preset_response import DeleteVoicePresetResponse
from .types.generate_voice_sample_response import GenerateVoiceSampleResponse
from .types.list_voice_options_response import ListVoiceOptionsResponse
from .types.publish_voice_preset_response import PublishVoicePresetResponse
from .types.retrieve_voice_preset_response import RetrieveVoicePresetResponse
from .types.update_voice_preset_response import UpdateVoicePresetResponse
from .types.voice_settings_data import VoiceSettingsData

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class VoicesClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        *,
        default_only: typing.Optional[bool] = None,
        presets_only: typing.Optional[bool] = None,
        voices_only: typing.Optional[bool] = None,
        is_custom: typing.Optional[bool] = None,
        name: typing.Optional[str] = None,
        voice_name: typing.Optional[str] = None,
        voice_id: typing.Optional[int] = None,
        reduce_latency: typing.Optional[bool] = None,
        public: typing.Optional[bool] = None,
        editable: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListVoiceOptionsResponse:
        """
        Retrieves all available voices for your account, including custom and default presets.

        Parameters
        ----------
        default_only : typing.Optional[bool]
            Filter to show only default presets, excluding user-created presets.

        presets_only : typing.Optional[bool]
            Filter to show only presets.

        voices_only : typing.Optional[bool]
            Filter to show only voices.

        is_custom : typing.Optional[bool]
            Filter for custom voices.

        name : typing.Optional[str]
            Filters the voices array by the name of the voice.

        voice_name : typing.Optional[str]
            Filters the presets array by the name of the voice.

        voice_id : typing.Optional[int]
            Filters the presets array by the ID of the voice.

        reduce_latency : typing.Optional[bool]
            Filter by latency reduction option. Use in tandem with `reduce_latency`to simulate exactly which voice your agent would use.

        public : typing.Optional[bool]
            Filter to show only public presets, or set to `false` to exclude them.

        editable : typing.Optional[bool]
            Filter to show only editable presets.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListVoiceOptionsResponse

        Examples
        --------
        from bland.client import BlandAI

        client = BlandAI(
            api_key="YOUR_API_KEY",
        )
        client.voices.list(
            default_only=True,
            presets_only=True,
            voices_only=True,
            is_custom=True,
            name="string",
            voice_name="string",
            voice_id=1,
            reduce_latency=True,
            public=True,
            editable=True,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/voices"),
            params=jsonable_encoder(
                remove_none_from_dict(
                    {
                        "default_only": default_only,
                        "presets_only": presets_only,
                        "voices_only": voices_only,
                        "is_custom": is_custom,
                        "name": name,
                        "voice_name": voice_name,
                        "voice_id": voice_id,
                        "reduce_latency": reduce_latency,
                        "public": public,
                        "editable": editable,
                        **(
                            request_options.get("additional_query_parameters", {})
                            if request_options is not None
                            else {}
                        ),
                    }
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(ListVoiceOptionsResponse, _response.json())  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def retrieve(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> RetrieveVoicePresetResponse:
        """
        Retrieves detailed information about a voice preset for the given id.

        Parameters
        ----------
        id : str
            The unique identifier for the voice preset.

            Used within your call like `voice: "ff2c405b-3dba-41e0-9261-bc8ee3f91f46"` instead of `voice_id: ..., reduce_latency: ...`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        RetrieveVoicePresetResponse

        Examples
        --------
        from bland.client import BlandAI

        client = BlandAI(
            api_key="YOUR_API_KEY",
        )
        client.voices.retrieve(
            id="string",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v1/voices/{jsonable_encoder(id)}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(RetrieveVoicePresetResponse, _response.json())  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create(
        self,
        *,
        voice_name: str,
        description: typing.Optional[str] = OMIT,
        voice_id: typing.Optional[int] = OMIT,
        reduce_latency: typing.Optional[bool] = OMIT,
        interruption_threshold: typing.Optional[int] = OMIT,
        language: typing.Optional[str] = OMIT,
        voice_settings: typing.Optional[VoiceSettingsData] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateVoicePresetResponse:
        """
        Creates a new voice preset by bundling various voice settings into one entity.

        Parameters
        ----------
        voice_name : str
            The name for the new voice preset.

        description : typing.Optional[str]
            A description of the voice preset.

        voice_id : typing.Optional[int]
            The existing `voice_id` that will be mapped to the new voice preset.

        reduce_latency : typing.Optional[bool]
            The current `reduce_latency` setting that will be mapped to the new voice preset.

        interruption_threshold : typing.Optional[int]
            The threshold for voice interruption settings.

            If not provided, the default value is `50`.

        language : typing.Optional[str]
            The language code for the voice preset.

        voice_settings : typing.Optional[VoiceSettingsData]
            A JSON object containing specific settings for the voice.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CreateVoicePresetResponse

        Examples
        --------
        from bland import VoiceSettingsData
        from bland.client import BlandAI

        client = BlandAI(
            api_key="YOUR_API_KEY",
        )
        client.voices.create(
            voice_name="string",
            description="string",
            voice_id=1,
            reduce_latency=True,
            interruption_threshold=1,
            language="string",
            voice_settings=VoiceSettingsData(),
        )
        """
        _request: typing.Dict[str, typing.Any] = {"voice_name": voice_name}
        if description is not OMIT:
            _request["description"] = description
        if voice_id is not OMIT:
            _request["voice_id"] = voice_id
        if reduce_latency is not OMIT:
            _request["reduce_latency"] = reduce_latency
        if interruption_threshold is not OMIT:
            _request["interruption_threshold"] = interruption_threshold
        if language is not OMIT:
            _request["language"] = language
        if voice_settings is not OMIT:
            _request["voice_settings"] = voice_settings
        _response = self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/voices"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(CreateVoicePresetResponse, _response.json())  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(
        self,
        voice_preset_id: str,
        *,
        voice_name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        voice_id: typing.Optional[int] = OMIT,
        reduce_latency: typing.Optional[bool] = OMIT,
        interruption_threshold: typing.Optional[int] = OMIT,
        language: typing.Optional[str] = OMIT,
        voice_settings: typing.Optional[VoiceSettingsData] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UpdateVoicePresetResponse:
        """
        Updates the settings for a voice preset.

        Parameters
        ----------
        voice_preset_id : str
            The `id` of the voice preset to update.

            Note: Public voices cannot be altered once published.

        voice_name : typing.Optional[str]
            The name for the new voice preset.

        description : typing.Optional[str]
            A description of the voice preset.

        voice_id : typing.Optional[int]
            The existing `voice_id` that will be mapped to the new voice preset.

        reduce_latency : typing.Optional[bool]
            The current `reduce_latency` setting that will be mapped to the new voice preset.

        interruption_threshold : typing.Optional[int]
            The threshold for voice interruption settings.

            If not provided, the default value is `50`.

            Reset to default by setting to `null`.

        language : typing.Optional[str]
            The language code for the voice preset.

            Reset to default by setting to `null`.

        voice_settings : typing.Optional[VoiceSettingsData]
            A JSON object containing specific settings for the voice.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UpdateVoicePresetResponse

        Examples
        --------
        from bland import VoiceSettingsData
        from bland.client import BlandAI

        client = BlandAI(
            api_key="YOUR_API_KEY",
        )
        client.voices.update(
            voice_preset_id="string",
            voice_name="string",
            description="string",
            voice_id=1,
            reduce_latency=True,
            interruption_threshold=1,
            language="string",
            voice_settings=VoiceSettingsData(),
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if voice_name is not OMIT:
            _request["voice_name"] = voice_name
        if description is not OMIT:
            _request["description"] = description
        if voice_id is not OMIT:
            _request["voice_id"] = voice_id
        if reduce_latency is not OMIT:
            _request["reduce_latency"] = reduce_latency
        if interruption_threshold is not OMIT:
            _request["interruption_threshold"] = interruption_threshold
        if language is not OMIT:
            _request["language"] = language
        if voice_settings is not OMIT:
            _request["voice_settings"] = voice_settings
        _response = self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"v1/voices/${jsonable_encoder(voice_preset_id)}"
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(UpdateVoicePresetResponse, _response.json())  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(
        self, voice_preset_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> DeleteVoicePresetResponse:
        """
        Deletes a voice preset.

        Parameters
        ----------
        voice_preset_id : str
            The unique identifier for the voice preset to be deleted.

            Note:

            - This voice preset must have been created with your account
            - Default or other user's voice presets cannot be deleted.
            - Public voice presets can be deleted, but not modified.
            - This will not delete cloned voice presets, only the original.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DeleteVoicePresetResponse

        Examples
        --------
        from bland.client import BlandAI

        client = BlandAI(
            api_key="YOUR_API_KEY",
        )
        client.voices.delete(
            voice_preset_id="string",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"v1/voices/{jsonable_encoder(voice_preset_id)}/delete"
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))
            if request_options is not None
            else None,
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(DeleteVoicePresetResponse, _response.json())  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def publish(
        self, voice_preset_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> PublishVoicePresetResponse:
        """
        Publishes your voice preset, making it publicly available.

        Parameters
        ----------
        voice_preset_id : str
            The unique identifier for the voice preset to be published.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PublishVoicePresetResponse

        Examples
        --------
        from bland.client import BlandAI

        client = BlandAI(
            api_key="YOUR_API_KEY",
        )
        client.voices.publish(
            voice_preset_id="string",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"v1/voices/{jsonable_encoder(voice_preset_id)}/publish"
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))
            if request_options is not None
            else None,
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(PublishVoicePresetResponse, _response.json())  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def generate(
        self,
        voice_preset_id: str,
        *,
        text: str,
        voice_settings: typing.Optional[VoiceSettingsData] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GenerateVoiceSampleResponse:
        """
        Generates an audio sample from a specified voice preset, with options to override default settings for tuning and testing.

        Parameters
        ----------
        voice_preset_id : str
            The unique identifier for the voice preset to be used for generating the sample.

        text : str
            The text content to be spoken in the voice sample.

            Character limit: `200` characters.

        voice_settings : typing.Optional[VoiceSettingsData]
            Alternate `voice_settings` can be passed in to override the preset's default settings.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GenerateVoiceSampleResponse

        Examples
        --------
        from bland import VoiceSettingsData
        from bland.client import BlandAI

        client = BlandAI(
            api_key="YOUR_API_KEY",
        )
        client.voices.generate(
            voice_preset_id="string",
            text="string",
            voice_settings=VoiceSettingsData(),
        )
        """
        _request: typing.Dict[str, typing.Any] = {"text": text}
        if voice_settings is not OMIT:
            _request["voice_settings"] = voice_settings
        _response = self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"v1/voices/{jsonable_encoder(voice_preset_id)}/sample"
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(GenerateVoiceSampleResponse, _response.json())  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncVoicesClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        *,
        default_only: typing.Optional[bool] = None,
        presets_only: typing.Optional[bool] = None,
        voices_only: typing.Optional[bool] = None,
        is_custom: typing.Optional[bool] = None,
        name: typing.Optional[str] = None,
        voice_name: typing.Optional[str] = None,
        voice_id: typing.Optional[int] = None,
        reduce_latency: typing.Optional[bool] = None,
        public: typing.Optional[bool] = None,
        editable: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListVoiceOptionsResponse:
        """
        Retrieves all available voices for your account, including custom and default presets.

        Parameters
        ----------
        default_only : typing.Optional[bool]
            Filter to show only default presets, excluding user-created presets.

        presets_only : typing.Optional[bool]
            Filter to show only presets.

        voices_only : typing.Optional[bool]
            Filter to show only voices.

        is_custom : typing.Optional[bool]
            Filter for custom voices.

        name : typing.Optional[str]
            Filters the voices array by the name of the voice.

        voice_name : typing.Optional[str]
            Filters the presets array by the name of the voice.

        voice_id : typing.Optional[int]
            Filters the presets array by the ID of the voice.

        reduce_latency : typing.Optional[bool]
            Filter by latency reduction option. Use in tandem with `reduce_latency`to simulate exactly which voice your agent would use.

        public : typing.Optional[bool]
            Filter to show only public presets, or set to `false` to exclude them.

        editable : typing.Optional[bool]
            Filter to show only editable presets.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListVoiceOptionsResponse

        Examples
        --------
        from bland.client import AsyncBlandAI

        client = AsyncBlandAI(
            api_key="YOUR_API_KEY",
        )
        await client.voices.list(
            default_only=True,
            presets_only=True,
            voices_only=True,
            is_custom=True,
            name="string",
            voice_name="string",
            voice_id=1,
            reduce_latency=True,
            public=True,
            editable=True,
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/voices"),
            params=jsonable_encoder(
                remove_none_from_dict(
                    {
                        "default_only": default_only,
                        "presets_only": presets_only,
                        "voices_only": voices_only,
                        "is_custom": is_custom,
                        "name": name,
                        "voice_name": voice_name,
                        "voice_id": voice_id,
                        "reduce_latency": reduce_latency,
                        "public": public,
                        "editable": editable,
                        **(
                            request_options.get("additional_query_parameters", {})
                            if request_options is not None
                            else {}
                        ),
                    }
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(ListVoiceOptionsResponse, _response.json())  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def retrieve(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> RetrieveVoicePresetResponse:
        """
        Retrieves detailed information about a voice preset for the given id.

        Parameters
        ----------
        id : str
            The unique identifier for the voice preset.

            Used within your call like `voice: "ff2c405b-3dba-41e0-9261-bc8ee3f91f46"` instead of `voice_id: ..., reduce_latency: ...`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        RetrieveVoicePresetResponse

        Examples
        --------
        from bland.client import AsyncBlandAI

        client = AsyncBlandAI(
            api_key="YOUR_API_KEY",
        )
        await client.voices.retrieve(
            id="string",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v1/voices/{jsonable_encoder(id)}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(RetrieveVoicePresetResponse, _response.json())  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create(
        self,
        *,
        voice_name: str,
        description: typing.Optional[str] = OMIT,
        voice_id: typing.Optional[int] = OMIT,
        reduce_latency: typing.Optional[bool] = OMIT,
        interruption_threshold: typing.Optional[int] = OMIT,
        language: typing.Optional[str] = OMIT,
        voice_settings: typing.Optional[VoiceSettingsData] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateVoicePresetResponse:
        """
        Creates a new voice preset by bundling various voice settings into one entity.

        Parameters
        ----------
        voice_name : str
            The name for the new voice preset.

        description : typing.Optional[str]
            A description of the voice preset.

        voice_id : typing.Optional[int]
            The existing `voice_id` that will be mapped to the new voice preset.

        reduce_latency : typing.Optional[bool]
            The current `reduce_latency` setting that will be mapped to the new voice preset.

        interruption_threshold : typing.Optional[int]
            The threshold for voice interruption settings.

            If not provided, the default value is `50`.

        language : typing.Optional[str]
            The language code for the voice preset.

        voice_settings : typing.Optional[VoiceSettingsData]
            A JSON object containing specific settings for the voice.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CreateVoicePresetResponse

        Examples
        --------
        from bland import VoiceSettingsData
        from bland.client import AsyncBlandAI

        client = AsyncBlandAI(
            api_key="YOUR_API_KEY",
        )
        await client.voices.create(
            voice_name="string",
            description="string",
            voice_id=1,
            reduce_latency=True,
            interruption_threshold=1,
            language="string",
            voice_settings=VoiceSettingsData(),
        )
        """
        _request: typing.Dict[str, typing.Any] = {"voice_name": voice_name}
        if description is not OMIT:
            _request["description"] = description
        if voice_id is not OMIT:
            _request["voice_id"] = voice_id
        if reduce_latency is not OMIT:
            _request["reduce_latency"] = reduce_latency
        if interruption_threshold is not OMIT:
            _request["interruption_threshold"] = interruption_threshold
        if language is not OMIT:
            _request["language"] = language
        if voice_settings is not OMIT:
            _request["voice_settings"] = voice_settings
        _response = await self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/voices"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(CreateVoicePresetResponse, _response.json())  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self,
        voice_preset_id: str,
        *,
        voice_name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        voice_id: typing.Optional[int] = OMIT,
        reduce_latency: typing.Optional[bool] = OMIT,
        interruption_threshold: typing.Optional[int] = OMIT,
        language: typing.Optional[str] = OMIT,
        voice_settings: typing.Optional[VoiceSettingsData] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UpdateVoicePresetResponse:
        """
        Updates the settings for a voice preset.

        Parameters
        ----------
        voice_preset_id : str
            The `id` of the voice preset to update.

            Note: Public voices cannot be altered once published.

        voice_name : typing.Optional[str]
            The name for the new voice preset.

        description : typing.Optional[str]
            A description of the voice preset.

        voice_id : typing.Optional[int]
            The existing `voice_id` that will be mapped to the new voice preset.

        reduce_latency : typing.Optional[bool]
            The current `reduce_latency` setting that will be mapped to the new voice preset.

        interruption_threshold : typing.Optional[int]
            The threshold for voice interruption settings.

            If not provided, the default value is `50`.

            Reset to default by setting to `null`.

        language : typing.Optional[str]
            The language code for the voice preset.

            Reset to default by setting to `null`.

        voice_settings : typing.Optional[VoiceSettingsData]
            A JSON object containing specific settings for the voice.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UpdateVoicePresetResponse

        Examples
        --------
        from bland import VoiceSettingsData
        from bland.client import AsyncBlandAI

        client = AsyncBlandAI(
            api_key="YOUR_API_KEY",
        )
        await client.voices.update(
            voice_preset_id="string",
            voice_name="string",
            description="string",
            voice_id=1,
            reduce_latency=True,
            interruption_threshold=1,
            language="string",
            voice_settings=VoiceSettingsData(),
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if voice_name is not OMIT:
            _request["voice_name"] = voice_name
        if description is not OMIT:
            _request["description"] = description
        if voice_id is not OMIT:
            _request["voice_id"] = voice_id
        if reduce_latency is not OMIT:
            _request["reduce_latency"] = reduce_latency
        if interruption_threshold is not OMIT:
            _request["interruption_threshold"] = interruption_threshold
        if language is not OMIT:
            _request["language"] = language
        if voice_settings is not OMIT:
            _request["voice_settings"] = voice_settings
        _response = await self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"v1/voices/${jsonable_encoder(voice_preset_id)}"
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(UpdateVoicePresetResponse, _response.json())  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(
        self, voice_preset_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> DeleteVoicePresetResponse:
        """
        Deletes a voice preset.

        Parameters
        ----------
        voice_preset_id : str
            The unique identifier for the voice preset to be deleted.

            Note:

            - This voice preset must have been created with your account
            - Default or other user's voice presets cannot be deleted.
            - Public voice presets can be deleted, but not modified.
            - This will not delete cloned voice presets, only the original.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DeleteVoicePresetResponse

        Examples
        --------
        from bland.client import AsyncBlandAI

        client = AsyncBlandAI(
            api_key="YOUR_API_KEY",
        )
        await client.voices.delete(
            voice_preset_id="string",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"v1/voices/{jsonable_encoder(voice_preset_id)}/delete"
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))
            if request_options is not None
            else None,
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(DeleteVoicePresetResponse, _response.json())  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def publish(
        self, voice_preset_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> PublishVoicePresetResponse:
        """
        Publishes your voice preset, making it publicly available.

        Parameters
        ----------
        voice_preset_id : str
            The unique identifier for the voice preset to be published.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PublishVoicePresetResponse

        Examples
        --------
        from bland.client import AsyncBlandAI

        client = AsyncBlandAI(
            api_key="YOUR_API_KEY",
        )
        await client.voices.publish(
            voice_preset_id="string",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"v1/voices/{jsonable_encoder(voice_preset_id)}/publish"
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))
            if request_options is not None
            else None,
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(PublishVoicePresetResponse, _response.json())  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def generate(
        self,
        voice_preset_id: str,
        *,
        text: str,
        voice_settings: typing.Optional[VoiceSettingsData] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GenerateVoiceSampleResponse:
        """
        Generates an audio sample from a specified voice preset, with options to override default settings for tuning and testing.

        Parameters
        ----------
        voice_preset_id : str
            The unique identifier for the voice preset to be used for generating the sample.

        text : str
            The text content to be spoken in the voice sample.

            Character limit: `200` characters.

        voice_settings : typing.Optional[VoiceSettingsData]
            Alternate `voice_settings` can be passed in to override the preset's default settings.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GenerateVoiceSampleResponse

        Examples
        --------
        from bland import VoiceSettingsData
        from bland.client import AsyncBlandAI

        client = AsyncBlandAI(
            api_key="YOUR_API_KEY",
        )
        await client.voices.generate(
            voice_preset_id="string",
            text="string",
            voice_settings=VoiceSettingsData(),
        )
        """
        _request: typing.Dict[str, typing.Any] = {"text": text}
        if voice_settings is not OMIT:
            _request["voice_settings"] = voice_settings
        _response = await self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"v1/voices/{jsonable_encoder(voice_preset_id)}/sample"
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(GenerateVoiceSampleResponse, _response.json())  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic_v1.parse_obj_as(ErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
