# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

from ...core.datetime_utils import serialize_datetime
from ...core.pydantic_utilities import pydantic_v1
from .answered_by_enum import AnsweredByEnum
from .transcript import Transcript


class CallDetailsResponse(pydantic_v1.BaseModel):
    transcripts: typing.List[Transcript] = pydantic_v1.Field()
    """
    An array of phrases spoken during the call.
    """

    variables: typing.Dict[str, str] = pydantic_v1.Field()
    """
    Variables created during the call - both system variables as well as generated with `dynamic_data`.
    
    For example, if you used a `dynamic_data` API request to generate a variable called `appointment_time`, you would see it here.
    """

    concatenated_transcript: str = pydantic_v1.Field()
    """
    A single string containing all of the text from the call. Excludes system messages and auto-generated data.
    """

    to: str = pydantic_v1.Field()
    """
    The phone number that received the call.
    """

    from_: str = pydantic_v1.Field(alias="from")
    """
    The phone number that made the call.
    """

    batch_id: str = pydantic_v1.Field()
    """
    If the call is part of a batch, it's batch_id will be here.
    """

    request_data: typing.Dict[str, str] = pydantic_v1.Field()
    """
    Details about parameters in the original api request.
    """

    completed: bool = pydantic_v1.Field()
    """
    Whether the call has been completed. If it differs from the value of `queue_status`, this will be the most up-to-date status.
    """

    queue_status: str = pydantic_v1.Field()
    """
    The status of the call. During extremely high volume periods, calls may be queued for a short period of time before being dispatched.
    
    Progresses through the following stages -
    
    - `new` - An API request has been received.
    - `queued` - Call pararameters have been validated and authentication succeeded.
    - `allocated` - Extremely brief, the call is being dispatched.
    - `started` - The phone call is live and in progress.
    - `complete` - The phone call has ended successfully.
    
    The following statuses show the point that was reached before an error -
    
    - `pre_queue_error` - An error occurred before the call was queued. Invalid parameters generally cause this.
    - `queue_error` - Error occurred while the call was queued. Ex. Valid phone number but to an unserviced area.
    - `call_error` - Error occurred during live call. May be caused by transferring to an invalid phone number or an unforeseen error.
    - `complete_error` - Error occurred after the call was completed. Ex. A post-call webhook failed.
    
    If at any point an error occurs, it will be recorded in the `error_message` field.
    """

    error_message: str = pydantic_v1.Field()
    """
    If an error occurs, this will contain a description of the error. Otherwise, it will be null.
    """

    answered_by: AnsweredByEnum = pydantic_v1.Field()
    """
    If `answered_by_enabled` was set to `true` in the original API request, this field contains one of the following values:
    
    - `human`: The call was answered by a human.
    - `voicemail`: The call was answered by an answering machine or voicemail.
    - `unknown`: There was not enough audio at the start of the call to make a determination.
    - `no-answer`: The call was not answered.
    - `null`: Not enabled, or still processing the result.
    """

    endpoint_url: str = pydantic_v1.Field()
    """
    The URL that was called to dispatch the phone call.
    """

    max_duration: float = pydantic_v1.Field()
    """
    The maximum length of time the call was allowed to last. If the call would exceed this length, it's ended early.
    """

    corrected_duration: float = pydantic_v1.Field()
    """
    The total length of time the call was connected. This differs from `call_length` in that it includes ringing and connection time.
    """

    call_length: float = pydantic_v1.Field()
    """
    The length of the call in minutes.
    """

    created_at: dt.datetime = pydantic_v1.Field()
    """
    The timestamp for when the call was dispatched.
    """

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().dict(**kwargs_with_defaults)

    class Config:
        frozen = True
        smart_union = True
        allow_population_by_field_name = True
        populate_by_name = True
        extra = pydantic_v1.Extra.allow
        json_encoders = {dt.datetime: serialize_datetime}
