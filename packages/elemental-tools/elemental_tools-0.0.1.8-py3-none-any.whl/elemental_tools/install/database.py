# Database Installation or Update Procedures
import os.path
from typing import Union, List

from icecream import ic
from sqlalchemy import MetaData

from elemental_tools.api import controllers
from elemental_tools.asserts import root_ref, _autogenerated_root_ref

from elemental_tools.exceptions import InternalException, SettingMissing
from elemental_tools.install import datasets
from elemental_tools.install.raw_sql import DDL
from elemental_tools.settings import SettingController

from elemental_tools.settings import SettingSchema

from elemental_tools.db import SQLModel, Connect, inspect, text, database_extensions
from elemental_tools.install.datasets import install_dataset, newest_version_available
from elemental_tools.logger import Logger

from elemental_tools.config import config_initializer

config = config_initializer()


class InstallDatabase:
    __logger__ = Logger(app_name=config.app_name, owner='installation', origin='database').log

    class SettingsInstaller:

        __logger__ = Logger(app_name=config.app_name, owner='database', origin='setting-installer').log

        def __init__(self, _settings: SettingController = SettingController()):
            self.__settings_controller__ = _settings

        def check(self, ignore: Union[List, None] = None):
            self.__logger__("start", "Checking for datasets upgrade...")
            if ignore is None:
                ignore = ['root_ref']

            for _name, _value in vars(self.__settings_controller__).items():
                if _name not in ignore:
                    if isinstance(_value, SettingSchema):
                        if _name.startswith("_"):
                            continue
                        try:
                            self.__logger__('info', f"Checking Setting: {_name}")
                            getattr(self.__settings_controller__, _name).get(root_ref(), _name, ignore_default=True)
                            self.__logger__('success', f"Setting Already Exists")
                        except SettingMissing:
                            self.__logger__('alert',
                                            f"Default configuration: {_name} was not found at settings database.")
                            try:
                                self.__logger__('installing', f"Installing {_name}...")
                                getattr(self.__settings_controller__, _name).set(root_ref(),
                                                                                 getattr(self.__settings_controller__,
                                                                                         _name).value)
                                self.__logger__('success', f"Setting {_name} Installed")
                            except Exception as e:
                                raise Exception(
                                    f'Default configuration {_name} was not set, please reinstall or update.')

            self.__logger__("success", "Database Successfully Checked!")

    def install(self):
        self.__logger__("info", f"Starting Database Upgrade...")
        datasets_root_path = os.path.dirname(datasets.__file__)
        dataset_ext = 'json'

        with self.engine.connect() as connection:
            self.__logger__("info", f"Applying Database Extensions")
            for ext_name in database_extensions:
                connection.execute(text(f'CREATE EXTENSION IF NOT EXISTS {ext_name}'))
                connection.commit()

        SQLModel.metadata.create_all(self.engine)

        settings_controller = SettingController()

        database_version = settings_controller.database_version.get(root_ref())

        if newest_version_available() > database_version:
            self.__logger__("alert", "Database being updated, please do a double check for consistency.")

            for table in self.get_table_names():
                dataset_path = os.path.join(datasets_root_path, f"{table}.{dataset_ext}")
                self.__logger__("info", f"Loading dataset: {dataset_path}")
                if os.path.isfile(dataset_path):
                    self.__logger__("info", f"Installing: {dataset_path}")
                    install_dataset(self.session, dataset_path, table)
                    self.__logger__("success", f"Installed!")

        self.SettingsInstaller().check()
        if root_ref() == _autogenerated_root_ref:
            settings_controller.root_ref.set(None, root_ref())

        self.__logger__("success", f"Database upgrade finish successfully!")
        settings_controller.database_version.set(root_ref(), newest_version_available())

    def __init__(self):
        try:
            self.connection = Connect(config.db_url, config.db_name)
            self.engine = self.connection.engine
            self.session = self.connection.session
            self.inspector = inspect(self.engine)
            self.get_table_names = self.inspector.get_table_names

        except TypeError:
            raise InternalException(f"Failed to Connect to DB: {config.db_name} on {config.db_url}")

        self.install()
        ddl_installer = DDL(self.session)
        ddl_installer()


class UninstallDatabase:
    __logger__ = Logger(app_name="database", owner="uninstall", origin=config.app_name).log

    def __init__(self):
        try:
            self.connection = Connect()
            self.engine = self.connection.engine
            self.session = self.connection.session
            self.inspector = inspect(self.engine)
            self.get_table_names = self.inspector.get_table_names

        except TypeError:
            raise InternalException(f"Failed to Connect to DB: {config.db_name} on {config.db_url}")

        user_input = None
        while not user_input == "yes":
            self.__logger__("alert",
                            f"""Please type "yes" to allow the test to clear database and rebuild it.\n\nOr Press "CTRL+C" to Quit""",
                            clean=True)

            user_input = input()

        self.uninstall()

    def uninstall(self):

        # Reflect the existing database tables
        metadata = MetaData()
        metadata.reflect(bind=self.engine)

        # Drop each table

        for table in reversed(metadata.sorted_tables):
            table.drop(self.engine)

        # Commit the changes
        self.engine.dispose()
