# AUTOGENERATED! DO NOT EDIT! File to edit: ../../../nbs/agents/benchmark_agents/12_Dual_Sourcing_Agents.ipynb.

# %% auto 0
__all__ = ['DualSourcingBaseAgent', 'SingleIndexAgent', 'DualIndexAgent', 'CappedDualIndexAgent', 'SingleIndexPolicy',
           'DualIndexPolicy', 'CappedDualIndexPolicy']

# %% ../../../nbs/agents/benchmark_agents/12_Dual_Sourcing_Agents.ipynb 4
# General libraries:
import numpy as np
from scipy.stats import norm
from tqdm import tqdm

# Mushroom libraries
from mushroom_rl.core import Agent

import time

# %% ../../../nbs/agents/benchmark_agents/12_Dual_Sourcing_Agents.ipynb 6
class DualSourcingBaseAgent(Agent):

    def fit(self, features = None, demand=None, mask=None):

        """ 
        xxx
        """

        assert isinstance(demand, np.ndarray)
        assert demand.ndim == 2

        self.policy.set_params(demand, self._preprocessors[0])


class SingleIndexAgent(DualSourcingBaseAgent):

    """
    xxx

    """

    def __init__(self,
                  mdp_info,
                  mdp,
                  l, # lead time
                  l_e, # expedited lead time
                  unit_size = 0.01,
                  preprocessors = None,
                  postprocessors = None,
                  agent_name = None,
                  precision = 5,
                  num_iterations_per_parameter = 12,
                  algorithm = "brute_0_1", 
                  full_grid=False,# "brute_0_1": brute force for demand between 0 and 1 and unit-size <1, "brute_variable": brute force for demand large 1 and unit size 1 
                  #search_space = 3 # applies only for brute_variable - grid size in multiple of average demand
        ):

        mdp._mdp_info.horizon = mdp.demand.shape[0]
        mdp.reset(0)

        policy = SingleIndexPolicy(
            l = l,
            l_e = l_e,
            mdp = mdp,
            unit_size = unit_size,
            preprocessors = preprocessors,
            postprocessors = postprocessors,
            num_iterations_per_parameter = num_iterations_per_parameter,
            algorithm = algorithm,
            full_grid = full_grid,
            #search_space = search_space
        )

        self.precision=precision

        if agent_name is None:
            self.name = 'Single_Index_Agent'
        else:
            self.name = agent_name
        
        self.train_directly=True
        self.train_mode = "direct"

        super().__init__(mdp_info, policy)

class DualIndexAgent(DualSourcingBaseAgent):

    """
    xxx

    """

    def __init__(self,
                  mdp_info,
                  mdp,
                  l, # lead time
                  l_e, # expedited lead time
                  unit_size = 0.01,
                  preprocessors = None,
                  postprocessors = None,
                  agent_name = None,
                  precision = 5,
                  num_iterations_per_parameter = 12,
                  algorithm = "brute_0_1",
                  full_grid=False, # "brute_0_1": brute force for demand between 0 and 1 and unit-size <1, "brute_variable": brute force for demand large 1 and unit size 1 
                  return_levels=False,
                  #search_space = 3 # applies only for brute_variable - grid size in multiple of average demand
        ):

        mdp._mdp_info.horizon = mdp.demand.shape[0]
        mdp.reset(0)

        policy = DualIndexPolicy(
            l = l,
            l_e = l_e,
            mdp = mdp,
            unit_size = unit_size,
            preprocessors = preprocessors,
            postprocessors = postprocessors,
            num_iterations_per_parameter = num_iterations_per_parameter,
            algorithm = algorithm,
            full_grid = full_grid,
            return_levels = return_levels,
            #search_space = search_space
        )

        if agent_name is None:
            self.name = 'Dual_Index_Agent'
        else:
            self.name = agent_name
        
        self.train_directly=True
        self.train_mode = "direct"

        super().__init__(mdp_info, policy)

class CappedDualIndexAgent(DualSourcingBaseAgent):

    """
    xxx

    """

    def __init__(self,
                  mdp_info,
                  mdp,
                  l, # lead time
                  l_e, # expedited lead time
                  unit_size = 0.01,
                  preprocessors = None,
                  postprocessors = None,
                  agent_name = None,
                  precision = 5,
                  num_iterations_per_parameter = 12,
                  algorithm = "brute_0_1",
                  full_grid=False, # "brute_0_1": brute force for demand between 0 and 1 and unit-size <1, "brute_variable": brute force for demand large 1 and unit size 1 
                  return_levels=False,
                  #search_space = 3 # applies only for brute_variable - grid size in multiple of average demand
        ):

        mdp._mdp_info.horizon = mdp.demand.shape[0]
        mdp.reset(0)

        policy = CappedDualIndexPolicy(
            l = l,
            l_e = l_e,
            mdp = mdp,
            unit_size = unit_size,
            preprocessors = preprocessors,
            postprocessors = postprocessors,
            num_iterations_per_parameter = num_iterations_per_parameter,
            algorithm = algorithm,
            full_grid = full_grid,
            #search_space = search_space
        )

        self.precision=precision

        if agent_name is None:
            self.name = 'Capped_Dual_Index_Agent'
        else:
            self.name = agent_name
        
        self.train_directly=True
        self.train_mode = "direct"

        super().__init__(mdp_info, policy)


class SingleIndexPolicy():

    """
    xxx
    """

    def __init__(self,
                 l, 
                 l_e, 
                 mdp,
                 unit_size = 0.01,
                 preprocessors = None,
                 postprocessors = None,
                 num_iterations_per_parameter = 12,
                 algorithm = "brute_0_1", 
                 full_grid = False,# "brute_0_1": brute force for demand between 0 and 1 and unit-size <1, "brute_0_1": brute force for demand large 1 and unit size 1
                 ):
        self.l = l
        self.l_e = l_e
        self.unit_size = unit_size
        self.num_products = len(l)

        if preprocessors is None:
            self.preprocessors = []
        else:
            self.preprocessors = preprocessors
        if postprocessors is None:
            self.postprocessors = []
        else:
            self.postprocessors = postprocessors

        self.mdp = mdp

        self.num_iterations_per_parameter = num_iterations_per_parameter

        self.S = 0.5 #0.5 # initial value
        self.S_e = 0.5 #0.5 # initial value

        self.algorithm = algorithm

        self.full_grid = full_grid
    
    def set_and_calculate_grid(self, S, S_e, step_size, full_grid=False, plot=False,):
        


        if full_grid:
            S_candidates = np.arange(0, 1+step_size, step_size)
            S_e_candidates = np.arange(0, 1+step_size, step_size)
            
        else:

            S_candidates = np.arange(S-step_size*self.num_iterations_per_parameter, S+step_size*(self.num_iterations_per_parameter+1), step_size)
            S_e_candidates = np.arange(S_e-step_size*self.num_iterations_per_parameter, S_e+step_size*(self.num_iterations_per_parameter+1), step_size)

            # only use positive or zero candidates
            S_candidates = S_candidates[S_candidates >= 0]
            S_e_candidates = S_e_candidates[S_e_candidates >= 0]

        print("base S:", S)
        print("base S_e:", S_e)
        print("S candidates:", S_candidates)
        print("S_e candidates:", S_e_candidates)

        best_S, best_S_e, best_cost, _ = self.calculate_grid(S_candidates, S_e_candidates)

        return best_S, best_S_e, best_cost

    def calculate_grid(self, S_candidates, S_e_candidates):
    
        cost_matrix = np.zeros((len(S_candidates), len(S_e_candidates)))

        for i, S_candidate in enumerate(S_candidates):
            for j, S_e_candidate in enumerate(S_e_candidates):
                if S_e_candidate > S_candidate:
                    cost_value = np.inf
                else:
                    cost_value = self.run_simulation(S_candidate, S_e_candidate)

                cost_matrix[i, j] = cost_value
                print("S:", np.round(S_candidate,2), "S_e:", np.round(S_e_candidate,2), "cost:", np.round(cost_value))

        best_cost = np.min(cost_matrix)
        best_S_index, best_S_e_index = np.unravel_index(np.argmin(cost_matrix), cost_matrix.shape)
        best_S = S_candidates[best_S_index]
        best_S_e = S_e_candidates[best_S_e_index]

        print("max S index:", len(S_candidates), "best S index:", best_S_index)
        print("max S_e index:", len(S_e_candidates), "best S_e index:", best_S_e_index)

        print("best S and S_e:", best_S, best_S_e)

        if best_S_index == 0 or best_S_index == len(S_candidates)-1:
            warn_edge = True
        elif best_S_e_index == 0 or best_S_e_index == len(S_e_candidates)-1:
            warn_edge = True
        else:
            warn_edge = False
        
        if warn_edge:
            print("Warning: Optimal value at the edge of search space")

        return best_S, best_S_e, best_cost, warn_edge

    def run_simulation(self, S, S_e):

        total_cost = 0

        state = self.mdp.reset(0)

        for t in range(self.mdp.info.horizon):

            state = self.preprocessor(state)
            action = self.draw_action_train(state, S, S_e)
                
            state, reward, _, _ = self.mdp.step(action)
            
            total_cost += -reward

        return total_cost

    def set_params(self, demand, preprocessor):
        
        """
        Set the optimal order quantity (q_star) for each product.

        This method calculates and assigns the optimal order quantity based on the EOQ formula.

        Returns:
            None

        """

        self.preprocessor = preprocessor

        if self.algorithm == "brute_0_1":

            if self.full_grid:
                self.S, self.S_e, cost = self.set_and_calculate_grid(self.S, self.S_e, step_size = self.unit_size, full_grid=True)
                print("result:", "S:", self.S, "S_e:", self.S_e, "cost:", cost)
            else:
                self.S, self.S_e, cost = self.set_and_calculate_grid(self.S, self.S_e, step_size = self.unit_size*10)
                print("iteration 1:", "S:", self.S, "S_e:", self.S_e, "cost:", cost)
                self.S, self.S_e, cost = self.set_and_calculate_grid(self.S, self.S_e, step_size = self.unit_size*3)
                print("iteration 2:", "S:", self.S, "S_e:", self.S_e, "cost:", cost)
                self.S, self.S_e, cost = self.set_and_calculate_grid(self.S, self.S_e, step_size = self.unit_size)
                print("iteration 3:", "S:", self.S, "S_e:", self.S_e, "cost:", cost)
        
        elif self.algorithm == "brute_variable":
            # rais not implemented

            raise NotImplementedError("only implemented for values normalized between 0 and 1")


            # self.run_brute_variable(demand)
        
        else:
            # error
            raise ValueError("Algorithm unknown")
    
    

    def draw_action(self, input):

        """
        Generate an action based on the current state.

        # TODO adjust description

        Returns zero for products which have still sufficient inventory, and the optimal order quantity for products which are running out of stock.

        Parameters:
            input (numpy.ndarray): The current inventory level and potentially order pipeline for each product.

        Returns:
            numpy.ndarray: The action to be taken, indicating the quantity to order for each product.

        """

        for preprocessor in self.preprocessors:
            input = preprocessor(input)
        
        # print("input")
        total_inventory_position = np.sum(input)
        # print(total_inventory_position)
        if total_inventory_position < self.S_e:
            q_e = self.S_e - total_inventory_position
            q = self.S-self.S_e
        elif total_inventory_position < self.S:
            q_e=0
            q = self.S - total_inventory_position
        else:
            q_e=0
            q = 0

        # print("q", q, "q_e", q_e)
        action = np.array([q, q_e])

        for postprocessor in self.postprocessors:
            action = postprocessor(action)

        return action
    
    def draw_action_train(self, input, S, S_e):

        """
        Generate an action based on the current state.

        # TODO adjust description

        Returns zero for products which have still sufficient inventory, and the optimal order quantity for products which are running out of stock.

        Parameters:
            input (numpy.ndarray): The current inventory level and potentially order pipeline for each product.

        Returns:
            numpy.ndarray: The action to be taken, indicating the quantity to order for each product.

        """

        for preprocessor in self.preprocessors:
            input = preprocessor(input)

        total_inventory_position = np.sum(input)
        if total_inventory_position < S_e:
            q_e = S_e - total_inventory_position
            q = S-S_e
        elif total_inventory_position < S:
            q_e=0
            q = S - total_inventory_position 
        else:
            q_e=0
            q = 0 

        action = np.array([q, q_e])

        for postprocessor in self.postprocessors:
            action = postprocessor(action)

        return action
    
    def reset(self):
        pass

class DualIndexPolicy(SingleIndexPolicy):

    """
    xxx
    """

    def __init__(self,
                 l, 
                 l_e, 
                 mdp,
                 unit_size = 0.01,
                 preprocessors = None,
                 postprocessors = None,
                 num_iterations_per_parameter = 12,
                 algorithm = "brute_0_1", # "brute_0_1": brute force for demand between 0 and 1 and unit-size <1, "brute_0_1": brute force for demand large 1 and unit size 1
                 full_grid = False,
                 return_levels = False
                 ):
        
        self.return_levels = return_levels
        
        super().__init__(l, l_e, mdp, unit_size, preprocessors, postprocessors, num_iterations_per_parameter, algorithm, full_grid)
    
    def draw_action(self, input):
        
        """
        Generate an action based on the current state.

        # TODO adjust description

        Returns zero for products which have still sufficient inventory, and the optimal order quantity for products which are running out of stock.

        Parameters:
            input (numpy.ndarray): The current inventory level and potentially order pipeline for each product.

        Returns:
            numpy.ndarray: The action to be taken, indicating the quantity to order for each product.

        """

        for preprocessor in self.preprocessors:
            input = preprocessor(input)

        total_inventory_position = np.sum(input)
        expedited_inventory_position = input[0]+np.sum(input[-self.l_e[0]:]) # first position is inventory, rest is pipeline vector # only single-product case (one l_e)

        # print(input[0], input[1:])
        # print("total_inventory_position:", total_inventory_position)
        # print("expedited_inventory_position:", expedited_inventory_position)

        if expedited_inventory_position < self.S_e:
            q_e = self.S_e - expedited_inventory_position
            q = np.maximum(self.S-total_inventory_position-q_e,0)
        elif total_inventory_position < self.S:
            q_e=0
            q = self.S - total_inventory_position 
        else:
            q_e=0
            q = 0

        action = np.array([q, q_e])

        for postprocessor in self.postprocessors:
            action = postprocessor(action)
        
        #TEMP:
        action = np.round(action, 2)

        if self.return_levels:
            action = np.array([self.S, self.S_e])

        return action

    def draw_action_train(self, input, S, S_e):

        """
        Generate an action based on the current state.

        # TODO adjust description

        Returns zero for products which have still sufficient inventory, and the optimal order quantity for products which are running out of stock.

        Parameters:
            input (numpy.ndarray): The current inventory level and potentially order pipeline for each product.

        Returns:
            numpy.ndarray: The action to be taken, indicating the quantity to order for each product.

        """

        for preprocessor in self.preprocessors:
            input = preprocessor(input)

        total_inventory_position = np.sum(input)
        expedited_inventory_position = input[0]+np.sum(input[-self.l_e[0]:]) # first position is inventory, rest is pipeline vector # only single-product case (one l_e)

        if expedited_inventory_position < S_e:
            q_e = S_e - expedited_inventory_position
            q = np.maximum(S-total_inventory_position-q_e,0)
        elif total_inventory_position < S:
            q_e=0
            q = S - total_inventory_position 
        else:
            q_e=0
            q = 0

        action = np.array([q, q_e])

        for postprocessor in self.postprocessors:
            action = postprocessor(action)  

        #TEMP:
        action = np.round(action, 2)

        if self.return_levels:
            action = np.array([S, S_e])

        return action

class CappedDualIndexPolicy(SingleIndexPolicy):

    """
    xxx
    """

    def __init__(self,
                 l, 
                 l_e, 
                 mdp,
                 unit_size = 0.01,
                 preprocessors = None,
                 postprocessors = None,
                 num_iterations_per_parameter = 12,
                 algorithm = "brute_0_1", # "brute_0_1": brute force for demand between 0 and 1 and unit-size <1, "brute_0_1": brute force for demand large 1 and unit size 1
                 full_grid = False,
                 precision = 5,
                 ):
        
        self.cap = 0.5
        self.precision = precision
        
        super().__init__(l, l_e, mdp, unit_size, preprocessors, postprocessors, num_iterations_per_parameter, algorithm, full_grid)
    
    def set_and_calculate_grid(self, S, S_e, cap, step_size, full_grid=False, plot=False,):

        if full_grid:
            S_candidates = np.arange(0, 1+step_size, step_size)
            S_e_candidates = np.arange(0, 1+step_size, step_size)
            cap_candidates = np.arange(0, 1+step_size, step_size)
            
        else:
            S_candidates = np.arange(S-step_size*self.num_iterations_per_parameter, S+step_size*(self.num_iterations_per_parameter+1), step_size)
            S_e_candidates = np.arange(S_e-step_size*self.num_iterations_per_parameter, S_e+step_size*(self.num_iterations_per_parameter+1), step_size)
            cap_candidates = np.arange(cap-step_size*self.num_iterations_per_parameter, cap+step_size*(self.num_iterations_per_parameter+1), step_size)

            # only use positive or zero candidates
            S_candidates = S_candidates[S_candidates >= 0]
            S_e_candidates = S_e_candidates[S_e_candidates >= 0]
            cap_candidates = cap_candidates[cap_candidates >= 0]

        print("base S:", S)
        print("base S_e:", S_e)
        print("base cap:", cap)
        print("S candidates:", S_candidates)
        print("S_e candidates:", S_e_candidates)
        print("cap candidates:", cap_candidates)

        best_S, best_S_e, best_cap, best_cost, _ = self.calculate_grid(S_candidates, S_e_candidates, cap_candidates)

        return best_S, best_S_e, best_cap, best_cost
    
    def calculate_grid(self, S_candidates, S_e_candidates, cap_candidates):
    
        cost_matrix = np.zeros((len(S_candidates), len(S_e_candidates), len(cap_candidates)))

        for i, S_candidate in enumerate(S_candidates):
            for j, S_e_candidate in enumerate(S_e_candidates):
                for k, cap_candidate in enumerate(cap_candidates):
                    if S_e_candidate > S_candidate:
                        cost_value = np.inf
                    else:
                        cost_value = self.run_simulation(S_candidate, S_e_candidate, cap_candidate)
                    cost_matrix[i, j, k] = cost_value
                    print("S:", np.round(S_candidate,2), "S_e:", np.round(S_e_candidate,2), "cap:", np.round(cap_candidate,2), "cost:", np.round(cost_value))

        best_cost = np.min(cost_matrix)
        best_S_index, best_S_e_index, best_cap_index = np.unravel_index(np.argmin(cost_matrix), cost_matrix.shape)
        best_S = S_candidates[best_S_index]
        best_S_e = S_e_candidates[best_S_e_index]
        best_cap = cap_candidates[best_cap_index]

        print("max S index:", len(S_candidates), "best S index:", best_S_index)
        print("max S_e index:", len(S_e_candidates), "best S_e index:", best_S_e_index)
        print("max cap index:", len(cap_candidates), "best cap index:", best_cap_index)

        print("best S, S_e and cap:", best_S, best_S_e, best_cap)

        if best_S_index == 0 or best_S_index == len(S_candidates)-1:
            warn_edge = True
        elif best_S_e_index == 0 or best_S_e_index == len(S_e_candidates)-1:
            warn_edge = True
        elif best_cap_index == 0 or best_cap_index == len(cap_candidates)-1:
            warn_edge = True
        else:
            warn_edge = False
        
        if warn_edge:
            print("Warning: Optimal value at the edge of search space")

        return best_S, best_S_e, best_cap, best_cost, warn_edge

    def run_simulation(self, S, S_e, cap):

        total_cost = 0

        state = self.mdp.reset(0)

        for t in range(self.mdp.info.horizon):

            state = self.preprocessor(state)
            action = self.draw_action_train(state, S, S_e, cap)
                
            state, reward, _, _ = self.mdp.step(action)
            
            total_cost += -reward

        return total_cost
    
    def set_and_calculate_grid(self, S, S_e, cap, step_size, plot=False, full_grid=True):

        S_candidates = np.arange(S-step_size*self.num_iterations_per_parameter, S+step_size*(self.num_iterations_per_parameter+1), step_size)
        S_e_candidates = np.arange(S_e-step_size*self.num_iterations_per_parameter, S_e+step_size*(self.num_iterations_per_parameter+1), step_size)
        cap_candidates = np.arange(cap-step_size*self.num_iterations_per_parameter, cap+step_size*(self.num_iterations_per_parameter+1), step_size)

        if full_grid:
            S_candidates = np.arange(0, 1+step_size, step_size)
            S_e_candidates = np.arange(0, 1+step_size, step_size)
            cap_candidates = np.arange(0, 1+step_size, step_size)

        # only use positive or zero candidates
        S_candidates = S_candidates[S_candidates >= 0]
        S_e_candidates = S_e_candidates[S_e_candidates >= 0]
        cap_candidates = cap_candidates[cap_candidates >= 0]

        print("base S:", S)
        print("base S_e:", S_e)
        print("base cap:", cap)
        print("S candidates:", S_candidates)
        print("S_e candidates:", S_e_candidates)
        print("cap candidates:", cap_candidates)

        best_S, best_S_e, best_cap, best_cost, _ = self.calculate_grid(S_candidates, S_e_candidates, cap_candidates)

        return best_S, best_S_e, best_cap, best_cost

    def set_stop_condition(self, cost_value, best_cost_value, steps, best_candidate, candidate, results_temp, max_candidate, min_candidate, step_size):

        if np.round(cost_value, self.precision) < np.round(best_cost_value, self.precision):
            best_cost_value = cost_value
            best_candidate = candidate

        if steps < self.initial_steps:
            cont = True
            max_candidate += step_size
            candidate = max_candidate
        elif len(results_temp[np.argmin(results_temp):]) < self.initial_steps:
            cont = True
            max_candidate += step_size
            candidate = max_candidate
        elif len(results_temp[:np.argmin(results_temp)+1]) < self.initial_steps:
            cont = True
            min_candidate -= step_size
            candidate = min_candidate
            if candidate < 0:
                cont = False
        else:
            cont = False
        
        return candidate, best_cost_value, best_candidate, cont, steps, results_temp, max_candidate, min_candidate 

    def set_and_calculate_grid_with_cuts(self, S, S_e, cap, step_size, plot=False):

        # temporary, add as hyperparameter
        self.initial_steps = 2

        initial_S_candidiates = np.arange(S, S + step_size*(self.initial_steps), step_size)
        initial_S_e_candidates = np.arange(S_e, S_e + step_size*(self.initial_steps), step_size)
        initial_cap_candidates = np.arange(cap, cap + step_size*(self.initial_steps), step_size)
        
        cap_candidate = cap
        S_e_candidate = S_e

        results_S_temp = []
        S_candidate = S
        best_S_candidate = S
        min_S_candidate = S
        max_S_candidate = S
        cont_S = True
        steps_S = 0
        best_S_cost_value = np.inf
        last_S_candidate = S

        while cont_S:
            steps_S = steps_S+1

            ############ calc values for S ##################################
            print("entering middle loop")

            results_S_e_temp = []
            S_e_candidate = S_e
            best_S_e_candidate = S_e
            min_S_e_candidate = S_e
            max_S_e_candidate = S_e
            cont_S_e = True
            steps_S_e = 0
            best_S_e_cost_value = np.inf
            last_S_e_candidate = S_e

            while cont_S_e:
                steps_S_e = steps_S_e+1

                ############ calc values for S_e ##################################
                print("in inner loop")
                
                results_cap_temp = []
                cap_candidate = cap
                best_cap_candidate = cap
                min_cap_candidate = cap
                max_cap_candidate = cap
                cont_cap = True
                steps = 0
                best_cap_cost_value = np.inf
                last_cap_candidate = cap
                while cont_cap:
                    steps = steps+1

                    if (S_candidate, S_e_candidate, cap_candidate) in self.calculated_values:
                        cost_value = self.calculated_values[(S_candidate, S_e_candidate, cap_candidate)]
                    
                    # TODO Test this
                    elif S_e_candidate > S_candidate:
                        cost_value = np.inf
                        self.calculated_values[(S_candidate, S_e_candidate, cap_candidate)] = cost_value

                    elif cap_candidate > S_candidate:
                        cost_value = np.inf
                        self.calculated_values[(S_candidate, S_e_candidate, cap_candidate)] = cost_value

                    else:
                        cost_value = self.run_simulation(S_candidate, S_e_candidate, cap_candidate)
                        self.calculated_values[(S_candidate, S_e_candidate, cap_candidate)] = cost_value
                    
                    cost_value = np.round(cost_value, 2)
                    
                    if cap_candidate > last_cap_candidate:
                        results_cap_temp.append(cost_value)
                    else:
                        results_cap_temp.insert(0, cost_value)
                    print("S:", np.round(S_candidate,2), "S_e:", np.round(S_e_candidate,2), "cap:", np.round(cap_candidate,2), "cost:", np.round(cost_value))

                    last_cap_candidate = cap_candidate

                    cap_candidate, best_cap_cost_value, best_cap_candidate, cont_cap, steps, results_cap_temp, max_cap_candidate, min_cap_candidate = self.set_stop_condition(cost_value, best_cap_cost_value, steps, best_cap_candidate, cap_candidate, results_cap_temp,  max_cap_candidate, min_cap_candidate, step_size)

                ############ done calc values for S_e ##################################
                
                print("results_cap_temp:", results_cap_temp)
                print("best_cost_value:", best_cap_cost_value)
                print("best_cap_candidate:", best_cap_candidate)
                
                if S_e_candidate > last_S_e_candidate:
                    results_S_e_temp.append(cost_value)
                else:
                    results_S_e_temp.insert(0, cost_value)

                last_S_e_candidate = S_e_candidate

                best_S_e_cost_value_previous = best_S_e_cost_value
                S_e_candidate, best_S_e_cost_value, best_S_e_candidate, cont_S_e, steps_S_e, results_S_e_temp, max_S_e_candidate, min_S_e_candidate = self.set_stop_condition(cost_value, best_S_e_cost_value, steps, best_S_e_candidate, S_e_candidate, results_S_e_temp,  max_S_e_candidate, min_S_e_candidate, step_size)

                if best_S_e_cost_value < best_S_e_cost_value_previous:
                    best_cap_candidate_S_e_loop = best_cap_candidate
                
            
            ############ done calc values for S ##################################   

            print("results_S_e_temp:", results_S_e_temp)
            print("best_S_e_cost_value:", best_S_e_cost_value, "with S_e:", best_S_e_candidate, "and cap:", best_cap_candidate_S_e_loop)
        
            if S_candidate > last_S_candidate:
                results_S_temp.append(best_S_e_cost_value)
            else:
                results_S_temp.insert(0, best_S_e_cost_value)

            last_S_candidate = S_candidate
            best_S_cost_value_previous = best_S_cost_value

            S_candidate, best_S_cost_value, best_S_candidate, cont_S, steps_S, results_S_temp, max_S_candidate, min_S_candidate = self.set_stop_condition(cost_value, best_S_cost_value, steps, best_S_candidate, S_candidate, results_S_temp,  max_S_candidate, min_S_candidate, step_size)

            if best_S_cost_value < best_S_cost_value_previous:
                best_S_e_candidate_S_loop = best_S_e_candidate

        print("results_S_temp:", results_S_temp)
        print("best_S_cost_value:", best_S_cost_value, "with S:", best_S_candidate, "and S_e:", best_S_e_candidate_S_loop, "and cap:", best_cap_candidate_S_e_loop)

        # print("max S index:", len(S_candidates), "best S index:", best_S_index)
        # print("max S_e index:", len(S_e_candidates), "best S_e index:", best_S_e_index)
        # print("max cap index:", len(cap_candidates), "best cap index:", best_cap_index)

        # print("best S, S_e and cap:", best_S, best_S_e, best_cap)
        
        # print("base S:", S)
        # print("base S_e:", S_e)
        # print("base cap:", cap)
        # print("S candidates:", S_candidates)
        # print("S_e candidates:", S_e_candidates)
        # print("cap candidates:", cap_candidates)


        return best_S_candidate, best_S_e_candidate_S_loop, best_cap_candidate_S_e_loop, best_S_cost_value
    
    def set_params(self, demand, preprocessor):
        
        """
        Set the optimal order quantity (q_star) for each product.

        This method calculates and assigns the optimal order quantity based on the EOQ formula.

        Returns:
            None

        """

        self.preprocessor = preprocessor

        if self.algorithm == "brute_0_1":

            if self.full_grid:
                self.S, self.S_e, self.cap, cost = self.set_and_calculate_grid(self.S, self.S_e, self.cap, step_size = self.unit_size, full_grid=True)
                print("result:", "S:", self.S, "S_e:", self.S_e, "cost:", cost)
            else:
                self.S, self.S_e, self.cap, cost = self.set_and_calculate_grid(self.S, self.S_e, self.cap, step_size = self.unit_size*10)
                print("iteration 1:", "S:", self.S, "S_e:", self.S_e, "cap:", self.cap, "cost:", cost)
                self.S, self.S_e, self.cap, cost = self.set_and_calculate_grid(self.S, self.S_e, self.cap, step_size = self.unit_size*3)
                print("iteration 2:", "S:", self.S, "S_e:", self.S_e, "cap:", self.cap, "cost:", cost)
                self.S, self.S_e, self.cap, cost = self.set_and_calculate_grid(self.S, self.S_e, self.cap, step_size = self.unit_size)
                print("iteration 3:", "S:", self.S, "S_e:", self.S_e, "cap:", self.cap, "cost:", cost)
        
        elif self.algorithm == "brute_force_cuts":
            self.calculated_values = dict()
            self.S, self.S_e, self.cap, cost = self.set_and_calculate_grid_with_cuts(self.S, self.S_e, self.cap, step_size = self.unit_size*10)
            print("iteration 1:", "S:", self.S, "S_e:", self.S_e, "cap:", self.cap, "cost:", cost)
            self.S, self.S_e, self.cap, cost = self.set_and_calculate_grid_with_cuts(self.S, self.S_e, self.cap, step_size = self.unit_size*3)
            print("iteration 2:", "S:", self.S, "S_e:", self.S_e, "cap:", self.cap, "cost:", cost)
            self.S, self.S_e, self.cap, cost = self.set_and_calculate_grid_with_cuts(self.S, self.S_e, self.cap, step_size = self.unit_size)
            print("iteration 3:", "S:", self.S, "S_e:", self.S_e, "cap:", self.cap, "cost:", cost)     

        elif self.algorithm == "brute_variable":
            # rais not implemented

            raise NotImplementedError("only implemented for values normalized between 0 and 1")


            # self.run_brute_variable(demand)
        
        else:
            # error
            raise ValueError("Algorithm unknown")
    
    

    
    def draw_action(self, input):
        
        """
        Generate an action based on the current state.

        # TODO adjust description

        Returns zero for products which have still sufficient inventory, and the optimal order quantity for products which are running out of stock.

        Parameters:
            input (numpy.ndarray): The current inventory level and potentially order pipeline for each product.

        Returns:
            numpy.ndarray: The action to be taken, indicating the quantity to order for each product.

        """

        for preprocessor in self.preprocessors:
            input = preprocessor(input)

        total_inventory_position = np.sum(input)
        expedited_inventory_position = input[0]+np.sum(input[-(self.l_e)]) # first position is inventory, rest is pipeline vector

        if expedited_inventory_position < self.S_e:
            q_e = self.S_e - expedited_inventory_position
            q = np.minimum(np.maximum(self.S-total_inventory_position-q_e,0), self.cap)
        elif total_inventory_position < self.S:
            q_e=0
            q = np.minimum(self.S - total_inventory_position, self.cap)
        else:
            q_e=0
            q = 0

        action = np.array([q, q_e])

        for postprocessor in self.postprocessors:
            action = postprocessor(action)

        return action

    def draw_action_train(self, input, S, S_e, cap):

        """
        Generate an action based on the current state.

        # TODO adjust description

        Returns zero for products which have still sufficient inventory, and the optimal order quantity for products which are running out of stock.

        Parameters:
            input (numpy.ndarray): The current inventory level and potentially order pipeline for each product.

        Returns:
            numpy.ndarray: The action to be taken, indicating the quantity to order for each product.

        """

        for preprocessor in self.preprocessors:
            input = preprocessor(input)

        total_inventory_position = np.sum(input)
        expedited_inventory_position = input[0]+np.sum(input[-(self.l_e)]) # first position is inventory, rest is pipeline vector

        if expedited_inventory_position < S_e:
            q_e = S_e - expedited_inventory_position
            q = np.minimum(np.maximum(S-total_inventory_position-q_e,0), cap)
        elif total_inventory_position < S:
            q_e=0
            q = np.minimum(S - total_inventory_position, cap)
        else:
            q_e=0
            q = 0

        action = np.array([q, q_e])

        for postprocessor in self.postprocessors:
            action = postprocessor(action)

        return action
