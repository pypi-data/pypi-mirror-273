from datetime import datetime, timezone
from typing import Any, Callable, Dict, Iterator, List, Optional

import antimatter.client as openapi_client
from antimatter.builders.settings_patch import SettingsPatchBuilder
from antimatter.session_mixins.serializers.identity_details import serialize_identity_provider_info_dict
from antimatter.session_mixins.token import exec_with_token


class GeneralMixin:
    """
    Session mixin defining CRUD functionality for other general functionality.

    :param domain: The domain to use for the session.
    :param client: The client to use for the session.
    """

    _page_res_size: int = 100

    def __init__(self, domain: str, client_func: Callable[[], openapi_client.ApiClient], **kwargs):
        try:
            super().__init__(domain=domain, client_func=client_func, **kwargs)
        except TypeError:
            super().__init__()  # If this is last mixin, super() will be object()
        self._domain = domain
        self._client_func = client_func

    @exec_with_token
    def get_private_info(self) -> Dict[str, Any]:
        """
        Returns a Domain's summary information.

        :return: The private summary info for a domain
        """
        # Disable warnings because of a bug in DomainIdentityProviderDetails autogenerated code
        general_api = openapi_client.GeneralApi(api_client=self._client_func())
        res = general_api.domain_get_private_info(domain_id=self._domain).model_dump(warnings=False)
        if "identity_providers" in res:
            res["identity_providers"] = [
                serialize_identity_provider_info_dict(prov) for prov in res["identity_providers"]
            ]
        return res

    def get_public_info(self) -> Dict[str, Any]:
        """
        Returns a Domain's summary information. This endpoint does not require
        authorization

        :return: The public summary info for a domain
        """
        # Disable warnings because of a bug in DomainIdentityProviderDetails autogenerated code
        general_api = openapi_client.GeneralApi(api_client=self._client_func())
        res = general_api.domain_get_public_info(domain_id=self._domain).model_dump(warnings=False)
        if "identity_providers" in res:
            res["identity_providers"] = [
                serialize_identity_provider_info_dict(prov) for prov in res["identity_providers"]
            ]
        return res

    @exec_with_token
    def get_settings(self) -> Dict[str, Any]:
        """
        Return the domain settings.
        """
        general_api = openapi_client.GeneralApi(api_client=self._client_func())
        return general_api.domain_get_settings(domain_id=self._domain).model_dump()

    @exec_with_token
    def patch_settings(self, *patch: SettingsPatchBuilder) -> Dict[str, Any]:
        """
        Applies the given patch to the domain settings. The user must have
        permissions on all resources the patch references.

        :param patch: The patch or patches to make to the settings. The path is the patch is
                        a JSON pointer path.
        :return: The domain settings after applying the patch
        """
        general_api = openapi_client.GeneralApi(api_client=self._client_func())
        return general_api.domain_patch_settings(
            domain_id=self._domain,
            domain_settings_patch=openapi_client.DomainSettingsPatch(patch=[p.build() for p in patch])
        ).model_dump()

    @exec_with_token
    def get_status(self) -> Dict[str, Any]:
        """
        Return the domain status, which contains important notifications for
        administrators of the domain.
        """
        general_api = openapi_client.GeneralApi(api_client=self._client_func())
        return general_api.domain_get_status(domain_id=self._domain).model_dump()

    @exec_with_token
    def list_hooks(self) -> List[Dict[str, Any]]:
        """
        Return a list of available hooks in this domain. A hook is a data processor,
        like a PII classifier
        """
        contexts_api = openapi_client.ContextsApi(api_client=self._client_func())
        return [h.model_dump() for h in contexts_api.domain_list_hooks(domain_id=self._domain).hooks]

    @exec_with_token
    def list_resources(self) -> Dict[str, Any]:
        """
        Return a list of resource strings that can be used in policy rules, and
        the set of permissions that you can assign to them.
        """
        policy_api = openapi_client.PolicyApi(api_client=self._client_func())
        return policy_api.domain_list_resources(domain_id=self._domain).model_dump()

    @exec_with_token
    def query_access_log(
        self,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
        session: Optional[str] = None,
        location: Optional[str] = None,
        location_prefixed: Optional[bool] = None,
        operation_type: Optional[str] = None,
        allowed_tag: Optional[str] = None,
        redacted_or_tokenized_tag: Optional[str] = None,
        capsule_id: Optional[str] = None,
    ) -> Iterator[Dict[str, Any]]:
        """
        Query the data access log for this domain. This contains all operations
        interacting with capsules within this domain. An iterator is returned
        over the results in reverse chronological order.

        :param start_date: The earlier date of the date range. As results are returned in reverse
                    chronological order, this date corresponds with the end of the result set.
                    This should be a timezone-aware datetime, or else will be treated as the
                    system timezone
        :param end_date: The later date of the date range. As results are returned in reverse
                    chronological order, this date corresponds with the beginning of the result
                    set. If not specified, defaults to the current time.
                    This should be a timezone-aware datetime, or else will be treated as the
                    system timezone
        :param session: The session you would like to filter on. This will return results for only
                    the provided session. If not specified, this field is ignored
        :param location: The location you would like to filter on. This is a matched filter and will
                    return results starting with the provided string. If not specified, this
                    field is ignored
        :param location_prefixed: A boolean indicator to indicate that the location you provided is a prefix
                    or not. If this is set to true, then the filter provided in location is
                    treated as a prefix. If not specified, this is treated as false
        :param operation_type: The operation you would like to filter on. This will filter on the provided
                    operation type and return all results using the provided operation type. If
                    not specified, this field is ignored
        :param allowed_tag: The allow tag key you would like to filter on. This accepts tag key only
                    and will return all allowed tag results matching the provided tag key. If
                    not specified, this field is ignored
        :param redacted_or_tokenized_tag: The redacted or tokenized tag key you would like ot filter on. This accepts
                    a tag key only and will return all redacted and tokenized tag key results
                    matching the provided tag key. If not specified, this field is ignored
        :param capsule_id: The ID for a specific capsule. Use this to limit results to a single capsule
        :return: An iterator over the access logs matching the filters
        """
        capsules_api = openapi_client.CapsulesApi(api_client=self._client_func())
        pagination = None
        has_more = True
        if start_date is not None:
            start_date = start_date.astimezone(timezone.utc)
        if end_date is not None:
            end_date = end_date.astimezone(timezone.utc)
        while has_more:
            kwargs = {
                "start_date": start_date,
                "end_date": end_date,
                "num_results": self._page_res_size,
                "start_from_id": pagination,
                "session": session,
                "location": location,
                "location_prefixed": location_prefixed,
                "operation_type": operation_type,
                "allowed_tag": allowed_tag,
                "redacted_or_tokenized_tag": redacted_or_tokenized_tag,
            }
            if capsule_id is None:
                res = capsules_api.domain_query_access_log(domain_id=self._domain, **kwargs)
            else:
                res = capsules_api.domain_query_access_log_single_capsule(
                    domain_id=self._domain, capsule_id=capsule_id, **kwargs,
                )
            has_more = res.has_more
            for log in res.results:
                pagination = log.id
                yield log.model_dump()

    @exec_with_token
    def query_control_log(
        self,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
        session: Optional[str] = None,
        url: Optional[str] = None,
        description: Optional[str] = None,
    ) -> Iterator[Dict[str, Any]]:
        """
        Query the domain control-plane audit log. An iterator is returned over the
        results in reverse chronological order.

        :param start_date: The earlier date of the date range. As results are returned in reverse
                    chronological order, this date corresponds with the end of the result set.
                    This should be a timezone-aware datetime, or else will be treated as the
                    system timezone
        :param end_date: The later date of the date range. As results are returned in reverse
                    chronological order, this date corresponds with the beginning of the
                    result set. If not specified, defaults to the current time.
                    This should be a timezone-aware datetime, or else will be treated as the
                    system timezone
        :param session: The session you would like to filter on. This will return results for only
                    the provided session. If not specified, this field is ignored
        :param url: The URL you would like to filter on. This is a prefix matched filter and
                    will return results starting with the provided string. If not specified,
                    this field is ignored
        :param description: The description you would like to filter on. This is an in matched filter
                    and will return results that  contain the provided string. If not specified,
                    this field is ignored
        :return: An iterator over the control logs matching the filters
        """
        general_api = openapi_client.GeneralApi(api_client=self._client_func())
        pagination = None
        has_more = True
        if start_date is not None:
            start_date = start_date.astimezone(timezone.utc)
        if end_date is not None:
            end_date = end_date.astimezone(timezone.utc)
        while has_more:
            res = general_api.domain_query_control_log(
                domain_id=self._domain,
                start_date=start_date,
                end_date=end_date,
                num_results=self._page_res_size,
                start_from_id=pagination,
                session=session,
                url=url,
                description=description,
            )
            has_more = res.has_more
            for log in res.results:
                pagination = log.id
                yield log.model_dump()
