# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['zeta',
 'zeta.cli',
 'zeta.cloud',
 'zeta.experimental',
 'zeta.experimental.triton',
 'zeta.experimental.triton.activations',
 'zeta.experimental.triton.triton_modules',
 'zeta.models',
 'zeta.nn',
 'zeta.nn.attention',
 'zeta.nn.biases',
 'zeta.nn.embeddings',
 'zeta.nn.masks',
 'zeta.nn.modules',
 'zeta.nn.modules.xmoe',
 'zeta.ops',
 'zeta.optim',
 'zeta.quant',
 'zeta.rl',
 'zeta.structs',
 'zeta.tokenizers',
 'zeta.training',
 'zeta.utils']

package_data = \
{'': ['*']}

install_requires = \
['accelerate==0.28.0',
 'argparse>=1.4.0,<2.0.0',
 'beartype==0.17.2',
 'bitsandbytes==0.43.0',
 'colt5-attention',
 'datasets',
 'einops-exts==0.0.4',
 'einops==0.7.0',
 'local-attention',
 'loguru',
 'pytest==8.1.1',
 'rich==13.7.1',
 'scipy==1.9.3',
 'torch>=2.1.1,<3.0',
 'torchfix',
 'torchvision==0.18.0',
 'tqdm==4.66.3',
 'transformers==4.40.1',
 'vector-quantize-pytorch==1.14.7']

entry_points = \
{'console_scripts': ['zeta = zeta.cli.main:main']}

setup_kwargs = {
    'name': 'zetascale',
    'version': '2.4.8',
    'description': 'Rapidly Build, Optimize, and Deploy SOTA AI Models',
    'long_description': '[![Multi-Modality](images/agorabanner.png)](https://discord.gg/qUtxnK2NMf)\n\n![Zeta banner](images/zeta.png)\nBuild SOTA AI Models 80% faster with modular, high-performance, and scalable building blocks!\n\n[![Docs](https://readthedocs.org/projects/zeta/badge/)](https://zeta.readthedocs.io)\n\n<p>\n  <a href="https://github.com/kyegomez/zeta/blob/main/LICENSE"><img alt="MIT License" src="https://img.shields.io/badge/license-MIT-blue.svg" /></a>\n  <a href="https://pypi.org/project/zetascale"><img alt="MIT License" src="https://badge.fury.io/py/zetascale.svg" /></a>\n</p>\n\n[![GitHub issues](https://img.shields.io/github/issues/kyegomez/zeta)](https://github.com/kyegomez/zeta/issues) [![GitHub forks](https://img.shields.io/github/forks/kyegomez/zeta)](https://github.com/kyegomez/zeta/network) [![GitHub stars](https://img.shields.io/github/stars/kyegomez/zeta)](https://github.com/kyegomez/zeta/stargazers) [![GitHub license](https://img.shields.io/github/license/kyegomez/zeta)](https://github.com/kyegomez/zeta/blob/main/LICENSE)[![GitHub star chart](https://img.shields.io/github/stars/kyegomez/zeta?style=social)](https://star-history.com/#kyegomez/zeta)[![Dependency Status](https://img.shields.io/librariesio/github/kyegomez/zeta)](https://libraries.io/github/kyegomez/zeta) [![Downloads](https://static.pepy.tech/badge/zeta/month)](https://pepy.tech/project/zeta)\n\n[![Join the Agora discord](https://img.shields.io/discord/1110910277110743103?label=Discord&logo=discord&logoColor=white&style=plastic&color=d7b023)![Share on Twitter](https://img.shields.io/twitter/url/https/twitter.com/cloudposse.svg?style=social&label=Share%20%40kyegomez/zeta)](https://twitter.com/intent/tweet?text=Check%20out%20this%20amazing%20AI%20project:%20&url=https%3A%2F%2Fgithub.com%2Fkyegomez%2Fzeta) [![Share on Facebook](https://img.shields.io/badge/Share-%20facebook-blue)](https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fgithub.com%2Fkyegomez%2Fzeta) [![Share on LinkedIn](https://img.shields.io/badge/Share-%20linkedin-blue)](https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fgithub.com%2Fkyegomez%2Fzeta&title=&summary=&source=)\n\n[![Share on Reddit](https://img.shields.io/badge/-Share%20on%20Reddit-orange)](https://www.reddit.com/submit?url=https%3A%2F%2Fgithub.com%2Fkyegomez%2Fzeta&title=zeta%20-%20the%20future%20of%20AI) [![Share on Hacker News](https://img.shields.io/badge/-Share%20on%20Hacker%20News-orange)](https://news.ycombinator.com/submitlink?u=https%3A%2F%2Fgithub.com%2Fkyegomez%2Fzeta&t=zeta%20-%20the%20future%20of%20AI) [![Share on Pinterest](https://img.shields.io/badge/-Share%20on%20Pinterest-red)](https://pinterest.com/pin/create/button/?url=https%3A%2F%2Fgithub.com%2Fkyegomez%2Fzeta&media=https%3A%2F%2Fexample.com%2Fimage.jpg&description=zeta%20-%20the%20future%20of%20AI) [![Share on WhatsApp](https://img.shields.io/badge/-Share%20on%20WhatsApp-green)](https://api.whatsapp.com/send?text=Check%20out%20zeta%20-%20the%20future%20of%20AI%20%23zeta%20%23AI%0A%0Ahttps%3A%2F%2Fgithub.com%2Fkyegomez%2Fzeta)\n\nAfter building out thousands of neural nets and facing the same annoying bottlenecks of chaotic codebases with no modularity and low performance modules, Zeta needed to be born to enable me and others to quickly prototype, train, and optimize the latest SOTA neural nets and deploy them into production. \n\nZeta places a radical emphasis on useability, modularity, and performance. Zeta is now currently employed in 100s of models across my github and across others. \nGet started below and LMK if you want my help building any model, I\'m here for you üòä üíú \n\n\n# Install\n\n`$ pip3 install -U zetascale`\n\n# Usage\n\n## Starting Your Journey\n\nCreating a model empowered with the aforementioned breakthrough research features is a breeze. Here\'s how to quickly materialize the renowned Flash Attention\n\n```python\nimport torch\n\nfrom zeta.nn import FlashAttention\n\nq = torch.randn(2, 4, 6, 8)\nk = torch.randn(2, 4, 10, 8)\nv = torch.randn(2, 4, 10, 8)\n\nattention = FlashAttention(causal=False, dropout=0.1, flash=True)\noutput = attention(q, k, v)\n\nprint(output.shape)\n```\n\n\n\n### `SwiGLU`\n- Powers Transformer models\n```python\nimport torch\n\nfrom zeta.nn import SwiGLUStacked\n\nx = torch.randn(5, 10)\nswiglu = SwiGLUStacked(10, 20)\nswiglu(x).shape\n```\n\n### ```RelativePositionBias```\n- ```RelativePositionBias``` quantizes the distance between two positions into a certain number of buckets and then uses an embedding to get the relative position bias. This mechanism aids in the attention mechanism by providing biases based on relative positions between the query and key, rather than relying solely on their absolute positions.\n```python\nimport torch\nfrom torch import nn\n\nfrom zeta.nn import RelativePositionBias\n\n# Initialize the RelativePositionBias module\nrel_pos_bias = RelativePositionBias()\n\n# Example 1: Compute bias for a single batch\nbias_matrix = rel_pos_bias(1, 10, 10)\n\n\n# Example 2: Utilize in conjunction with an attention mechanism\n# NOTE: This is a mock example, and may not represent an actual attention mechanism\'s complete implementation.\nclass MockAttention(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.rel_pos_bias = RelativePositionBias()\n\n    def forward(self, queries, keys):\n        bias = self.rel_pos_bias(queries.size(0), queries.size(1), keys.size(1))\n        # Further computations with bias in the attention mechanism...\n        return None  # Placeholder\n\n\n# Example 3: Modify default configurations\ncustom_rel_pos_bias = RelativePositionBias(\n    bidirectional=False, num_buckets=64, max_distance=256, num_heads=8\n)\n```\n\n### `FeedForward`\nThe FeedForward module performs a feedforward operation on the input tensor x. It consists of a multi-layer perceptron (MLP) with an optional activation function and LayerNorm. \nUsed in most language, multi-modal, and modern neural networks.\n\n```python\nimport torch\n\nfrom zeta.nn import FeedForward\n\nmodel = FeedForward(256, 512, glu=True, post_act_ln=True, dropout=0.2)\n\nx = torch.randn(1, 256)\n\noutput = model(x)\nprint(output.shape)\n```\n\n### `BitLinear`\n- The BitLinear module performs linear transformation on the input data, followed by quantization and dequantization. The quantization process is performed using the absmax_quantize function, which quantizes the input tensor based on the absolute maximum value, [from the paper](https://arxiv.org/abs/2310.11453)\n```python\nimport torch\nfrom torch import nn\n\nimport zeta.quant as qt\n\n\nclass MyModel(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.linear = qt.BitLinear(10, 20)\n\n    def forward(self, x):\n        return self.linear(x)\n\n\n# Initialize the model\nmodel = MyModel()\n\n# Create a random tensor of size (128, 10)\ninput = torch.randn(128, 10)\n\n# Perform the forward pass\noutput = model(input)\n\n# Print the size of the output\nprint(output.size())  # torch.Size([128, 20])\n```\n\n### `PalmE`\n- This is an implementation of the multi-modal Palm-E model using a decoder llm as the backbone with an VIT image encoder to process vision, it\'s very similiar to GPT4, Kosmos, RTX2, and many other multi-modality model architectures\n\n```python\nimport torch\n\nfrom zeta.structs import (\n    AutoRegressiveWrapper,\n    Decoder,\n    Encoder,\n    Transformer,\n    ViTransformerWrapper,\n)\n\n\nclass PalmE(torch.nn.Module):\n    """\n        PalmE is a transformer architecture that uses a ViT encoder and a transformer decoder.\n\n        Args:\n\n            image_size (int): Size of the image.\n            patch_size (int): Size of the patch.\n            encoder_dim (int): Dimension of the encoder.\n            encoder_depth (int): Depth of the encoder.\n            encoder_heads (int): Number of heads in the encoder.\n            num_tokens (int): Number of tokens.\n            max_seq_len (int): Maximum sequence length.\n            decoder_dim (int): Dimension of the decoder.\n            decoder_depth (int): Depth of the decoder.\n            decoder_heads (int): Number of heads in the decoder.\n            alibi_num_heads (int): Number of heads in the alibi attention.\n            attn_kv_heads (int): Number of heads in the attention key-value projection.\n            use_abs_pos_emb (bool): Whether to use absolute positional embeddings.\n            cross_attend (bool): Whether to cross attend in the decoder.\n            alibi_pos_bias (bool): Whether to use positional bias in the alibi attention.\n            rotary_xpos (bool): Whether to use rotary positional embeddings.\n            attn_flash (bool): Whether to use attention flash.\n            qk_norm (bool): Whether to normalize the query and key in the attention layer.\n\n        Returns:\n\n                torch.Tensor: The output of the model.\n\n        Usage:\n\n    img = torch.randn(1, 3, 256, 256)\n    text = torch.randint(0, 20000, (1, 1024))\n    model = PalmE()\n    output = model(img, text)\n    print(output)\n\n    """\n\n    def __init__(\n        self,\n        image_size=256,\n        patch_size=32,\n        encoder_dim=512,\n        encoder_depth=6,\n        encoder_heads=8,\n        num_tokens=20000,\n        max_seq_len=1024,\n        decoder_dim=512,\n        decoder_depth=6,\n        decoder_heads=8,\n        alibi_num_heads=4,\n        attn_kv_heads=2,\n        use_abs_pos_emb=False,\n        cross_attend=True,\n        alibi_pos_bias=True,\n        rotary_xpos=True,\n        attn_flash=True,\n        qk_norm=True,\n    ):\n        super().__init__()\n\n        # vit architecture\n        self.encoder = ViTransformerWrapper(\n            image_size=image_size,\n            patch_size=patch_size,\n            attn_layers=Encoder(\n                dim=encoder_dim, depth=encoder_depth, heads=encoder_heads\n            ),\n        )\n\n        # palm model architecture\n        self.decoder = Transformer(\n            num_tokens=num_tokens,\n            max_seq_len=max_seq_len,\n            use_abs_pos_emb=use_abs_pos_emb,\n            attn_layers=Decoder(\n                dim=decoder_dim,\n                depth=decoder_depth,\n                heads=decoder_heads,\n                cross_attend=cross_attend,\n                alibi_pos_bias=alibi_pos_bias,\n                alibi_num_heads=alibi_num_heads,\n                rotary_xpos=rotary_xpos,\n                attn_kv_heads=attn_kv_heads,\n                attn_flash=attn_flash,\n                qk_norm=qk_norm,\n            ),\n        )\n\n        # autoregressive wrapper to enable generation of tokens\n        self.decoder = AutoRegressiveWrapper(self.decoder)\n\n    def forward(self, img: torch.Tensor, text: torch.Tensor):\n        """Forward pass of the model."""\n        try:\n            encoded = self.encoder(img, return_embeddings=True)\n            return self.decoder(text, context=encoded)\n        except Exception as error:\n            print(f"Failed in forward method: {error}")\n            raise\n\n\n# Usage with random inputs\nimg = torch.randn(1, 3, 256, 256)\ntext = torch.randint(0, 20000, (1, 1024))\n\n# Initiliaze the model\nmodel = PalmE()\noutput = model(img, text)\nprint(output)\n```\n\n\n### `Unet`\nUnet is a famous convolutional neural network architecture originally used for biomedical image segmentation but soon became the backbone of the generative AI Mega-revolution. The architecture comprises two primary pathways: downsampling and upsampling, followed by an output convolution. Due to its U-shape, the architecture is named U-Net. Its symmetric architecture ensures that the context (from downsampling) and the localization (from upsampling) are captured effectively.\n\n```python\nimport torch\n\nfrom zeta.nn import Unet\n\n# Initialize the U-Net model\nmodel = Unet(n_channels=1, n_classes=2)\n\n# Random input tensor with dimensions [batch_size, channels, height, width]\nx = torch.randn(1, 1, 572, 572)\n\n# Forward pass through the model\ny = model(x)\n\n# Output\nprint(f"Input shape: {x.shape}")\nprint(f"Output shape: {y.shape}")\n```\n\n\n### `VisionEmbeddings`\nThe VisionEmbedding class is designed for converting images into patch embeddings, making them suitable for processing by transformer-based models. This class plays a crucial role in various computer vision tasks and enables the integration of vision data into transformer architectures!\n\n```python\nimport torch\n\nfrom zeta.nn import VisionEmbedding\n\n# Create an instance of VisionEmbedding\nvision_embedding = VisionEmbedding(\n    img_size=224,\n    patch_size=16,\n    in_chans=3,\n    embed_dim=768,\n    contain_mask_token=True,\n    prepend_cls_token=True,\n)\n\n# Load an example image (3 channels, 224x224)\ninput_image = torch.rand(1, 3, 224, 224)\n\n# Perform image-to-patch embedding\noutput = vision_embedding(input_image)\n\n# The output now contains patch embeddings, ready for input to a transformer model\n```\n\n\n### `niva`\n- Niva focuses on weights of certain layers (specified by quantize_layers). Ideal for models where runtime activation is variable. üëÅÔ∏è Example Layers: nn.Embedding, nn.LSTM. \n\n```python\nimport torch\n\nfrom zeta import niva\n\n# Load a pre-trained model\nmodel = YourModelClass()\n\n# Quantize the model dynamically, specifying layers to quantize\nniva(\n    model=model,\n    model_path="path_to_pretrained_model_weights.pt",\n    output_path="quantized_model.pt",\n    quant_type="dynamic",\n    quantize_layers=[nn.Linear, nn.Conv2d],\n    dtype=torch.qint8,\n)\n```\n\n\n### `FusedDenseGELUDense`\n- Increase model speed by 2x with this module that fuses together 2 hyper-optimized dense ops from bits and bytes and a gelu together!\n\n```python\nimport torch\n\nfrom zeta.nn import FusedDenseGELUDense\n\nx = torch.randn(1, 512)\nmodel = FusedDenseGELUDense(512, 1024)\nout = model(x)\nout.shape\n```\n\n\n### `FusedDropoutLayerNorm`\n- FusedDropoutLayerNorm is a fused kernel of dropout and layernorm to speed up FFNs or MLPS by 2X\n\n```python\nimport torch\nfrom torch import nn\n\nfrom zeta.nn import FusedDropoutLayerNorm\n\n# Initialize the module\nmodel = FusedDropoutLayerNorm(dim=512)\n\n# Create a sample input tensor\nx = torch.randn(1, 512)\n\n# Forward pass\noutput = model(x)\n\n# Check output shape\nprint(output.shape)  # Expected: torch.Size([1, 512])\n```\n\n\n### `Mamba`\n- Pytorch implementation of the new SSM model architecture Mamba\n\n```python\nimport torch\n\nfrom zeta.nn import MambaBlock\n\n# Initialize Mamba\nblock = MambaBlock(dim=64, depth=1)\n\n# Random input\nx = torch.randn(1, 10, 64)\n\n# Apply the model to the block\ny = block(x)\n\nprint(y.shape)\n# torch.Size([1, 10, 64])\n```\n\n### `FiLM`\n\n```python\nimport torch\n\nfrom zeta.nn import Film\n\n# Initialize the Film layer\nfilm_layer = Film(dim=128, hidden_dim=64, expanse_ratio=4)\n\n# Create some dummy data for conditions and hiddens\nconditions = torch.randn(10, 128)  # Batch size is 10, feature size is 128\nhiddens = torch.randn(\n    10, 1, 128\n)  # Batch size is 10, sequence length is 1, feature size is 128\n\n# Pass the data through the Film layer\nmodulated_features = film_layer(conditions, hiddens)\n\n# Print the shape of the output\nprint(modulated_features.shape)  # Should be [10, 1, 128]\n```\n\n### `hyper_optimize`\n- A single wrapper for torch.fx, torch.script, torch.compile, dynamic quantization, mixed precision through torch.amp, with execution time metrics all in once place!\n```python\nimport torch\n\nfrom zeta.nn import hyper_optimize\n\n\n@hyper_optimize(\n    torch_fx=False,\n    torch_script=False,\n    torch_compile=True,\n    quantize=True,\n    mixed_precision=True,\n    enable_metrics=True,\n)\ndef model(x):\n    return x @ x\n\n\nout = model(torch.randn(1, 3, 32, 32))\nprint(out)\n```\n\n\n### DPO - Direct Policy Optimization\nDirect Policy Optimization employed for many RLHF applications for LLMs.\n\n```python\nimport torch\nfrom torch import nn\n\nfrom zeta.rl import DPO\n\n\n# Define a simple policy model\nclass PolicyModel(nn.Module):\n    def __init__(self, input_dim, output_dim):\n        super().__init__()\n        self.fc = nn.Linear(input_dim, output_dim)\n\n    def forward(self, x):\n        return self.fc(x)\n\n\ninput_dim = 10\noutput_dim = 5\npolicy_model = PolicyModel(input_dim, output_dim)\n\n# Initialize DPO with the policy model\ndpo_model = DPO(model=policy_model, beta=0.1)\n\n# Sample preferred and unpreferred sequences\npreferred_seq = torch.randint(0, output_dim, (3, input_dim))\nunpreferred_seq = torch.randint(0, output_dim, (3, input_dim))\n\n# Compute loss\nloss = dpo_model(preferred_seq, unpreferred_seq)\nprint(loss)\n```\n\n\n### ZetaCloud\nTrain or finetune any model on any cluster in 1 click with zetacloud, just pass in your file and the GPU type and quantity you want! To gain access first `pip install zetascale` then run `zeta -h` in the terminal. [Here is the docs for more](https://zeta.apac.ai/en/latest/zeta/cloud/main/)\n\n- Flexible Pricing with pooling from many clouds\n- Easy Deployment with 1 click\n- Various options for cloud providers!\n\n```bash\nZetacloud CLI\n\noptions:\n  -h, --help            show this help message and exit\n  -t TASK_NAME, --task_name TASK_NAME\n                        Task name\n  -c CLUSTER_NAME, --cluster_name CLUSTER_NAME\n                        Cluster name\n  -cl CLOUD, --cloud CLOUD\n                        Cloud provider\n  -g GPUS, --gpus GPUS  GPUs\n  -f FILENAME, --filename FILENAME\n                        Filename\n  -s, --stop            Stop flag\n  -d, --down            Down flag\n  -sr, --status_report  Status report flag\n\n```\n\n- A simple run example code would be like:\n\n```bash\nzeta -f train.py -g A100:8\n```\n----\n\n\n# Documentation\nAll classes must have documentation if you see a class or function without documentation then please report it to me at kye@apac.ai,\n\nDocumentation is at [zeta.apac.ai](https://zeta.apac.ai/)\n\n\n-------\n\n\n# Running tests\nYou should install the pre-commit hooks with pre-commit install. This will run the linter, mypy, and a subset of the tests on every commit.\n\nFor more examples on how to run the full test suite please refer to the CI workflow.\n\nSome examples of running tests locally:\n\n```bash\npython3 -m pip install -e \'.[testing]\'  # install extra deps for testing\npython3 -m pytest tests/                 # whole test suite\n```\n----\n\n## Community\n\nJoin our growing community around the world, for real-time support, ideas, and discussions on how to build better models üòä \n\n- View our official [Docs](https://zeta.apac.ai)\n- Chat live with us on [Discord](https://discord.gg/kS3rwKs3ZC)\n- Follow us on [Twitter](https://twitter.com/kyegomez)\n- Connect with us on [LinkedIn](https://www.linkedin.com/company/the-swarm-corporation)\n- Visit us on [YouTube](https://www.youtube.com/channel/UC9yXyitkbU_WSy7bd_41SqQ)\n- [Join the Swarms community on Discord!](https://discord.gg/AJazBmhKnr)\n\n---\n\n# ü§ù Schedule a 1-on-1 Session\nWant to train a custom AI model for a real-world task like General Multi-Modal Models, Facial Recognitions, Drug Discovery, Humanoid Robotics? I\'ll help you create the model architecture then train the model and then optimize it to meet your quality assurance standards.\n\nBook a [1-on-1 Session with Kye here.](https://calendly.com/apacai/agora), the Creator, to discuss any issues, provide feedback, or explore how we can improve Zeta for you or help you build your own custom models!\n\n## ü´∂ Contributions:\n\nThe easiest way to contribute is to pick any issue with the `good first issue` tag üí™. Read the Contributing guidelines [here](/CONTRIBUTING.md). Bug Report? [File here](https://github.com/kyegomez/zeta/issues/new/choose) | Feature Request? [File here](https://github.com/kyegomez/zeta/issues/new/choose)\n\nZeta is an open-source project, and contributions are VERY welcome. If you want to contribute, you can create new features, fix bugs, or improve the infrastructure. Please refer to the [CONTRIBUTING.md](https://github.com/kyegomez/zeta/blob/master/CONTRIBUTING.md) and our [contributing board](https://github.com/users/kyegomez/projects/1) to participate in Roadmap discussions!\n\n<a href="https://github.com/kyegomez/zeta/graphs/contributors">\n  <img src="https://contrib.rocks/image?repo=kyegomez/zeta" />\n</a>\n\n----\n\n## Accelerate Backlog\nHelp us accelerate our backlog by supporting us financially! Note, we\'re an open source corporation and so all the revenue we generate is through donations at the moment ;)\n\n<a href="https://polar.sh/kyegomez"><img src="https://polar.sh/embed/fund-our-backlog.svg?org=kyegomez" /></a>\n\n\n# License \n- Apache\n',
    'author': 'Zeta Team',
    'author_email': 'kye@apac.ai',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://github.com/kyegomez/zeta',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'entry_points': entry_points,
    'python_requires': '>=3.10,<4.0',
}


setup(**setup_kwargs)
