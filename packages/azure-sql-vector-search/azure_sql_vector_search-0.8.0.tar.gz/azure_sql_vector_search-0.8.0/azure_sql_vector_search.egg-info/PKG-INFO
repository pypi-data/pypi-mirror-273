Metadata-Version: 2.1
Name: azure-sql-vector-search
Version: 0.8.0
Summary: Azure SQL Vector Search Clients
Home-page: https://github.com/projectAcetylcholine/sql_vector_search
Author: Microsoft Corporation
License: MIT License
Keywords: azure sql vector search langchain
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: pyodbc>=5.1.0
Requires-Dist: sqlalchemy>=2.0.30
Requires-Dist: numpy>=1.26.4

## Azure SQL Vector Search

This project contains SDKs that allow developers to use Azure SQL Database to build AI applications that need vector search.

### Vector Search Modes

There are 2 modes available:

- Classic Vector Search
- Native Vector Search

The classic vector search allows you to store vectors leveraging the traditional clustered column index that makes it easy to retrieve the vectors and the associated metadata later.

The native vector search uses newly made available built-in functions to store and query the data for faster performance.

The native vector search is currently in private-preview, and you will need access to this feature to use this mode.

### Distance Strategies

There are three distance strategies when comparing the vectors for the records in the table
- COSINE_SIMILARITY
- EUCLIDEAN_DISTANCE
- DOT_PRODUCT

Cosine Similarity, Inner Product (aka Dot Product), and Euclidean Distance are all measures used to analyze and compute relationships between vectors, but they each serve different purposes and are used in different contexts:

### 1. Cosine Similarity
- **Definition**: Cosine similarity measures the cosine of the angle between two vectors. It is calculated as the dot product of the vectors normalized to both have length 1.
- **Range**: It ranges from -1 to 1. A value of 1 means the vectors are parallel (same direction), 0 means they are orthogonal (no correlation), and -1 means they are anti-parallel (opposite directions).
- **Usage**: It is widely used in text analysis and other areas where the magnitude of the vectors is not as important as the orientation. It's especially useful in measuring similarity in high-dimensional spaces.

### 2. Inner Product (Dot Product)
- **Definition**: The inner product of two vectors is the sum of the products of their corresponding components. This is equivalent to projecting one vector onto another and scaling it by the length of the other vector.
- **Result Type**: The result is a scalar. Positive values indicate a certain degree of alignment between the vectors, zero suggests orthogonality, and negative values indicate a degree of opposition.
- **Usage**: Inner product is fundamental in geometry for defining projections, in physics for work calculations, and in machine learning for various linear algebra operations.

When the vectors are normalized (modified so that their magnitude is 1), Cosine Similarity and Inner Product (dot product) computes to the same value, however the inner product is a faster operation and is usually preferred over large datasets.

### 3. Euclidean Distance
- **Definition**: Euclidean distance is the straight-line distance between two points in Euclidean space, calculated by taking the square root of the sum of the squared differences between corresponding elements of the vectors.
- **Range**: It ranges from 0 to infinity. A distance of 0 means the points are identical, and larger values indicate points that are further apart.
- **Usage**: It's commonly used in clustering and classification tasks to measure the actual 'distance' between samples. It's the basis for many algorithms, including K-means clustering and K-nearest neighbors.

### Key Differences
- **Context of Use**: Cosine similarity is used when the magnitude of the vectors is not important, such as in text similarity calculations. The inner product is often used in contexts where alignment or opposition between vectors is critical, and Euclidean distance is used when the actual spatial distance is needed.
- **Sensitivity to Magnitude**: The inner product and Euclidean distance are affected by the magnitude (length) of the vectors, whereas cosine similarity only depends on the angle between vectors, making it magnitude-invariant.
- **Computation**: While both inner product and cosine similarity involve dot products, cosine similarity includes an additional step of normalizing the vectors, and Euclidean distance involves computing the square root of the sum of squared differences.

Each of these metrics applies best to specific situations and can yield very different insights depending on the application.

## Pre-Requisites 

You will need to download the ODBC driver and install the python library via pip to get started

Visit [this page](https://learn.microsoft.com/en-us/sql/connect/odbc/download-odbc-driver-for-sql-server?view=sql-server-ver16) for instructions on how to install the ODBC driver for your environment

There are binaries for Windows, Linux and Mac OS X

Once that is done, you will need to set up the connection string as an environment variable. We can use the following environment variable to connect

AZURE_SQL_CONNECTION_STRING

### Linux and Mac OS X

If you are running on Mac OS X or Linux you can set the environment variable as follows:

````bash
export AZURE_SQL_CONNECTION_STRING='your_connection_string_here'
````
### Windows 

````bash
set AZURE_SQL_CONNECTION_STRING=your_connection_string_here
````

### Installing the Python SDK via pip

````bash
pip install azure_sql_vector_search
````

## Examples of How to Insert Data using the Vector Search Client

In this section, we are going to cover the following

- How to Insert Data with Classic Client
- How to Insert Data with Native Vector Client

#### Using AzureSQLClassicVectorSearchClient

````python 
import os
from azure_sql_vector_search.classic_vector_search import AzureSQLClassicVectorSearchClient

connection_string = os.environ.get("AZURE_SQL_CONNECTION_STRING")

embeddings: list[list[float]] = [
    [0.5, 0.5, 0.5, 0.5],
    [-0.5, -0.5, -0.5, -0.5],
    [0.5, 0.5, 0.5, 0.5],
    [1.0, 0.0, 0.0, 0.0],
    [0.0, 1, 0, 0],
    [0, 0, 0, 1],
    [0.8, 0.6, 0, 0],
    [0, 0, 0.6, 0.8],
    [0, 0.8, 0.6, 0],
    [0, 0, 0.8, 0.6],
    [0.0, 0.0, 0.0, 0.0],
]

active_options = [True, False]
code_options = ["python", "typescript", "", None]
age_options = [40, 50, 60, 65, 75]

vector_search = AzureSQLClassicVectorSearchClient(connection_string, "products")

for i in range(len(embeddings)):
    embedding = embeddings[i]
    name = "Izzy {}".format(i)
    content = "Israel Ekpo {} {}".format(i, embedding)
    active = active_options[i % 2]
    code = code_options[i % 4]
    age = age_options[i % 5]

    # metadata containing integer, float, string, boolean and null types
    metadata = {"content": content, "name": name, "active": active, "code": code, "age": age, "mass": i / age}

    print("processing id {} embedding -> {}, metadata -> {}".format(i, embedding, metadata))
    result = vector_search.insert_row(content, metadata, embedding)

````

#### Using AzureSQLNativeVectorSearchClient

````python 
import os
from azure_sql_vector_search.native_vector_search import AzureSQLNativeVectorSearchClient

connection_string = os.environ.get("AZURE_SQL_CONNECTION_STRING")

embeddings: list[list[float]] = [
    [0.5, 0.5, 0.5, 0.5],
    [-0.5, -0.5, -0.5, -0.5],
    [0.5, 0.5, 0.5, 0.5],
    [1.0, 0.0, 0.0, 0.0],
    [0.0, 1, 0, 0],
    [0, 0, 0, 1],
    [0.8, 0.6, 0, 0],
    [0, 0, 0.6, 0.8],
    [0, 0.8, 0.6, 0],
    [0, 0, 0.8, 0.6],
    [0.0, 0.0, 0.0, 0.0],
]

active_options = [True, False]
code_options = ["python", "typescript", "", None]
age_options = [40, 50, 60, 65, 75]

vector_search = AzureSQLNativeVectorSearchClient(connection_string, "n_products")

for i in range(len(embeddings)):
    embedding = embeddings[i]
    name = "Izzy {}".format(i)
    content = "Israel Ekpo {} {}".format(i, embedding)
    active = active_options[i % 2]
    code = code_options[i % 4]
    age = age_options[i % 5]

    # metadata containing integer, float, string, boolean and null types
    metadata = {"content": content, "name": name, "active": active, "code": code, "age": age, "mass": i / age}
    result = vector_search.insert_row(content, metadata, embedding)
    print(i, "->", embedding)

````
## Examples of How to Query the Vector Database using the Search Client

In this section, we are going to cover the following examples using the Classic and Native clients

- Query with default values for COSINE, INNER PRODUCT AND EUCLIDEAN
- Query with k
- Query with filters
- Query with k and filters
- Query with distance strategy method


#### Using AzureSQLClassicVectorSearchClient

````python 
import os
from azure_sql_vector_search import AzureSQLClassicVectorSearchClient, DistanceMetric

connection_string = os.environ.get("AZURE_SQL_CONNECTION_STRING")

embedding = [0.5, 0.5, 0.5, 0.5]
k = 40
filters = {"active": True, "age": 40}

vector_search = AzureSQLClassicVectorSearchClient(connection_string, "products")

# Using custom value for top k results and filters
print("Cosine Similarity for ", embedding)
results_1 = vector_search.compute_similarity(embedding, DistanceMetric.COSINE_SIMILARITY, k, filters=filters)
print(results_1)

# No filters but showing the top 40 results
print("Inner Product Distance for ", embedding)
results_2 = vector_search.compute_similarity(embedding, DistanceMetric.DOT_PRODUCT, k)
print(results_2)

# Using no filters with the default top 4 results for k
print("Euclidean Distance for ", embedding)
results_3 = vector_search.compute_similarity(embedding, DistanceMetric.EUCLIDEAN_DISTANCE)
print(results_3)

print("Cosine Similarity for ", embedding)
results_4 = vector_search.cosine_similarity(embedding, k=k, filters=filters)
print(results_4)

print("Inner Product Distance for ", embedding)
results_5 = vector_search.inner_product(embedding, k=k, filters=filters)
print(results_5)

print("Euclidean Distance for ", embedding)
results_6 = vector_search.euclidean_distance(embedding, k=k, filters=filters)
print(results_6)
````

#### Using AzureSQLNativeVectorSearchClient

````python 

import os
from azure_sql_vector_search import AzureSQLNativeVectorSearchClient

connection_string = os.environ.get("AZURE_SQL_CONNECTION_STRING")

embedding = [0.5, 0.5, 0.5, 0.5]
k = 40
filters = {"active": True, "age": 40}

vector_search = AzureSQLNativeVectorSearchClient(connection_string, "n_products")

# Using custom value for top k results and filters
print("Cosine Similarity for ", embedding)
results_1 = vector_search.compute_similarity(embedding, DistanceMetric.COSINE_SIMILARITY, k, filters=filters)
print(results_1)

# No filters but showing the top 40 results
print("Inner Product Distance for ", embedding)
results_2 = vector_search.compute_similarity(embedding, DistanceMetric.DOT_PRODUCT, k)
print(results_2)

# Using no filters with the default top 4 results for k
print("Euclidean Distance for ", embedding)
results_3 = vector_search.compute_similarity(embedding, DistanceMetric.EUCLIDEAN_DISTANCE)
print(results_3)

# Using filters to pick top 40 matches for Cosine Similarity
print("Cosine Similarity for ", embedding)
results_4 = vector_search.cosine_similarity(embedding, k=k, filters=filters)
print(results_4)

# Using filters to pick top 40 matches for Dot Product
print("Inner Product Distance for ", embedding)
results_5 = vector_search.inner_product(embedding, k=k, filters=filters)
print(results_5)

# Using filters to pick top 40 matches for Euclidean Distance
print("Euclidean Distance for ", embedding)
results_6 = vector_search.euclidean_distance(embedding, k=k, filters=filters)
print(results_6)


````
## How to Reach Out with Questions and Feedback

If you have any questions, please reach out to us at ***vectorsqlintegration at service dot microsoft dot com***

Happy vector search! 
